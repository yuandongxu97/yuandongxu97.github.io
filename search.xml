<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>WSL（Windows Subsystem for Linux）使用笔记</title>
    <url>/2020/%E9%9A%8F%E7%AC%94/WSL/</url>
    <content><![CDATA[<p>Windows Subsystem for Linux（简称WSL）是一个在Windows 10上能够运行原生Linux二进制可执行文件（ELF格式）的兼容层。它是由Microsoft与Canonical公司合作开发，最初目标是使纯正的Ubuntu 14.04 “Trusty Tahr”映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。</p>
<ul>
<li>WSL的安装</li>
<li>WSL2版本转换</li>
<li>重启WSL的方法</li>
<li>Windows中查看WSL文件的方法</li>
<li><a href="#Windows%E4%B8%8EWSL%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%B7%B7%E6%B7%86%E7%9A%84%E9%97%AE%E9%A2%98">Windows 与 WSL 环境变量混淆的问题</a></li>
</ul>
<a id="more"></a>

<hr>
<h4 id="WSL的安装"><a href="#WSL的安装" class="headerlink" title="WSL的安装"></a>WSL的安装</h4><p>WSL一定向前兼容，所以将Windows更新至最新</p>
<p><strong>开启Windows的虚拟机平台和WSL功能：</strong>以<strong>管理员权限</strong>启动 PowerShell，，完成后重启计算机完成配置。</p>
<pre><code class="line-numbers language-powershell">Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform               # 启用虚拟机平台
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux    # 启用 Linux 子系统功能</code></pre>
<p><strong>配置wsl默认版本为wsl2</strong>：在以后安装 Linux 的时候默认启用 WSL2，需要下载安装一个补丁：wsl_update_x64.msi</p>
<pre><code class="line-numbers language-powershell">wsl --set-default-version 2</code></pre>
<p><strong>下载系统镜像</strong>：到windows store下载一个Linux发行版本系统，如Ubuntu、Ubuntu18等，注意当下载完成时实际上并没有完成实际的安装</p>
<p><strong>镜像的安装</strong>：返回桌面按win键搜索下载的Linux名称运行一次完成安装</p>
<h4 id="WSL的停止与重启"><a href="#WSL的停止与重启" class="headerlink" title="WSL的停止与重启"></a>WSL的停止与重启</h4><p>因为系统控制的某些原因，WSL内执行<code>reboot</code>并不能控制WSL的重启，所以在不重启Windows的情况下需要重启WSL需要使用以下命令</p>
<p><strong>管理员权限启动CMD/Powershell</strong></p>
<pre><code class="line-numbers language-powershell">net stop LxssManager         # 停止
net start LxssManager        # 启动</code></pre>
<h4 id="使用文件管理器查看WSL文件的方法"><a href="#使用文件管理器查看WSL文件的方法" class="headerlink" title="使用文件管理器查看WSL文件的方法"></a>使用文件管理器查看WSL文件的方法</h4><p>打开文件管理器，点击地址栏，输入<code>\\wsl$</code>回车会显示所有已安装的wsl的文件系统</p>
<p>比如我只安装了一个wsl发行版本，名称为Ubuntu</p>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200902153211.png"></p>
<h4 id="Windows与WSL环境变量混淆的问题"><a href="#Windows与WSL环境变量混淆的问题" class="headerlink" title="Windows与WSL环境变量混淆的问题"></a>Windows与WSL环境变量混淆的问题</h4><p>wsl具有互交互特性：</p>
<p>windows与wsl都配置好node环境后，wsl内使用<code>node</code>会调用到Windows的node，脑袋疼···</p>
<p>查了好多博客，解决方法</p>
<pre><code class="line-numbers language-bash">sudo vim /etc/wsl.conf</code></pre>
<pre><code class="line-numbers language-shell">[interop]
enabled=false
appendWindowsPath=false</code></pre>
<pre><code class="line-numbers language-bash"># 重启wsl
net stop LxssManager        
net start LxssManager    </code></pre>
<h4 id="WSL常用命令"><a href="#WSL常用命令" class="headerlink" title="WSL常用命令"></a>WSL常用命令</h4><p>用法：<code>wsl.exe [参数] [选项...] [命令行]</code></p>
<pre><code class="line-numbers language-powershell">$ wsl --help
版权所有 (c) Microsoft Corporation。保留所有权利。



用于运行 Linux 二进制文件的参数:

    如果未提供命令行，wsl.exe 将启动默认的 shell。

    --exec, -e &lt;命令行&gt;
        执行指定的命令而不使用默认的 Linux shell。

    --
        按原样传递剩余的命令行。

选项:
    --distribution, -d &lt;分发版&gt;
        运行指定的分发。

    --user, -u &lt;用户名&gt;
        以指定用户身份运行。

用于管理适用于 Linux 的 Windows 子系统的参数:

    --export &lt;分发版&gt; &lt;文件名&gt;
        将分发导出到 tar 文件。
        对于标准输出，文件名可以是 -。

    --import &lt;分发版&gt; &lt;安装位置&gt; &lt;文件名&gt; [选项]
        将指定的 tar 文件作为新分发进行导入。
        对于标准输入，文件名可以是 -。

    --list, -l [选项]
        列出分发。
        选项:
            --all        # 列出所有分发，包括当前正在安装或卸载的分发。
            --running        # 只列出当前正在运行的分发。
            --quiet, -q        # 只显示分发名称。
            --verbose, -v        # 显示有关所有分发的详细信息。
    --set-default, -s &lt;分发版&gt;        # 将分发设置为默认值。
    --set-default-version &lt;版本&gt;        # 更改新分发的默认安装版本。
    --set-version &lt;分发版&gt; &lt;版本&gt;        # 更改指定分发的版本。
    --shutdown        # 立即终止所有正在运行的分发和 WSL 2 轻型工具虚拟机。
    --terminate, -t &lt;分发版&gt;        # 终止指定的分发。
    --unregister &lt;分发版&gt;        # 注销分发。
    --help        # 显示用法信息。</code></pre>
]]></content>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python命名空间及作用域总结</title>
    <url>/2020/Python/Python%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h4 id="命名空间（namespace）-名称存储"><a href="#命名空间（namespace）-名称存储" class="headerlink" title="命名空间（namespace）- 名称存储"></a>命名空间（namespace）- 名称存储</h4><blockquote>
<p>官方文档说明：</p>
<p><em>A namespace is a mapping from names to objects.Most namespaces are currently implemented as Python dictionaries。</em></p>
<p>命名空间是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。</p>
</blockquote>
<p>命名空间其实就是Python对象名称的保存位置，各个命名空间是独立的，因此两个相互独立的函数中可以各有一个<code>a</code>变量，不同的命名空间中的对象名称是可以重名而没有任何影响。</p>
<h4 id="作用域（scope）-名称查找"><a href="#作用域（scope）-名称查找" class="headerlink" title="作用域（scope）- 名称查找"></a>作用域（scope）- 名称查找</h4><blockquote>
<p>官方文档说明：</p>
<p><em>A scope is a textual region of a Python program where a namespace is directly accessible. “Directly accessible” here means that an unqualified reference to a name attempts to find the name in the namespace.</em></p>
<p>作用域即代码可以直接访问命名空间的区域</p>
</blockquote>
<p>python中对象不是哪个位置都可以访问的，访问权限决定于这个对象是在哪里创建的，假设你在X处可以访问到A命名空间的变量，那么X就是A的作用域之一，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。</p>
<a id="more"></a>

<hr>
<h4 id="命名空间种类"><a href="#命名空间种类" class="headerlink" title="命名空间种类"></a>命名空间种类</h4><p>Python中一般认为有三种命名空间：</p>
<ul>
<li><strong>内置命名空间（built-in</strong>）：Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。</li>
<li><strong>全局命名空间（global）</strong>：模块级定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量等。</li>
<li><strong>局部命名空间（local）</strong>：类变量、函数变量等，注意local的区分是相对的</li>
</ul>
<p>查找优先级：<strong>局部 -&gt; 全局 -&gt; 内置</strong></p>
<h4 id="作用域种类"><a href="#作用域种类" class="headerlink" title="作用域种类"></a>作用域种类</h4><p>作用域有四种：</p>
<ul>
<li><strong>Local</strong>：本地最内层，包含局部变量，比如一个函数内部。</li>
<li><strong>Enclosing</strong>：本地中间层，包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A里面又包含了一个函数B ，那么对于B中的名称来说A中的作用域就为nonlocal。</li>
<li><strong>Global</strong>：本地外层，比如当前模块的全局变量。</li>
<li><strong>Built-in</strong>： Python内置，包含了内建的变量/关键字等，最后被搜索</li>
</ul>
<p>规则顺序： <strong>L –&gt; E –&gt; G –&gt;B</strong>，在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。</p>
<h4 id="作用域实例"><a href="#作用域实例" class="headerlink" title="作用域实例"></a>作用域实例</h4><p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200912201511.png"></p>
<pre><code># test.py
a = 0  # 全局作用域
def outer():
    a = 1  # 闭包函数外函数中
    def inner():
        a = 2  # 局部作用域</code></pre>
<h4 id="全局变量与局部变量"><a href="#全局变量与局部变量" class="headerlink" title="全局变量与局部变量"></a>全局变量与局部变量</h4><p>这是两个最常见的变量区分方法，</p>
<p>全局变量说白了模块(单个.py文件中)直接声明的变量。</p>
<p>局部变量是模块内的类或函数中定义的变量</p>
<h4 id="内置作用域的定义实现"><a href="#内置作用域的定义实现" class="headerlink" title="内置作用域的定义实现"></a>内置作用域的定义实现</h4><p>内置作用域是通过 builtin 标准模块来实现的，但builtin 的变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。Python3中</p>
<pre><code class="line-numbers language-python">import builtins
dir(builtins)        # 查看到底预定义了哪些变量
builtins.__dict__    # 查看模块详细信息</code></pre>
<h4 id="何时引入新作用域"><a href="#何时引入新作用域" class="headerlink" title="何时引入新作用域"></a>何时引入新作用域</h4><p>Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问</p>
<pre><code class="line-numbers language-python">In [18]: if True:
    ...:     a = 1
    ...:

In [19]: a
Out[19]: 1</code></pre>
<h4 id="global-和-nonlocal关键字"><a href="#global-和-nonlocal关键字" class="headerlink" title="global 和 nonlocal关键字"></a>global 和 nonlocal关键字</h4><p>函数内（局部变量空间）虽然可以使用全局命名空间的变量（全局变量）</p>
<pre><code class="line-numbers language-python">num = 10
def func():
    print(num)
func()
# 10</code></pre>
<p>但并不能直接修改</p>
<pre><code class="line-numbers language-python">num = 10
def func():
    num += 1
    print(num)
func()
# UnboundLocalError: local variable &#39;num&#39; referenced before assignment</code></pre>
<p>当内部作用域想修改外部作用域的变量时，就要用到global关键字预先声明了</p>
<pre><code class="line-numbers language-python">num = 10
def func():
    global num
    num += 10
    print(num)
func()
print(num)
# 20
# 20</code></pre>
<p>如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了</p>
<pre><code class="line-numbers language-python">num = 1
def outer():
    num = 10
    def inner():
        nonlocal num   # nonlocal关键字声明
        num = 100
        print(num)
    inner()
    print(num)
outer()
# 100
# 100</code></pre>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy框架笔记· 配置详解</title>
    <url>/2020/%E7%88%AC%E8%99%AB/scrapy%20settings/</url>
    <content><![CDATA[<p>Scrapy 提供了settings对象，用户可以通过配置该对象定制核心（core）、插件（extension）、pipeline 及 spider 组件的行为，如请求头、下载并发等。</p>
<p>Scrapy 提供了很多种配置的方法，不同的方法有不同的优先级和作用范围，高优先级会覆盖掉低优先级的配置：</p>
<ul>
<li>命令行选项（最高优先级）</li>
<li>每个spider的设定</li>
<li>项目设定模块</li>
<li>命令默认设定模块</li>
<li>全局默认设定（最低优先级）</li>
</ul>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNjcmFweS5vcmcvZW4vbGF0ZXN0L3RvcGljcy9jb21tYW5kcy5odG1s">scrapy document v2.1<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>

<hr>
<h3 id="常用配置项"><a href="#常用配置项" class="headerlink" title="常用配置项"></a>常用配置项</h3><ul>
<li>CONCURRENT_ITEMS：项目管道最大并发数</li>
<li>CONCURRENT_REQUESTS： scrapy下载器最大并发数</li>
<li>DOWNLOAD_DELAY：访问同一个网站的间隔时间，单位秒。一般默认为0.5*<code>DOWNLOAD_DELAY</code>到1.5 *<code>DOWNLOAD_DELAY</code>之间的随机值。也可以设置为固定值，由<code>RANDOMIZE_DOWNLOAD_DELAY</code>指定是否固定，默认True随机。这里的同一个网站可以是域名也可以是IP，由<code>CONCURRENT_REQUESTS_PER_IP</code>的值决定。</li>
<li>CONCURRENT_REQUESTS_PER_DOMAIN：对单个域名的最大并发</li>
<li>CONCURRENT_REQUESTS_PER_IP：对单个IP的最大并发，如果值不为0，则<code>CONCURRENT_REQUESTS_PER_DOMAIN</code>参数被忽略，而且<code>DOWNLOAD_DELAY</code>这个参数的同一网站指的是IP</li>
<li>DEFAULT_ITEM_CLASS：执行scrapy shell 命令的默认item类，默认<code>scrapy.item.Item</code></li>
<li>DEPTH_LIMIT：爬取的最大深度</li>
<li>DEPTH_PRIORITY：正值为广度优先(BFO)，负值为深度优先(DFO)，计算公式：<code>request.priority = request.priority - ( depth * DEPTH_PRIORITY )</code></li>
<li>COOKIES_ENABLED： 是否启用cookie中间件，也就是自动cookie管理</li>
<li>COOKIES_DEBUG：将请求cookie和响应包含Set-Cookie的写入日志</li>
<li>DOWNLOADER_MIDDLEWARE：下载器中间件和优先级的字典</li>
<li>DEFAULT_REQUEST_HEADERS：用于Scrapy HTTP请求的默认标头</li>
<li>DUPEFILTER_CLASS：去重的类，可以改成使用布隆过滤器，而不使用默认的</li>
<li>LOG_ENABLED：是否启用日志</li>
<li>LOG_FILE：日志文件路径，默认为None</li>
<li>LOG_FORMAT：日志格式化表达式</li>
<li>LOG_DATEFORMAT：<code>LOG_FORMAT</code>中的时间格式化表达式</li>
<li>LOG_LEVEL：最低日志级别，默认DEBUG，可用：CRITICAL, ERROR, WARNING, INFO, DEBUG</li>
<li>LOG_STDOUT：是否将所有标准输出（和错误）将被重定向到日志，例如print也会被记录在日志</li>
<li>LOG_SHORT_NAMES：如果为True，则日志将仅包含根路径;如果设置为False，则显示负责日志输出的组件</li>
<li>LOGSTATS_INTERVAL：每次统计记录打印输出之间的间隔</li>
<li>MEMDEBUG_ENABLED：是否启用内存调试</li>
<li>REDIRECT_MAX_TIMES：定义可以重定向请求的最长时间</li>
<li>REDIRECT_PRIORITY_ADJUST：调整重定向请求的优先级，为正值时优先级高</li>
<li>RETRY_PRIORITY_ADJUST：调整重试请求的优先级</li>
<li>ROBOTSTXT_OBEY：是否遵循robot协议</li>
<li>SCRAPER_SLOT_MAX_ACTIVE_SIZE：正在处理响应数据的软限制（以字节为单位），如果所有正在处理的响应的大小总和高于此值，Scrapy不会处理新的请求。</li>
<li>SPIDER_MIDDLEWARES：蜘蛛中间件</li>
<li>USER_AGENT：默认使用的User-Agent</li>
</ul>
<h3 id="各优先级的配置方法"><a href="#各优先级的配置方法" class="headerlink" title="各优先级的配置方法"></a>各优先级的配置方法</h3><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><pre><code class="line-numbers language-bash">scrapy crawl myspider -s LOG_FILE=scrapy.log
scrapy crawl myspider --set USER_AGENT=Mozilla/Firefox</code></pre>
<h4 id="Spider"><a href="#Spider" class="headerlink" title="Spider"></a>Spider</h4><pre><code class="line-numbers language-python">import scrapy
from scrapy.linkextractors import LinkExtractor
from scrapy.spiders import CrawlSpider, Rule
class DemoSpider(scrapy.Spider):
    name = &#39;demo&#39;
    # 定义相关设置
    custom_settings = &#123;
       &#39;CONCURRENT_ITEMS&#39;: 88,                 # 设定同时处理的结果个数
       &#39;CONCURRENT_REQUESTS&#39;: 66              # 设置同时处理的请求个数
    &#125;
    def parse_item(self, response):           
        pass</code></pre>
<h4 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h4><p>由项目根的<code>scrapy.cfg</code>指定</p>
<pre><code class="line-numbers language-python"># settings.py
ROBOTSTXT_OBEY = False                      # 是否遵循robots协议</code></pre>
<h4 id="命令默认"><a href="#命令默认" class="headerlink" title="命令默认"></a>命令默认</h4><p>就是 scrapy.cfg 文件，其采用 ini 格式，和普通的配置文件用法相同。其会在下面的位置查找该文件。</p>
<ul>
<li>系统级别：/etc/scrapy.cfg或c:\scrapy\scrapy.cfg。</li>
<li>用户级别：<del>/.config/scrapy.cfg($XDG_CONFIG_HOME)及</del>/.scrapy.cfg($HOME)。</li>
<li>项目级别：在 Scrapy 项目根路径下的 scrapy.cfg。</li>
</ul>
<h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><p>全局默认设定存储在 scrapy.settings.default_settings 模块。</p>
<h3 id="读取配置对象的方法"><a href="#读取配置对象的方法" class="headerlink" title="读取配置对象的方法"></a>读取配置对象的方法</h3><p>spider</p>
<pre><code class="line-numbers language-python">class MySpider(scrapy.Spider):
    name = &#39;myspider&#39;
    start_urls = [&#39;http://example.com&#39;]

    def parse(self, response):
        print(self.settings)    # 配置对象
        print(self.settings.attributes)        # 属性字典
        print(self.settings.attributes.get(&#39;CONCURRENT_REQUESTS&#39;))        # 获取指定属性值</code></pre>
<p>在scrapy shell中可以直接使用变量settings进行访问</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200913201933.png"></p>
<p>在extensions、middlewares 、item pipelines中通过<a href="https://docs.scrapy.org/en/latest/topics/api.html#scrapy.crawler.Crawler.settings"><code>scrapy.crawler.Crawler.settings</code></a>的实现方法from_crawler传递配置对象</p>
<pre><code class="line-numbers language-python">class MyExtension:
    def __init__(self, log_is_enabled=False):
        if log_is_enabled:
            print(&quot;log is enabled!&quot;)

    @classmethod
    def from_crawler(cls, crawler):
        settings = crawler.settings
        return cls(settings.getbool(&#39;LOG_ENABLED&#39;))</code></pre>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS、Xpath选择器语法及实例参考</title>
    <url>/2020/%E7%88%AC%E8%99%AB/css%E3%80%81xpath%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>xpath，XML路径语言。用来在HTML/XML文档中查找信息的语言，使用<strong>路径表达式</strong>来获取节点/节点集，和文件系统路径类似。</p>
<p>css，层叠样式表，用于定位网页中的位置</p>
<p>css常用于批量定位，较为粗糙；xpath定位精度更高</p>
<a id="more"></a>

<hr>
<h2 id="CSS选择器语法"><a href="#CSS选择器语法" class="headerlink" title="CSS选择器语法"></a>CSS选择器语法</h2><p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200913173434.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200913173446.png"></p>
<h2 id="Xpath选择器语法"><a href="#Xpath选择器语法" class="headerlink" title="Xpath选择器语法"></a>Xpath选择器语法</h2><h3 id="路径表达式"><a href="#路径表达式" class="headerlink" title="路径表达式"></a>路径表达式</h3><table>
<thead>
<tr>
<th align="center">语法</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">nodename</td>
<td>选择名称为nodename的所有节点</td>
<td>div/p，选取div子结点中p标签</td>
</tr>
<tr>
<td align="center">/</td>
<td>从根节点选取</td>
<td>/div</td>
</tr>
<tr>
<td align="center">//</td>
<td>选择所有节点，不考虑位置</td>
<td>div//p，选取div子孙节点中所有p标签</td>
</tr>
<tr>
<td align="center">.</td>
<td>选择当前节点</td>
<td></td>
</tr>
<tr>
<td align="center">..</td>
<td>选择当前节点的父节点，用于选择绝对路径</td>
<td>..</td>
</tr>
<tr>
<td align="center">@</td>
<td>选择属性</td>
<td>a/@href，选取a标签的href属性</td>
</tr>
<tr>
<td align="center">text()</td>
<td>选择文本</td>
<td>a/@href/text()，选取a标签的href属性的值<br />a/text()，选取a标签下所有文本</td>
</tr>
</tbody></table>
<h3 id="谓语"><a href="#谓语" class="headerlink" title="谓语"></a>谓语</h3><p>谓语被嵌在方括号内，用来查找某个特定的节点或包含某个制定的值的节点</p>
<table>
<thead>
<tr>
<th align="center">语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">//div/p[1]</td>
<td>选择div标签下的第一个p标签</td>
</tr>
<tr>
<td align="center">/div/p[last()]</td>
<td>选择div标签下的最后一个p标签</td>
</tr>
<tr>
<td align="center">/div/p[last()-1]</td>
<td>选择div标签下的倒数第二个p标签</td>
</tr>
<tr>
<td align="center">/div/p[position()&lt;3]</td>
<td>选择div下的前两个p标签</td>
</tr>
<tr>
<td align="center">//div[@class]</td>
<td>选取所有拥有属性为class的div节点</td>
</tr>
<tr>
<td align="center">//div[@class=”main”]</td>
<td>选取所有div下class属性为main的div节点</td>
</tr>
<tr>
<td align="center">//div[price&gt;3.5]</td>
<td>选取所有div下元素值price大于3.5的节点</td>
</tr>
</tbody></table>
<h3 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th>用法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">starts-with</td>
<td>//div[starts-with(@id,”ma”)]</td>
<td>起点匹配，选取id值以ma开头的div节点</td>
</tr>
<tr>
<td align="center">contains</td>
<td>//div[contains(@id,”ma”)]</td>
<td>包含匹配，选取所有id值包含ma的div节点</td>
</tr>
<tr>
<td align="center">and</td>
<td>//div[contains(@id,”ma”) and contains(@id,”in”)]</td>
<td>多值匹配，选取id值包含ma和in的div节点</td>
</tr>
<tr>
<td align="center">text()</td>
<td>//div[contains(text(),”ma”)]</td>
<td>文本匹配，选取节点文本包含ma的div节</td>
</tr>
</tbody></table>
<pre><code class="line-numbers language-python">string(.)        # 解析当前节点下所有text并拼接为字符串</code></pre>
<h3 id="选取若干路径"><a href="#选取若干路径" class="headerlink" title="选取若干路径"></a>选取若干路径</h3><p>通过在路径表达式中使用“|”运算符，可以选取若干个路径。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200913173327.png"></p>
<h3 id="通配"><a href="#通配" class="headerlink" title="通配"></a>通配</h3><p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200913173204.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200913173239.png"></p>
<h2 id="Python实例"><a href="#Python实例" class="headerlink" title="Python实例"></a>Python实例</h2><p>待解析文本<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNjcmFweS5vcmcvZW4vbGF0ZXN0L3RvcGljcy9zZWxlY3RvcnMuaHRtbCNpZDE=">来源<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="创建response对象"><a href="#创建response对象" class="headerlink" title="创建response对象"></a>创建response对象</h3><pre><code class="line-numbers language-python">from scrapy.selector import Selector

html = &quot;&quot;&quot;
&lt;html&gt;
 &lt;head&gt;
  &lt;base href=&#39;http://example.com/&#39; /&gt;
  &lt;title&gt;Example website&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;div id=&#39;images&#39;&gt;
   &lt;a href=&#39;image1.html&#39;&gt;Name: My image 1 &lt;br /&gt;&lt;img src=&#39;image1_thumb.jpg&#39; /&gt;&lt;/a&gt;
   &lt;a href=&#39;image2.html&#39;&gt;Name: My image 2 &lt;br /&gt;&lt;img src=&#39;image2_thumb.jpg&#39; /&gt;&lt;/a&gt;
   &lt;a href=&#39;image3.html&#39;&gt;Name: My image 3 &lt;br /&gt;&lt;img src=&#39;image3_thumb.jpg&#39; /&gt;&lt;/a&gt;
   &lt;a href=&#39;image4.html&#39;&gt;Name: My image 4 &lt;br /&gt;&lt;img src=&#39;image4_thumb.jpg&#39; /&gt;&lt;/a&gt;
   &lt;a href=&#39;image5.html&#39;&gt;Name: My image 5 &lt;br /&gt;&lt;img src=&#39;image5_thumb.jpg&#39; /&gt;&lt;/a&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;
&quot;&quot;&quot;

response = Selector(text=html)</code></pre>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200913142037.png"></p>
<h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><pre><code class="line-numbers language-python">In [9]: response.xpath(&#39;//title/text()&#39;).get()
Out[9]: &#39;Example website&#39;</code></pre>
<h4 id="属性的值"><a href="#属性的值" class="headerlink" title="属性的值"></a>属性的值</h4><pre><code class="line-numbers language-python">response.xpath(&#39;//a//@href&#39;).getall()
# [&#39;image1.html&#39;, &#39;image2.html&#39;, &#39;image3.html&#39;, &#39;image4.html&#39;, &#39;image5.html&#39;]</code></pre>
<h4 id="标签、指定属性的文本"><a href="#标签、指定属性的文本" class="headerlink" title="标签、指定属性的文本"></a>标签、指定属性的文本</h4><pre><code class="line-numbers language-python">response.xpath(&#39;//a[@href=&quot;image3.html&quot;]/text()&#39;).getall()
# [&#39;Name: My image 3 &#39;]</code></pre>
<h4 id="标签、指定属性的其他属性值"><a href="#标签、指定属性的其他属性值" class="headerlink" title="标签、指定属性的其他属性值"></a>标签、指定属性的其他属性值</h4><pre><code class="line-numbers language-python">response.xpath(&#39;//a[@href=&quot;image3.html&quot;]/img/@src&#39;).getall()
# [&#39;image3_thumb.jpg&#39;]</code></pre>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>常用</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Terminal安装及配置使用</title>
    <url>/2020/%E9%9A%8F%E7%AC%94/Windows%20Terminal/</url>
    <content><![CDATA[<p>Windows 终端是一个面向命令行工具和 shell（如命令提示符、PowerShell 和适用于 Linux 的 Windows 子系统 (WSL)）用户的新式终端应用程序。 它的主要功能包括多个选项卡、窗格、Unicode 和 UTF-8 字符支持、GPU 加速文本呈现引擎，还可以用于创建你自己的主题并自定义文本、颜色、背景和快捷键绑定。</p>
<p><img src="https://docs.microsoft.com/zh-cn/windows/terminal/images/overview.png"></p>
<a id="more"></a>

<hr>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>windows应用商店里搜索即可安装</p>
<p>Github项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC90ZXJtaW5hbA==">https://github.com/microsoft/terminal<i class="fa fa-external-link-alt"></i></span> ，可以下载release版本进行安装</p>
<p>官方手册：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vemgtY24vd2luZG93cy90ZXJtaW5hbC8=">https://docs.microsoft.com/zh-cn/windows/terminal/<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><p>Window Terminal通过profiles.json来配置</p>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200904222401.png"></p>
<ol>
<li><p>每配置一种类型的命令行界面都需要一个不同的<code>guid</code>，可以通过<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ3VpZGdlbi5jb20v">Create GUIDs online<i class="fa fa-external-link-alt"></i></span>生成</p>
</li>
<li><p>配置文件配置项说明</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>释义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>alwaysShowTabs</td>
<td>始终显示标签</td>
<td></td>
</tr>
<tr>
<td>defaultProfile</td>
<td>默认终端</td>
<td>GUID，用于连接终端配置</td>
</tr>
<tr>
<td>initialCols</td>
<td>默认列数</td>
<td></td>
</tr>
<tr>
<td>initialRows</td>
<td>默认行数</td>
<td></td>
</tr>
<tr>
<td>keybindings</td>
<td>快捷键配置</td>
<td></td>
</tr>
<tr>
<td>command</td>
<td>快捷键执行的命令</td>
<td></td>
</tr>
<tr>
<td>keys</td>
<td>快捷键</td>
<td></td>
</tr>
<tr>
<td>requestedTheme</td>
<td>主题</td>
<td></td>
</tr>
<tr>
<td>showTabsInTitlebar</td>
<td>在标题栏中显示终端窗口标签栏</td>
<td></td>
</tr>
<tr>
<td>showTerminalTitleInTitlebar</td>
<td>在标签栏中显示终端标签</td>
<td></td>
</tr>
<tr>
<td>acrylicOpacity</td>
<td>不透明度</td>
<td></td>
</tr>
<tr>
<td>closeOnExit</td>
<td>退出后关闭</td>
<td></td>
</tr>
<tr>
<td>colorScheme</td>
<td>颜色主题</td>
<td></td>
</tr>
<tr>
<td>commandline</td>
<td>命令行程序</td>
<td></td>
</tr>
<tr>
<td>cursorColor</td>
<td>光标颜色</td>
<td></td>
</tr>
<tr>
<td>cursorShape</td>
<td>光标形状</td>
<td></td>
</tr>
<tr>
<td>fontFace</td>
<td>字体</td>
<td></td>
</tr>
<tr>
<td>fontSize</td>
<td>字体大小</td>
<td></td>
</tr>
<tr>
<td>guid</td>
<td>GUID</td>
<td>终端配置标识</td>
</tr>
<tr>
<td>historySize</td>
<td>历史大小</td>
<td></td>
</tr>
<tr>
<td>icon</td>
<td>图标</td>
<td></td>
</tr>
<tr>
<td>name</td>
<td>名称</td>
<td></td>
</tr>
<tr>
<td>padding</td>
<td>内容距离界面的内部距离</td>
<td></td>
</tr>
<tr>
<td>snapOnInput</td>
<td>嗅探输入</td>
<td></td>
</tr>
<tr>
<td>startingDirectory</td>
<td>初始目录</td>
<td></td>
</tr>
<tr>
<td>useAcrylic</td>
<td>使用不透明度</td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h3><h4 id="1-配置：cmd下通过bash命令打开git命令行"><a href="#1-配置：cmd下通过bash命令打开git命令行" class="headerlink" title="1. 配置：cmd下通过bash命令打开git命令行"></a>1. 配置：cmd下通过<code>bash</code>命令打开git命令行</h4><ul>
<li><p>打开环境变量配置</p>
<p><img src="https://img2018.cnblogs.com/blog/1536549/202001/1536549-20200119103742020-888134717.png" alt="img"></p>
</li>
<li><p>配置Path</p>
<p><img src="https://img2018.cnblogs.com/blog/1536549/202001/1536549-20200119104202576-1352584275.png" alt="img"></p>
</li>
<li><p>cmd下打开git</p>
</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1536549/202001/1536549-20200119104145720-438416481.png" alt="img"></p>
<h4 id="2-配置Window-Terminal的profile-json"><a href="#2-配置Window-Terminal的profile-json" class="headerlink" title="2. 配置Window Terminal的profile.json"></a>2. 配置Window Terminal的profile.json</h4><p>在<code>profiles</code>属性值的数组里添加以下json</p>
<pre><code class="line-numbers language-json">&#123;
    &quot;guid&quot;: &quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6109&#125;&quot;, // GUID,终端配置标识,每个都必须不一样
    &quot;commandline&quot;: &quot;bash.exe&quot;,  // 命令
    &quot;name&quot;: &quot;git-bash&quot;, // 给它一个名字来与其他界面分开
    &quot;tabTitle&quot;: &quot;Git Bash&quot;,  // 给它一个标签页的名字
    &quot;snapOnInput&quot;: true,  // 捕捉输入
    &quot;startingDirectory&quot;: &quot;%USERPROFILE%&quot;,  // 打开当前用户根目录
    &quot;historySize&quot;: 9001,  // 历史大小
    &quot;closeOnExit&quot;: true,  // 退出后关闭
    &quot;icon&quot;: &quot;D:/Program Files/Git/mingw64/share/git/git-for-windows.ico&quot;  // 其实是安装Git以后自带的icon
&#125;</code></pre>
<h3 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h3><h4 id="1-配置远程连接"><a href="#1-配置远程连接" class="headerlink" title="1. 配置远程连接"></a>1. 配置远程连接</h4><ul>
<li><p>配置公钥密钥</p>
<p>Linux下可以直接通过shell命令配置，Window下通过Git的<code>git bash</code>来完成类似shell命令的功能</p>
<p><code>ssh-keygen -t rsa</code></p>
<p><img src="https://img2018.cnblogs.com/blog/1536549/202001/1536549-20200119103930853-783799958.png" alt="img"></p>
</li>
<li><p>配置远程连接文件</p>
<p>在<code>C:\Users\11064\.ssh</code>目录下，<code>11064</code>是我的用户名，新建<code>config</code>命名的文件(没有后缀名)，配置远程连接</p>
</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1536549/202001/1536549-20200119103831005-1208574898.png" alt="img"></p>
<h4 id="2-cmd下可以远程连接"><a href="#2-cmd下可以远程连接" class="headerlink" title="2. cmd下可以远程连接"></a>2. cmd下可以远程连接</h4><p><img src="https://img2018.cnblogs.com/blog/1536549/202001/1536549-20200119103814954-1143916604.png" alt="img"></p>
<h4 id="3-配置profiles-json"><a href="#3-配置profiles-json" class="headerlink" title="3. 配置profiles.json"></a>3. 配置profiles.json</h4><pre><code class="line-numbers language-json">&#123;
    &quot;guid&quot;: &quot;&#123;9a138488-58fc-4a7a-b3c2-3af9ba5bc7bb&#125;&quot;,
    &quot;commandline&quot;: &quot;ssh fengzi&quot;,
    &quot;name&quot;: &quot;aliyun-Ubuntu&quot;,
    &quot;tabTitle&quot;: &quot;aliyun-Ubuntu&quot;,
    &quot;snapOnInput&quot;: true,
    &quot;historySize&quot;: 9001,
    &quot;closeOnExit&quot;: true,
    &quot;icon&quot;: &quot;C:/Users/11064/.ssh/icon/ubuntu-icon.png&quot;   // 自己找的一个图标
&#125;</code></pre>
<h3 id="配置背景图片"><a href="#配置背景图片" class="headerlink" title="配置背景图片"></a>配置背景图片</h3><p><strong>最喜欢的配置项</strong></p>
<p>以<code>profiles.json</code>里的<code>power shell</code>配置项为例</p>
<pre><code class="line-numbers language-json">&#123;
      // Make changes here to the powershell.exe profile
      &quot;guid&quot;: &quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;,
      &quot;name&quot;: &quot;power shell&quot;,
      &quot;commandline&quot;: &quot;powershell.exe&quot;,
      &quot;hidden&quot;: false,
      &quot;useAcrylic&quot;: true, // 使用不透明度
      &quot;backgroundImage&quot;: &quot;C:/Users/11064/Desktop/vscode_bc/ab2bff80gy1g7oxngj7whj21900u0go6.jpg&quot;, // 背景图片
      &quot;backgroundImageOpacity&quot;: 0.6,  // 背景图片不透明度
      &quot;backgroundImageAlignment&quot;: &quot;topleft&quot;,  // 背景图片位置
      &quot;foreground&quot;: &quot;#FFFFFF&quot;,   // 前景颜色？
      &quot;tabTitle&quot;: &quot;power Shell&quot;,
      &quot;startingDirectory&quot;: &quot;./&quot;
    &#125;,</code></pre>
<p>分享我的界面<br> <img src="https://img2018.cnblogs.com/blog/1536549/202001/1536549-20200119103752068-1619596894.png" alt="img"></p>
<h3 id="配置主题颜色"><a href="#配置主题颜色" class="headerlink" title="配置主题颜色"></a>配置主题颜色</h3><ol>
<li><p>从<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21iYWRvbGF0by9pVGVybTItQ29sb3ItU2NoZW1lcw==">mbadolato  iTerm2-Color-Schemes<i class="fa fa-external-link-alt"></i></span>中选择自己喜欢的颜色主题</p>
</li>
<li><p>从 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21iYWRvbGF0by9pVGVybTItQ29sb3ItU2NoZW1lcy90cmVlL21hc3Rlci93aW5kb3dzdGVybWluYWw=">windowsterminal<i class="fa fa-external-link-alt"></i></span>文件夹中打开自己喜欢的主题的json文件</p>
</li>
<li><p>复制主题的json配置到<code>profiles.json</code>中的 <code>schemes</code> 配置项中</p>
<pre><code class="line-numbers language-json">&quot;schemes&quot;: [&#123;
  &quot;name&quot;: &quot;Day&quot;,
  &quot;black&quot;: &quot;#000000&quot;,
  &quot;red&quot;: &quot;#b87a7a&quot;,
  &quot;green&quot;: &quot;#7ab87a&quot;,
  &quot;yellow&quot;: &quot;#b8b87a&quot;,
  &quot;blue&quot;: &quot;#7a7ab8&quot;,
  &quot;purple&quot;: &quot;#b87ab8&quot;,
  &quot;cyan&quot;: &quot;#7ab8b8&quot;,
  &quot;white&quot;: &quot;#d9d9d9&quot;,
  &quot;brightBlack&quot;: &quot;#262626&quot;,
  &quot;brightRed&quot;: &quot;#dbbdbd&quot;,
  &quot;brightGreen&quot;: &quot;#bddbbd&quot;,
  &quot;brightYellow&quot;: &quot;#dbdbbd&quot;,
  &quot;brightBlue&quot;: &quot;#bdbddb&quot;,
  &quot;brightPurple&quot;: &quot;#dbbddb&quot;,
  &quot;brightCyan&quot;: &quot;#bddbdb&quot;,
  &quot;brightWhite&quot;: &quot;#ffffff&quot;
&#125;,&#123;
  &quot;name&quot;: &quot;Night&quot;,
  &quot;black&quot;: &quot;#000000&quot;,
  &quot;red&quot;: &quot;#ff7092&quot;,
  &quot;green&quot;: &quot;#00fbac&quot;,
  &quot;yellow&quot;: &quot;#fffa6a&quot;,
  &quot;blue&quot;: &quot;#00bfff&quot;,
  &quot;purple&quot;: &quot;#df95ff&quot;,
  &quot;cyan&quot;: &quot;#86cbfe&quot;,
  &quot;white&quot;: &quot;#ffffff&quot;,
  &quot;brightBlack&quot;: &quot;#000000&quot;,
  &quot;brightRed&quot;: &quot;#ff8aa4&quot;,
  &quot;brightGreen&quot;: &quot;#21f6bc&quot;,
  &quot;brightYellow&quot;: &quot;#fff787&quot;,
  &quot;brightBlue&quot;: &quot;#1bccfd&quot;,
  &quot;brightPurple&quot;: &quot;#e6aefe&quot;,
  &quot;brightCyan&quot;: &quot;#99d6fc&quot;,
  &quot;brightWhite&quot;: &quot;#ffffff&quot;
&#125;],</code></pre>
</li>
<li><p>将主题的名字配置到界面的配置中，比如 <code>powershell</code></p>
<pre><code class="line-numbers language-json">&quot;profiles&quot;: [&#123;
    // Make changes here to the powershell.exe profile
    &quot;guid&quot;: &quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;,
    &quot;name&quot;: &quot;power shell&quot;,
    &quot;commandline&quot;: &quot;powershell.exe&quot;,
    &quot;hidden&quot;: false,
    &quot;tabTitle&quot;: &quot;power Shell&quot;,
    &quot;startingDirectory&quot;: &quot;./&quot;,
    &quot;colorScheme&quot; : &quot;Night&quot;
&#125;]</code></pre>
</li>
</ol>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy框架笔记·shell交互式调试器</title>
    <url>/2020/%E7%88%AC%E8%99%AB/scrapy%20shell/</url>
    <content><![CDATA[<p>scrapy shell是一个基于命令行的交互式shell，我们可以使用它进行爬虫代码语句的测试，比如获取到了网页的response后可以使用css/xpath进行数据的提取测试。还可以将scrapy shell集成到spider中提供类似断点测试的功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200911195829.png"></p>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNjcmFweS5vcmcvZW4vbGF0ZXN0L3RvcGljcy9zaGVsbC5odG1s">scrapy document v2.1<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>

<h3 id="配置scrapy-shell"><a href="#配置scrapy-shell" class="headerlink" title="配置scrapy shell"></a>配置scrapy shell</h3><p>默认使用标准python shell，当安装ipython后会变更为ipython，可以提供更多智能完成和色彩提示</p>
<pre><code class="line-numbers language-bash">pip install ipython</code></pre>
<p>当然还可以通过环境变量<code>SCRAPY_PYTHON_SHELL</code>指定其他shell，如bpython，项目中单独配置方法为</p>
<pre><code class="line-numbers language-bash">vim scrpay.cfg</code></pre>
<pre><code>[settings]
shell = bpython</code></pre>
<h3 id="scrapy-shell的使用"><a href="#scrapy-shell的使用" class="headerlink" title="scrapy shell的使用"></a>scrapy shell的使用</h3><p>调试一个在线网页</p>
<pre><code class="line-numbers language-bash"># scrapy shell &lt;url&gt;
scrapy shell www.baidu.com</code></pre>
<p>当然还可以调试一个本地网页，注意使用当前文件夹的文件要指定为<code>./</code></p>
<pre><code class="line-numbers language-bash">scrapy shell /root/file.html
# 或者
scrapy shell file:///absolute/path/to/file.html</code></pre>
<h4 id="shell启动的可选参数"><a href="#shell启动的可选参数" class="headerlink" title="shell启动的可选参数"></a>shell启动的可选参数</h4><pre><code class="line-numbers language-bash"># 不显示日志
scrapy shell www.baidu.com --nolog</code></pre>
<pre><code class="line-numbers language-bash"># 指定headers UA
scrapy shell -s USER_AGENT=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0&quot; https://www.zhihu.com/question/285908404</code></pre>
<h4 id="shell中的可用方法"><a href="#shell中的可用方法" class="headerlink" title="shell中的可用方法"></a>shell中的可用方法</h4><pre><code class="line-numbers language-shell"># 重新调试一个新的URL，并相应地更新所有相关对象
fetch(&#39;www.baidu.com&#39;)
fetch(&#39;www.baidu.com&#39;, redirect=True)</code></pre>
<pre><code class="line-numbers language-shell"># 刷新请求
fetch(request)</code></pre>
<pre><code class="line-numbers language-shell"># 浏览器查看响应
view(response)</code></pre>
<h4 id="shell中的可用对象"><a href="#shell中的可用对象" class="headerlink" title="shell中的可用对象"></a>shell中的可用对象</h4><p>crawler - 当前爬虫对象<br>spider - 可处理当前URL的spider，或者一个新的spider对象<br>request - URL的请求对象，使用<a href="https://docs.scrapy.org/en/latest/topics/request-response.html#scrapy.http.Request.replace"><code>replace()</code></a>变更<br>response - 当前URL的响应对象<br>settings - 当前scrapy setting对象</p>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>启动</p>
<pre><code class="line-numbers language-bash">scrapy shell &quot;https://scrapy.org&quot; --nolog</code></pre>
<p>获取文本</p>
<pre><code class="line-numbers language-bash">&gt;&gt;&gt; response.xpath(&#39;//title/text()&#39;).get()
&#39;Scrapy | A Fast and Powerful Scraping and Web Crawling Framework&#39;</code></pre>
<p>请求一个新的URL</p>
<pre><code class="line-numbers language-bash">&gt;&gt;&gt; fetch(&quot;https://old.reddit.com/&quot;)</code></pre>
<p>变更请求对象</p>
<pre><code class="line-numbers language-bash">&gt;&gt;&gt; request = request.replace(method=&quot;POST&quot;)</code></pre>
<p>查看请求头</p>
<pre><code class="line-numbers language-bash">from pprint import pprint
pprint(request.headers)</code></pre>
<pre><code>&#123;b&#39;Accept&#39;: [b&#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=&#39;
             b&#39;0.8&#39;],
 b&#39;Accept-Encoding&#39;: [b&#39;gzip, deflate&#39;],
 b&#39;Accept-Language&#39;: [b&#39;en&#39;],
 b&#39;User-Agent&#39;: [b&#39;Scrapy/2.3.0 (+https://scrapy.org)&#39;]&#125;</code></pre>
<h3 id="spider中的使用"><a href="#spider中的使用" class="headerlink" title="spider中的使用"></a>spider中的使用</h3><p>在spider的编写中集成shell可以调试某个点的response，调用的方法为</p>
<pre><code class="line-numbers language-python">from scrapy.shell import inspect_response
inspect_response(response, self)</code></pre>
<p>案例</p>
<pre><code class="line-numbers language-python">import scrapy

class MySpider(scrapy.Spider):
    name = &quot;myspider&quot;
    start_urls = [
        &quot;http://example.com&quot;,
        &quot;http://example.org&quot;,
        &quot;http://example.net&quot;,
    ]

    def parse(self, response):
        # We want to inspect one specific response.
        if &quot;.org&quot; in response.url:
            from scrapy.shell import inspect_response
            inspect_response(response, self)</code></pre>
<p>代码运行到if语句会进入到scrapyshell中，使用ctrl-d（Linux）或ctrl-z（Windows）退出</p>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy框架笔记·spider基类与Spider模板类</title>
    <url>/2020/%E7%88%AC%E8%99%AB/scrapy%20spider/</url>
    <content><![CDATA[<p>我们在进行spider类的编写时，需要继承 <code>scrapy.Spider</code>类并对其中的方法进行重写，Spider类定义了对目标（URLorURLS）的处理逻辑，流程为：</p>
<ul>
<li><p>首先，生成最初爬取请求，有两种设定方法</p>
<ul>
<li><code>start_urls</code>类属性：这是一个url的列表，scrapy会根据调度器的指定循环生成URL的请求，默认回调 <code>parse</code>方法解析response</li>
<li><code>start_requsts</code>方法：源码中这个方法用于处理start_urls，可以重写这个方法改写请求的内容（更改headers、添加clouflare cookies等）</li>
</ul>
</li>
<li><p>然后，使用解析函数对response进行处理，</p>
<ul>
<li>获取爬取目标：横向的 <code>下一页</code>或者纵向的 <code>详情页</code></li>
<li>有效数据提取：存入<code>item</code>或交给<code>Request.meta</code></li>
</ul>
</li>
<li><p>最后，使用<code>yield item</code>将数据交给pipeline组件或者Feed进行导出</p>
</li>
</ul>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNjcmFweS5vcmcvZW4vbGF0ZXN0L3RvcGljcy9jb21tYW5kcy5odG1s">scrapy document v2.1<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>

<h2 id="scrapy-Spider类分析"><a href="#scrapy-Spider类分析" class="headerlink" title="scrapy.Spider类分析"></a>scrapy.Spider类分析</h2><p>我们编写的spider都继承于scrapy.Spider类</p>
<pre><code class="line-numbers language-python">import scrapy
from filespider.items import FileSpiderItem


class MySpider(scrapy.Spider):
    name = &#39;&#39;
    allow_domains = []
    start_urls = []
    custom_settings = &#123;&#125;

    def start_requests(self):
        # do something
        yield scrapy.Request(url=&#39;&#39;, callback=self.parse)

    def parse(self, response, **kwargs):
        item = FileSpiderItem()
        yield item</code></pre>
<h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>spider标识，一个项目中每个spider的name属性必须是唯一的</p>
<pre><code class="line-numbers language-bash">scrapy list        # 获取项目中的spider列表
scrapy crawl &lt;name&gt;        # 运行name名称的spider</code></pre>
<h4 id="allowed-domains"><a href="#allowed-domains" class="headerlink" title="allowed_domains"></a>allowed_domains</h4><p>允许爬行域，如果配置为<code>allowed_domains=[&#39;movie.douban.com&#39;]</code>，那么：</p>
<ul>
<li>对<code>https://movie.douban.com/xxx</code>的请求会执行</li>
<li>对<code>https://music.douban.com/xxx</code>的请求会被抛弃</li>
</ul>
<h4 id="start-urls"><a href="#start-urls" class="headerlink" title="start_urls"></a>start_urls</h4><p>爬取的起点URL列表</p>
<h4 id="custom-settings"><a href="#custom-settings" class="headerlink" title="custom_settings"></a>custom_settings</h4><p>爬取配置，优先级高于settings.py，会在实例化前更新配置</p>
<h4 id="crawler"><a href="#crawler" class="headerlink" title="crawler"></a>crawler</h4><h4 id="settings-配置实例"><a href="#settings-配置实例" class="headerlink" title="settings    配置实例"></a>settings    配置实例</h4><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><h4 id="from-crawler-crawler-args-kwargs"><a href="#from-crawler-crawler-args-kwargs" class="headerlink" title="from_crawler(crawler, args*, *kwargs*)"></a><code>from_crawler</code>(<em>crawler</em>, <strong>args*, *</strong>kwargs*)</h4><p>相当于spider类的<code>__init__</code>方法，一般不需要重写</p>
<h4 id="start-requests"><a href="#start-requests" class="headerlink" title="start_requests()"></a><code>start_requests</code>()</h4><p>这是一个生成器方法，最后必须返回iterable对象（<code>yield xxx</code>）</p>
<p>默认实现中对start_urls列表中的每个URL生成 <code>Request(url, dont_filter=True)</code> </p>
<p><strong>重写实例：</strong>POST登陆</p>
<pre><code class="line-numbers language-python">class MySpider(scrapy.Spider):
    name = &#39;myspider&#39;

    def start_requests(self):
        return [scrapy.FormRequest(&quot;http://www.example.com/login&quot;,
                                   formdata=&#123;&#39;user&#39;: &#39;john&#39;, &#39;pass&#39;: &#39;secret&#39;&#125;,
                                   callback=self.logged_in)]

    def logged_in(self, response):
        # here you would extract links to follow and return Requests for
        # each of them, with another callback
        pass</code></pre>
<h4 id="parse-response"><a href="#parse-response" class="headerlink" title="parse(response)"></a><code>parse</code>(<em>response</em>)</h4><p>负责处理回调该函数的函数生成的请求的响应（···，其实就是使用callback的对象的响应）</p>
<p>重写后主要用于数据解析和URL获取</p>
<pre><code class="line-numbers language-python">def parse(self, response):
    for h3 in response.xpath(&#39;//h3&#39;).getall():
        yield &#123;&quot;title&quot;: h3&#125;
    for href in response.xpath(&#39;//a/@href&#39;).getall():
        yield scrapy.Request(response.urljoin(href), self.parse)</code></pre>
<p>必须返回如下三者之一：</p>
<ul>
<li><code>scrapy.Request</code>对象</li>
<li>dict字典对象</li>
<li>Item实例</li>
</ul>
<h4 id="log-message-level-component"><a href="#log-message-level-component" class="headerlink" title="log(message[, level, component])"></a><code>log</code>(<em>message</em>[, <em>level</em>, <em>component</em>])</h4><p>spider的logger，保持向后兼容性</p>
<pre><code class="line-numbers language-python">def parse_item(self, response):
        self.logger.info(&#39;Hi, this is an item page! %s&#39;, response.url)</code></pre>
<h4 id="closed-reason"><a href="#closed-reason" class="headerlink" title="closed(reason)"></a><code>closed</code>(<em>reason</em>)</h4><p>spider关闭时调用。此方法为 <code>spider_closed</code>信号。</p>
<h2 id="Spider类对crawl命令参数（-a）的解析"><a href="#Spider类对crawl命令参数（-a）的解析" class="headerlink" title="Spider类对crawl命令参数（-a）的解析"></a>Spider类对crawl命令参数（-a）的解析</h2><p>在<code>scrapy crawl</code>时可以使用<code>-a xxx=xxx</code>指定参数，以动态改变spider功能</p>
<h3 id="原理与注意"><a href="#原理与注意" class="headerlink" title="原理与注意"></a>原理与注意</h3><p>手册中对该功能的举例，可以看到这个例子巧妙的在spider的启动阶段改变了源URL列表</p>
<pre><code class="line-numbers language-bash">scrapy crawl myspider -a category=electronics</code></pre>
<pre><code class="line-numbers language-python">import scrapy

class MySpider(scrapy.Spider):
    name = &#39;myspider&#39;

    def __init__(self, category=None, *args, **kwargs):
        super(MySpider, self).__init__(*args, **kwargs)
        self.start_urls = [&#39;http://www.example.com/categories/%s&#39; % category]</code></pre>
<p>注意参数传入的只是<strong>字符串</strong>，要设置为属性必须使用<code>ast.literal_eval</code> 或 <code>json.loads</code>进行转换</p>
<h3 id="可直接使用接口"><a href="#可直接使用接口" class="headerlink" title="可直接使用接口"></a>可直接使用接口</h3><pre><code class="line-numbers language-bash">scrapy crawl myspider -a user_agent=mybot        # UserAgentMiddleware
scrapy crawl myspider -a http_user=myuser -a http_pass=mypassword        # HttpAuthMiddleware</code></pre>
<h2 id="scrapy预设Spider子类"><a href="#scrapy预设Spider子类" class="headerlink" title="scrapy预设Spider子类"></a>scrapy预设Spider子类</h2><p>scrapy根据爬取过程中经常用到的功能预设了一些Spider类的子类，可用template：</p>
<ul>
<li>默认：<code>scrapy.Spider</code></li>
<li>CrawlSpider：class  <code>scrapy.spiders.CrawlSpider</code></li>
<li>XMLFeedSpider：class  <code>scrapy.spiders.XMLFeedSpider</code></li>
<li>CSVFeedSpider：class  <code>scrapy.spiders.CSVFeedSpider</code></li>
<li>SitemapSpider：class  <code>scrapy.spiders.SitemapSpider</code></li>
</ul>
<pre><code class="line-numbers language-bash">scrapy genspider [-t template] &lt;name&gt; &lt;domain&gt;
scrapy genspider [--template=template] &lt;name&gt; &lt;domain&gt;</code></pre>
<h3 id="class-scrapy-spiders-CrawlSpider"><a href="#class-scrapy-spiders-CrawlSpider" class="headerlink" title="class scrapy.spiders.CrawlSpider"></a><em>class</em> <code>scrapy.spiders.CrawlSpider</code></h3><p>主要使用LinkExtractor方法模板化匹配并提取网页上的链接并生成请求，比如说爬取<strong>起点小说网</strong>，相对于父类，增加了：</p>
<ul>
<li>rules属性：爬取规则实例列表，这些实例由 <code>scrapy.spiders.Rule</code>爬行规则类生成</li>
<li>parse_start_url(response)方法：用于解析初始响应，返回值类似parse函数</li>
</ul>
<h4 id="scrapy-spiders-Rule-爬行规则类"><a href="#scrapy-spiders-Rule-爬行规则类" class="headerlink" title="scrapy.spiders.Rule 爬行规则类"></a>scrapy.spiders.Rule 爬行规则类</h4><pre><code class="line-numbers language-python">class scrapy.spiders.Rule(
    link_extractor, 
    callback=None, 
    cb_kwargs=None, 
    follow=None, 
    process_links=None, 
    process_request=None
)</code></pre>
<ul>
<li><p>link_extractor</p>
<p>是一个 <code>LinkExtractor</code> 对象，定义如何从每个已爬网页提取链接，每个生成的链接将用于生成 <code>Request</code> 对象，链接的文本保存在 <code>response.meta[&#39;link_text&#39;]</code></p>
</li>
<li><p>callback：指定该条匹配实例的解析函数</p>
</li>
</ul>
<h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><p>手册栗子很形象</p>
<pre><code class="line-numbers language-python">import scrapy
from scrapy.spiders import CrawlSpider, Rule
from scrapy.linkextractors import LinkExtractor

class MySpider(CrawlSpider):
    name = &#39;example.com&#39;
    allowed_domains = [&#39;example.com&#39;]
    start_urls = [&#39;http://www.example.com&#39;]

    rules = (
        # Extract links matching &#39;category.php&#39; (but not matching &#39;subsection.php&#39;)
        # and follow links from them (since no callback means follow=True by default).
        Rule(LinkExtractor(allow=(&#39;category\.php&#39;, ), deny=(&#39;subsection\.php&#39;, ))),

        # Extract links matching &#39;item.php&#39; and parse them with the spider&#39;s method parse_item
        Rule(LinkExtractor(allow=(&#39;item\.php&#39;, )), callback=&#39;parse_item&#39;),
    )

    def parse_item(self, response):
        self.logger.info(&#39;Hi, this is an item page! %s&#39;, response.url)
        item = scrapy.Item()
        item[&#39;id&#39;] = response.xpath(&#39;//td[@id=&quot;item_id&quot;]/text()&#39;).re(r&#39;ID: (\d+)&#39;)
        item[&#39;name&#39;] = response.xpath(&#39;//td[@id=&quot;item_name&quot;]/text()&#39;).get()
        item[&#39;description&#39;] = response.xpath(&#39;//td[@id=&quot;item_description&quot;]/text()&#39;).get()
        item[&#39;link_text&#39;] = response.meta[&#39;link_text&#39;]
        return item</code></pre>
<h3 id="class-scrapy-spiders-XMLFeedSpider"><a href="#class-scrapy-spiders-XMLFeedSpider" class="headerlink" title="class  scrapy.spiders.XMLFeedSpider"></a>class  <code>scrapy.spiders.XMLFeedSpider</code></h3><p>为解析XML而设计，没使用过···，看栗子</p>
<h4 id="栗子-1"><a href="#栗子-1" class="headerlink" title="栗子"></a>栗子</h4><pre><code class="line-numbers language-python">from scrapy.spiders import XMLFeedSpider
from myproject.items import TestItem

class MySpider(XMLFeedSpider):
    name = &#39;example.com&#39;
    allowed_domains = [&#39;example.com&#39;]
    start_urls = [&#39;http://www.example.com/feed.xml&#39;]
    iterator = &#39;iternodes&#39;  # This is actually unnecessary, since it&#39;s the default value
    itertag = &#39;item&#39;

    def parse_node(self, response, node):
        self.logger.info(&#39;Hi, this is a &lt;%s&gt; node!: %s&#39;, self.itertag, &#39;&#39;.join(node.getall()))

        item = TestItem()
        item[&#39;id&#39;] = node.xpath(&#39;@id&#39;).get()
        item[&#39;name&#39;] = node.xpath(&#39;name&#39;).get()
        item[&#39;description&#39;] = node.xpath(&#39;description&#39;).get()
        return item</code></pre>
<h3 id="class-scrapy-spiders-CSVFeedSpider"><a href="#class-scrapy-spiders-CSVFeedSpider" class="headerlink" title="class  scrapy.spiders.CSVFeedSpider"></a>class  <code>scrapy.spiders.CSVFeedSpider</code></h3><p>处理CSV文件，与XMLFeedSpider相比该类用于行处理，每次迭代中调用<code>parse_row()</code>方法</p>
<h4 id="新增属性与方法"><a href="#新增属性与方法" class="headerlink" title="新增属性与方法"></a>新增属性与方法</h4><ul>
<li>delimiter：csv文件中每个字段<strong>分隔符</strong>字符串，默认为逗号 <code>&#39;,&#39;</code></li>
<li>quotechar：csv文件中每个字段包裹字符串，默认为双引号<code>&#39;&quot;&#39;</code></li>
<li>headers：字段列名</li>
<li>parse_row(response, row)：</li>
</ul>
<h4 id="栗子-2"><a href="#栗子-2" class="headerlink" title="栗子"></a>栗子</h4><pre><code class="line-numbers language-python">from scrapy.spiders import CSVFeedSpider
from myproject.items import TestItem

class MySpider(CSVFeedSpider):
    name = &#39;example.com&#39;
    allowed_domains = [&#39;example.com&#39;]
    start_urls = [&#39;http://www.example.com/feed.csv&#39;]
    delimiter = &#39;;&#39;
    quotechar = &quot;&#39;&quot;
    headers = [&#39;id&#39;, &#39;name&#39;, &#39;description&#39;]

    def parse_row(self, response, row):
        self.logger.info(&#39;Hi, this is a row!: %r&#39;, row)

        item = TestItem()
        item[&#39;id&#39;] = row[&#39;id&#39;]
        item[&#39;name&#39;] = row[&#39;name&#39;]
        item[&#39;description&#39;] = row[&#39;description&#39;]
        return item</code></pre>
<h3 id="class-scrapy-spiders-SitemapSpider"><a href="#class-scrapy-spiders-SitemapSpider" class="headerlink" title="class  scrapy.spiders.SitemapSpider"></a>class  <code>scrapy.spiders.SitemapSpider</code></h3>]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2020/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Linxu常用命令及命令参数笔记</p>
<ul>
<li>目录与文件</li>
<li>进程</li>
<li>账户与权限</li>
<li>文本操作</li>
<li>网络</li>
<li>查找</li>
<li>其他</li>
</ul>
<a id="more"></a>

<hr>
<h3 id="目录与文件"><a href="#目录与文件" class="headerlink" title="目录与文件"></a>目录与文件</h3><h4 id="find-查找文件"><a href="#find-查找文件" class="headerlink" title="find    查找文件"></a>find    查找文件</h4><p>使用方法</p>
<pre><code class="line-numbers language-bash">find [PATH] [option] [action]</code></pre>
<pre><code class="line-numbers language-bash"># 名称与类型
-name filename ：找出文件名为filename的文件
-size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件
-tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、
             目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）
# 时间
-mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；
-mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；
-mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；
-newer file : 列出比file还要新的文件名
# 权限
-user name : 列出文件所有者为name的文件
-group name : 列出文件所属用户组为name的文件
-uid n : 列出文件所有者为用户ID为n的文件
-gid n : 列出文件所属用户组为用户组ID为n的文件</code></pre>
<pre><code class="line-numbers language-bash">find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件

find /home/hadoop -user hadoop # 在目录/home/hadoop中找出所有者为hadoop的文件

find / -name passwd     # 查找文件名为passwd的文件
find . -perm 0755         # 查找当前目录中文件权限的0755的文件
find . -size +12k         # 查找当前目录中大于12KB的文件，注意c表示byte</code></pre>
<h4 id="ls-显示目录内容"><a href="#ls-显示目录内容" class="headerlink" title="ls    显示目录内容"></a>ls    显示目录内容</h4><pre><code class="line-numbers language-bash">-a ：全部的档案，连同隐藏档( 开头为 . 的档案) 一起列出来～ 
-A ：全部的档案，连同隐藏档，但不包括 . 与 .. 这两个目录，一起列出来～ 
-d ：仅列出目录本身，而不是列出目录内的档案数据 
-f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！) 
-F ：根据档案、目录等信息，给予附加数据结构，例如： 
*：代表可执行档； /：代表目录； =：代表 socket 档案； |：代表 FIFO 档案； 
-h ：将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来； 
-i ：列出 inode 位置，而非列出档案属性； 
-l ：长数据串行出，包含档案的属性等等数据； 
-n ：列出 UID 与 GID 而非使用者与群组的名称 (UID与GID会在账号管理提到！) 
-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小； 
-R ：连同子目录内容一起列出来； 
-S ：以档案容量大小排序！ 
-t ：依时间排序 
--color=never ：不要依据档案特性给予颜色显示； 
--color=always ：显示颜色 
--color=auto ：让系统自行依据设定来判断是否给予颜色 
--full-time ：以完整时间模式 (包含年、月、日、时、分) 输出 
--time=&#123;atime,ctime&#125; ：输出 access 时间或 改变权限属性时间 (ctime) 
而非内容变更时间 (modification time)  </code></pre>
<h4 id="cd-目录切换"><a href="#cd-目录切换" class="headerlink" title="cd    目录切换"></a>cd    目录切换</h4><pre><code class="line-numbers language-bash">cd /home/yuan        # 切换至绝对路径
cd ..                # 切换至上级目录
cd ./path            # 切换至相对路径</code></pre>
<h4 id="tree-树状图列出目录的内容"><a href="#tree-树状图列出目录的内容" class="headerlink" title="tree    树状图列出目录的内容"></a>tree    树状图列出目录的内容</h4><p>需要安装，<code>apt install tree</code></p>
<pre><code class="line-numbers language-bash">-d        # 仅显示目录
-f        # 显示完整路径
-L         # level 限制目录显示层级
-l         # 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</code></pre>
<h4 id="cp-复制"><a href="#cp-复制" class="headerlink" title="cp    复制"></a>cp    复制</h4><pre><code class="line-numbers language-bash">cp [options] &lt;原始&gt; &lt;目的&gt;</code></pre>
<pre><code class="line-numbers language-bash">-a         # 将文件的特性一起复制
-p         # 连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份
-i         # 若目标文件已经存在时，在覆盖时会先询问操作的进行
-r         # 递归持续复制，用于目录的复制行为
-u         # 目标文件与源文件有差异时才会复制</code></pre>
<h4 id="rm-删除"><a href="#rm-删除" class="headerlink" title="rm    删除"></a>rm    删除</h4><pre><code class="line-numbers language-bash">-r    # 递归删除，用于删除目录
-f    # 无需确认</code></pre>
<h4 id="rmdir-删除空目录"><a href="#rmdir-删除空目录" class="headerlink" title="rmdir    删除空目录"></a>rmdir    删除空目录</h4><h4 id="mv-移动"><a href="#mv-移动" class="headerlink" title="mv    移动"></a>mv    移动</h4><pre><code class="line-numbers language-bash">-f     # force强制的意思，如果目标文件已经存在，不会询问而直接覆盖</code></pre>
<h4 id="pwd-显示当前目录"><a href="#pwd-显示当前目录" class="headerlink" title="pwd    显示当前目录"></a>pwd    显示当前目录</h4><h4 id="tar-解压缩"><a href="#tar-解压缩" class="headerlink" title="tar    解压缩"></a>tar    解压缩</h4><ul>
<li>预览包 - <code>tar jtv &lt;filename&gt;</code></li>
<li>自动适应模式解压 - <code>tar xvf &lt;filename&gt;</code></li>
<li>指定目的目录 - <code>tar xvf &lt;filename&gt; -C &lt;path&gt;</code></li>
</ul>
<pre><code class="line-numbers language-bash">-x    # 解包或解压缩功能
-v    # 显示解包过程
-f    # 其后指定要处理的文件
-t    # 预览包
-C    # 其后指定目的目录</code></pre>
<h4 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir    创建目录"></a>mkdir    创建目录</h4><pre><code class="line-numbers language-bash">sudo mkdir -m 700 -p /opt/env/node</code></pre>
<pre><code class="line-numbers language-bash">-m, --mode=600        # 设定权限，如600
-p, --parents        # 递归创建
-v, --verbose        # 输出信息</code></pre>
<h3 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h3><h4 id="ps-进程信息"><a href="#ps-进程信息" class="headerlink" title="ps    进程信息"></a>ps    进程信息</h4><pre><code class="line-numbers language-bash">-A ：所有的进程均显示出来
-a ：不与terminal有关的所有进程
-u ：有效用户的相关进程
-x ：一般与a参数一起使用，可列出较完整的信息
-l ：较长，较详细地将PID的信息列出</code></pre>
<pre><code class="line-numbers language-bash"># 进程状态
USER: 行程拥有者
PID: pid
%CPU: 占用的 CPU 使用率
%MEM: 占用的记忆体使用率
VSZ: 占用的虚拟记忆体大小
RSS: 占用的记忆体大小
TTY: 终端的次要装置号码 (minor device number of tty)
STAT: 该行程的状态:
D: 无法中断的休眠状态 (通常 IO 的进程)
R: 正在执行中
S: 静止状态
T: 暂停执行
Z: 不存在但暂时无法消除
W: 没有足够的记忆体分页可分配
&lt;: 高优先序的行程
N: 低优先序的行程
L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)
START: 行程开始时间
TIME: 执行的时间
COMMAND:所执行的指令</code></pre>
<h4 id="kill-进程控制（pid）"><a href="#kill-进程控制（pid）" class="headerlink" title="kill    进程控制（pid）"></a>kill    进程控制（pid）</h4><pre><code class="line-numbers language-bash">kill -[signal] PID
kill -9 1234</code></pre>
<table>
<thead>
<tr>
<th>信号</th>
<th>信号值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIGHUP</td>
<td>1</td>
<td>启动被终止的进程</td>
</tr>
<tr>
<td>SIGINT</td>
<td>2</td>
<td>ctrl+c，中断一个程序的进行</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>强制中断一个进程的进行</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>以正常的结束进程方式来终止进程</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>19</td>
<td>ctrl+z，暂停一个进程的进行</td>
</tr>
</tbody></table>
<h4 id="killall-进程控制（name）"><a href="#killall-进程控制（name）" class="headerlink" title="killall    进程控制（name）"></a>killall    进程控制（name）</h4><pre><code class="line-numbers language-bash">-i 交互模式，杀死进程前先询问用户
-g 杀死进程组而不是进程
-l 列出所有的已知信号名称</code></pre>
<h4 id="pkill"><a href="#pkill" class="headerlink" title="pkill"></a>pkill</h4><h4 id="contrab-定时任务（min级）"><a href="#contrab-定时任务（min级）" class="headerlink" title="contrab    定时任务（min级）"></a>contrab    定时任务（min级）</h4><pre><code class="line-numbers language-bash">usage:  crontab [-u user] file
        crontab [-u user] [ -e | -l | -r ]
                (default operation is replace, per 1003.2)
        -e      (edit user&#39;s crontab)
        -l      (list user&#39;s crontab)
        -r      (delete user&#39;s crontab)
        -i      (prompt before deleting user&#39;s crontab)
        -s      (selinux context)</code></pre>
<ul>
<li>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。 <pre><code>在/etc/crontab文件，这个就是系统任务调度的配置文件。</code></pre>
</li>
<li>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。<pre><code>用户可以使用 crontab 工具来定制自己的计划任务。
在crontab 文件都被保存在/var/spool/cron目录中。其文件名与用户名一致</code></pre>
</li>
</ul>
<pre><code class="line-numbers language-bash">1.系统定时任务：例如清理系统日志，清理系统缓存   --&gt;不过多的关注
    查询系统定时处理任务的路径：
        路径1：
            cd /etc/logrotate.d/        --&gt;可以写定时任务
            less syslog 
        路径2：
            cat /etc/crontab   --&gt;不推荐使用，但是可以看格式
        路径3：
             ls /etc/ | grep cron*
                 anacrontab
                 cron.d                 --&gt;同路径2 ，可以写定时任务  
                 cron.daily
                 cron.deny              --&gt;控制普通用户使用定时任务crontab
                 cron.hourly
                 cron.monthly
                 crontab
                 cron.weekly
2.用户的定时任务      --&gt;关注重点</code></pre>
<pre><code class="line-numbers language-shell"># /etc/crontab: system-wide crontab
# Unlike any other crontab you don&#39;t have to run the `crontab&#39;
# command to install the new version when you edit this file
# and files in /etc/cron.d. These files also have username fields,
# that none of the other crontabs do.

SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=
HOME=
# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name command to be executed
17 *    * * *   root    cd / &amp;&amp; run-parts --report /etc/cron.hourly
25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )
47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )
52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )</code></pre>
<pre><code class="line-numbers language-bash">前四行是用来配置crond任务运行的环境变量
第一行SHELL变量指定了系统要使用哪个shell，这里是bash
第二行PATH变量指定了系统执行命令的路径
第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户
第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。

星号（*）：代表所有可能的值，如month字段为星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。
逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”
中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”
正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。

数字的表示最好用2为阿拉伯数字显示
周和日最好不要同时用
定时任务要加注解
可以定向到日志文件或者空文件
定时任务一定是绝对路径，且目录必须存在才能出结果
crontab 服务一定要开启运行</code></pre>
<pre><code>0 * * * * root run-parts /etc/cron.hourly        # 每小时执行/etc/cron.hourly目录内的脚本
echo &quot;*/2 * * * * /usr/bin/ntpstat time.windows.com &gt;/dev/null 2&gt;&amp;1&quot; &gt;&gt; /var/spool/cron/root        # 每隔2分钟同步一次互联网时间
echo &quot;*/30 [3-5],[17-20] * * * /bin/sh /home/omc/h.sh &gt;/dev/null 2&gt;&amp;1&quot; &gt;&gt; /var/spool/cron/root        # 每天3-5,17-20每隔30分钟执行一次脚本</code></pre>
<pre><code class="line-numbers language-bash"># 注意事项
1.环境变量问题，例如crontab不能识别Java的环境变量
    crontab执行shell时，只能识别为数不多的环境变量，普通的环境变量是无法识别的，所以在编写shell时，最好使用export重新声明变量，确保脚本执行。 
2.命令的执行最好用脚本
3.脚本权限加/bin/sh，规范路径/server/scripts
4.时间变量用反斜线转义，最好用脚本
5.定时任务添加注释
6.&gt;/dev/null 2&gt;&amp;1   ==&gt;&amp;&gt;/dev/null,别随意打印日志文件
7.定时任务里面的程序脚本尽量用全路径
8.避免不必要的程序以及命令输出
9.定时任务之前添加注释
10.打包到文件目录的上一级</code></pre>
<h4 id="free-内存信息"><a href="#free-内存信息" class="headerlink" title="free    内存信息"></a>free    内存信息</h4><pre><code class="line-numbers language-bash">free [参数]
-b 　以Byte为单位显示内存使用情况。 
-k 　以KB为单位显示内存使用情况。 
-m 　以MB为单位显示内存使用情况。
-g   以GB为单位显示内存使用情况。 
-o 　不显示缓冲区调节列。 
-s&lt;间隔秒数&gt; 　持续观察内存使用状况。 
-t 　显示内存总和列。 
-V 　显示版本信息。</code></pre>
<pre><code class="line-numbers language-bash"></code></pre>
<p>top    系统性能分析</p>
<pre><code class="line-numbers language-bash">top [参数]
-b 批处理
-c 显示完整的治命令
-I 忽略失效过程
-s 保密模式
-S 累积模式
-i&lt;时间&gt; 设置间隔时间
-u&lt;用户名&gt; 指定用户名
-p&lt;进程号&gt; 指定进程
-n&lt;次数&gt; 循环显示的次数</code></pre>
<h3 id="账户与权限"><a href="#账户与权限" class="headerlink" title="账户与权限"></a>账户与权限</h3><h4 id="sudo-以其他用户身份执行命令"><a href="#sudo-以其他用户身份执行命令" class="headerlink" title="sudo    以其他用户身份执行命令"></a>sudo    以其他用户身份执行命令</h4><pre><code class="line-numbers language-bash"># 默认root
-b：在后台执行指令；
-h：显示帮助；
-H：将HOME环境变量设为新身份的HOME环境变量；
-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。
-l：列出目前用户可执行与无法执行的指令；
-p：改变询问密码的提示符号；
-s：执行指定的shell；
-u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；
-v：延长密码有效期限5分钟；
-V ：显示版本信息。</code></pre>
<h4 id="passwd-设置用户密码"><a href="#passwd-设置用户密码" class="headerlink" title="passwd    设置用户密码"></a>passwd    设置用户密码</h4><pre><code class="line-numbers language-bash"># passwd [options] &lt;UserName&gt;
-S    # 账户状态</code></pre>
<h4 id="groups-显示用户组"><a href="#groups-显示用户组" class="headerlink" title="groups    显示用户组"></a>groups    显示用户组</h4><pre><code class="line-numbers language-bash">groups &lt;UserName&gt;</code></pre>
<h4 id="useradd-添加用户"><a href="#useradd-添加用户" class="headerlink" title="useradd    添加用户"></a>useradd    添加用户</h4><pre><code class="line-numbers language-bash">useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ][-u ][用户帐号] </code></pre>
<pre><code class="line-numbers language-bash">-c #&lt;备注&gt; 　加上备注文字。备注文字会保存在passwd的备注栏位中。　
-d #&lt;登入目录&gt; 　指定用户登入时的启始目录。
-D #　变更预设值．
-e # &lt;有效期限&gt; 　指定帐号的有效期限。
-f # &lt;缓冲天数&gt; 　指定在密码过期后多少天即关闭该帐号。
-g # &lt;群组&gt; 　指定用户所属的群组。
-G # &lt;群组&gt; 　指定用户所属的附加群组。
-m # 自动建立用户的登入目录。
-M # 不要自动建立用户的登入目录。
-n # 取消建立以用户名称为名的群组．
-r # 建立系统帐号。
-s # 指定用户登入后所使用的shell。
-u # 指定用户ID。</code></pre>
<h4 id="usermod-修改用户信息"><a href="#usermod-修改用户信息" class="headerlink" title="usermod    修改用户信息"></a>usermod    修改用户信息</h4><pre><code># 同useradd</code></pre>
<h4 id="userdel-删除用户"><a href="#userdel-删除用户" class="headerlink" title="userdel    删除用户"></a>userdel    删除用户</h4><pre><code class="line-numbers language-bash">-r    # 删除家目录和用户邮件池
-f    # 强制删除，包括用户的一切相关内容，这个参数是危险的参数，不建议大家使用。详细说明看MAN</code></pre>
<h4 id="groupadd-生成新用户组"><a href="#groupadd-生成新用户组" class="headerlink" title="groupadd    生成新用户组"></a>groupadd    生成新用户组</h4><pre><code class="line-numbers language-bash">－g gid：指定组ID号。
－o：允许组ID号，不必惟一。
－r：加入组ID号，低于499系统账号。
－f：加入已经有的组时，发展程序退出。</code></pre>
<h4 id="groupdel-删除用户组"><a href="#groupdel-删除用户组" class="headerlink" title="groupdel    删除用户组"></a>groupdel    删除用户组</h4><h4 id="chmod-权限更改"><a href="#chmod-权限更改" class="headerlink" title="chmod    权限更改"></a>chmod    权限更改</h4><pre><code class="line-numbers language-bash">-R：进行递归的持续更改，即连同子目录下的所有文件都会更改</code></pre>
<pre><code class="line-numbers language-bash">chmod 0755 file # 把file的文件权限改变为-rxwr-xr-x
chmod g+w file # 向file的文件权限中加入用户组可写权限</code></pre>
<h4 id="chown-拥有者更改"><a href="#chown-拥有者更改" class="headerlink" title="chown    拥有者更改"></a>chown    拥有者更改</h4><pre><code class="line-numbers language-bash">chown &lt;username&gt; &lt;file_or_path&gt;</code></pre>
<h4 id="chgrp-所属组更改"><a href="#chgrp-所属组更改" class="headerlink" title="chgrp    所属组更改"></a>chgrp    所属组更改</h4><pre><code class="line-numbers language-bash"># usermod [options] LOGIN
usermod -h
 -c #后面接账号的说明，即/etc/passwd第五栏的说明栏，可以加入一些账号的说明
 -d #后面接账号的家目录，即修改/etc/passwd的第六栏
 -e #后面接日期，格式是YYYY-MM-DD也就是在/etc/shadow内的第八栏
 -f #后面接天数，修改shadow的第七栏
 -g #后面接主群组，修改/etc/passwd的第四个字段，即是GID的字段
 -G #后面接附加群组，修改这个使用者能够支持的群组，修改的是/etc/group
 -a #与 -G 合用，可增加附加群组的支持而非设定
 -l #后面接账号名称。修改账号名称，/etc/passwd的第一栏
 -s #后面接Shell的文件，例如/bin/bash或/bin/csh等等
 -u #后面接 UID 数字，修改用户的UID /etc/passwd第三栏
 -L #暂时将用户的密码冻结，让他无法登入。其实就是在/etc/shadow的密码栏前面加上了“!”
 -U #将/etc/shadow 密码栏的“!”去掉</code></pre>
<h3 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h3><h4 id="vi-vim-使用编辑器打开文件"><a href="#vi-vim-使用编辑器打开文件" class="headerlink" title="vi/vim    使用编辑器打开文件"></a>vi/vim    使用编辑器打开文件</h4><pre><code class="line-numbers language-bash"></code></pre>
<h4 id="cat-全文查看"><a href="#cat-全文查看" class="headerlink" title="cat    全文查看"></a>cat    全文查看</h4><pre><code class="line-numbers language-bash"># cat [选项] [文件]...
-n, --number             # 带行号输出，1+
-s, --squeeze-blank      # n行空白替换为1行</code></pre>
<h4 id="more-分页查看"><a href="#more-分页查看" class="headerlink" title="more    分页查看"></a>more    分页查看</h4><pre><code class="line-numbers language-bash">more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] </code></pre>
<pre><code class="line-numbers language-bash">Enter 
 向下滚动一屏
空格键 向下滚动一屏
Ctrl+B 返回上一屏
= 输出当前行的行号
：f 输出文件名和当前行的行号
V 调用vi编辑器
!命令 调用Shell，并执行命令 
q 退出more</code></pre>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Enter</td>
<td>向下n行，需要定义。默认为1行</td>
<td></td>
</tr>
<tr>
<td>Ctrl+F / 空格</td>
<td>向下滚动一屏</td>
<td></td>
</tr>
<tr>
<td>ctrl+B</td>
<td>返回上一屏</td>
<td></td>
</tr>
<tr>
<td>=</td>
<td>输出当前行号</td>
<td></td>
</tr>
<tr>
<td>！</td>
<td>调出shell并执行命令</td>
<td></td>
</tr>
<tr>
<td>v</td>
<td>调用vi编辑器</td>
<td></td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
<td></td>
</tr>
</tbody></table>
<h4 id="less-更强大的more"><a href="#less-更强大的more" class="headerlink" title="less    更强大的more"></a>less    更强大的more</h4><h4 id="tail-输出文件最后部分"><a href="#tail-输出文件最后部分" class="headerlink" title="tail    输出文件最后部分"></a>tail    输出文件最后部分</h4><pre><code class="line-numbers language-bash">-f         动态循环读取
-q         不显示处理信息
-v         显示详细的处理信息
-c        &lt;数目&gt; 显示的字节数
-n        &lt;行数&gt; 显示行数
--pid=PID                     与-f合用,表示在进程ID,PID死掉之后结束. 
-q, --quiet, --silent         从不输出给出文件名的首部 
-s, --sleep-interval=S         与-f合用,表示在每次反复的间隔休眠S秒 </code></pre>
<h4 id="head-输出文件前10行"><a href="#head-输出文件前10行" class="headerlink" title="head    输出文件前10行"></a>head    输出文件前10行</h4><pre><code class="line-numbers language-bash">head [参数]... [文件]...  </code></pre>
<pre><code class="line-numbers language-baash">-q         隐藏文件名
-v         显示文件名
-c&lt;字节&gt;     显示字节数
-n&lt;行数&gt;     显示的行数</code></pre>
<h4 id="diff-显示差异"><a href="#diff-显示差异" class="headerlink" title="diff    显示差异"></a>diff    显示差异</h4><pre><code class="line-numbers language-bash">diff[参数][文件1或目录1][文件2或目录2]</code></pre>
<h4 id="awk-文本分析"><a href="#awk-文本分析" class="headerlink" title="awk    文本分析"></a>awk    文本分析</h4><pre><code class="line-numbers language-shell"># log.txt
2 this is a test
3 Are you like awk
This&#39;s a test
10 There are orange,apple,mongo</code></pre>
<pre><code class="line-numbers language-bash"># 每行按空格或TAB分割，输出文本中的1、4项
awk &#39;&#123;print $1,$4&#125;&#39; log.txt        
# 2 a
# 3 like
# This&#39;s
# 10 orange,apple,mongo</code></pre>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="ping-网络测试"><a href="#ping-网络测试" class="headerlink" title="ping    网络测试"></a>ping    网络测试</h4><pre><code class="line-numbers language-bash">ping [参数] [主机名或IP地址]</code></pre>
<pre><code class="line-numbers language-bash">-d         使用Socket的SO_DEBUG功能。
-f      极限检测。大量且快速地送网络封包给一台机器，看它的回应。
-n         只输出数值。
-q         不显示任何传送封包的信息，只显示最后的结果。
-r         忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。
-R         记录路由过程。
-v         详细显示指令的执行过程。
&lt;p&gt;-c     数目：在发送指定数目的包后停止。
-i         秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。
-I         网络界面：使用指定的网络界面送出数据包。
-l         前置载入：设置在送出要求信息之前，先行发出的数据包。
-p         范本样式：设置填满数据包的范本样式。
-s         字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。
-t         存活数值：设置存活数值TTL的大小。</code></pre>
<h4 id="ssh-远程登陆主机"><a href="#ssh-远程登陆主机" class="headerlink" title="ssh    远程登陆主机"></a>ssh    远程登陆主机</h4><pre><code class="line-numbers language-bash">ssh [-l login_name] [-p port] [user@]hostname</code></pre>
<h4 id="scp-远程拷贝（secure-copy）"><a href="#scp-远程拷贝（secure-copy）" class="headerlink" title="scp    远程拷贝（secure copy）"></a>scp    远程拷贝（secure copy）</h4><pre><code class="line-numbers language-bash">scp [参数] [原路径] [目标路径]</code></pre>
<pre><code class="line-numbers language-bash">-r 递归复制整个目录。 
-v 详细方式显示输出，用于调试连接，验证和配置问题。 
-i identity_file 指定密钥文件，此参数直接传递给ssh。 
-l limit 限定用户所能使用的带宽，以Kbit/s为单位。 
-P port 注意是大写的P, port是指定数据传输用到的端口号 </code></pre>
<h4 id="telnet-端口测试"><a href="#telnet-端口测试" class="headerlink" title="telnet    端口测试"></a>telnet    端口测试</h4><p>多用于远程登陆，现常用于测试端口是否开启</p>
<pre><code class="line-numbers language-bash">telnet IP/域名 端口</code></pre>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200909204431.png"></p>
<h4 id="netstat-TCP和UDP监听"><a href="#netstat-TCP和UDP监听" class="headerlink" title="netstat    TCP和UDP监听"></a>netstat    TCP和UDP监听</h4><pre><code class="line-numbers language-bash">netstat -a        # 详细的网络状况
netstat -nu        # 当前用户UDP连接状况
netstat -apu    # UDP端口号的使用情况
netstat -i        # 显示网卡列表
netstat -g        # 组播组的关系
netstat -s        # 网络统计信息
netstat -l        # 监听的套接口</code></pre>
<h4 id="wget-下载工具"><a href="#wget-下载工具" class="headerlink" title="wget    下载工具"></a>wget    下载工具</h4><pre><code class="line-numbers language-bash">wget [参数] [URL]</code></pre>
<pre><code class="line-numbers language-bash"># 启动参数
-V, –version 显示wget的版本后退出
-h, –help 打印语法帮助
-b, –background 启动后转入后台执行
-e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc

# 记录和输入文件参数：
-o, –output-file=FILE 把记录写到FILE文件中
-a, –append-output=FILE 把记录追加到FILE文件中
-d, –debug 打印调试输出
-q, –quiet 安静模式(没有输出)
-v, –verbose 冗长模式(这是缺省设置)
-nv, –non-verbose 关掉冗长模式，但不是安静模式
-i, –input-file=FILE 下载在FILE文件中出现的URLs
-F, –force-html 把输入文件当作HTML格式文件对待
-B, –base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀
–sslcertfile=FILE 可选客户端证书
–sslcertkey=KEYFILE 可选客户端证书的KEYFILE
–egd-file=FILE 指定EGD socket的文件名

# 下载参数：
–bind-address=ADDRESS 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用)
-t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制).
-O –output-document=FILE 把文档写到FILE文件中
-nc, –no-clobber 不要覆盖存在的文件或使用.#前缀
-c, –continue 接着下载没下载完的文件
–progress=TYPE 设定进程条标记
-N, –timestamping 不要重新下载文件除非比本地文件新
-S, –server-response 打印服务器的回应
–spider 不下载任何东西
-T, –timeout=SECONDS 设定响应超时的秒数
-w, –wait=SECONDS 两次尝试之间间隔SECONDS秒
–waitretry=SECONDS 在重新链接之间等待1…SECONDS秒
–random-wait 在下载之间等待0…2*WAIT秒
-Y, –proxy=on/off 打开或关闭代理
-Q, –quota=NUMBER 设置下载的容量限制
–limit-rate=RATE 限定下载输率

# 目录参数：
-nd –no-directories 不创建目录
-x, –force-directories 强制创建目录
-nH, –no-host-directories 不创建主机目录
-P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/…
–cut-dirs=NUMBER 忽略 NUMBER层远程目录

# HTTP 选项参数：
–http-user=USER 设定HTTP用户名为 USER.
–http-passwd=PASS 设定http密码为 PASS
-C, –cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许)
-E, –html-extension 将所有text/html文档以.html扩展名保存
–ignore-length 忽略 `Content-Length’头域
–header=STRING 在headers中插入字符串 STRING
–proxy-user=USER 设定代理的用户名为 USER
–proxy-passwd=PASS 设定代理的密码为 PASS
–referer=URL 在HTTP请求中包含 `Referer: URL’头
-s, –save-headers 保存HTTP头到文件
-U, –user-agent=AGENT 设定代理的名称为 AGENT而不是 Wget/VERSION
–no-http-keep-alive 关闭 HTTP活动链接 (永远链接)
–cookies=off 不使用 cookies
–load-cookies=FILE 在开始会话前从文件 FILE中加载cookie
–save-cookies=FILE 在会话结束后将 cookies保存到 FILE文件中

# FTP 选项参数：
-nr, –dont-remove-listing 不移走 `.listing’文件
-g, –glob=on/off 打开或关闭文件名的 globbing机制
–passive-ftp 使用被动传输模式 (缺省值).
–active-ftp 使用主动传输模式
–retr-symlinks 在递归的时候，将链接指向文件(而不是目录)

# 递归下载参数：
-r, –recursive 递归下载－－慎用!
-l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷)
–delete-after 在现在完毕后局部删除文件
-k, –convert-links 转换非相对链接为相对链接
-K, –backup-converted 在转换文件X之前，将之备份为 X.orig
-m, –mirror 等价于 -r -N -l inf -nr
-p, –page-requisites 下载显示HTML文件的所有图片

# 递归下载中的包含和不包含(accept/reject)：
-A, –accept=LIST 分号分隔的被接受扩展名的列表
-R, –reject=LIST 分号分隔的不被接受的扩展名的列表
-D, –domains=LIST 分号分隔的被接受域的列表
–exclude-domains=LIST 分号分隔的不被接受的域的列表
–follow-ftp 跟踪HTML文档中的FTP链接
–follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表
-G, –ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表
-H, –span-hosts 当递归时转到外部主机
-L, –relative 仅仅跟踪相对链接
-I, –include-directories=LIST 允许目录的列表
-X, –exclude-directories=LIST 不被包含目录的列表
-np, –no-parent 不要追溯到父目录
wget -S –spider url 不下载只显示过程</code></pre>
<h4 id="ifconfig-查看-配置网卡"><a href="#ifconfig-查看-配置网卡" class="headerlink" title="ifconfig    查看/配置网卡"></a>ifconfig    查看/配置网卡</h4><h4 id="route-路由配置"><a href="#route-路由配置" class="headerlink" title="route    路由配置"></a>route    路由配置</h4><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="whereis-查找程序名"><a href="#whereis-查找程序名" class="headerlink" title="whereis    查找程序名"></a>whereis    查找程序名</h4><pre><code class="line-numbers language-bash">whereis命令只能用于程序名的搜索，而且只搜索
- 二进制文件（参数-b）
- man说明文件（参数-m）
- 源代码文件（参数-s）。如果省略参数，则返回所有信息。
和find相比，whereis查找的速度非常快，这是因为linux系统会将系统内的所有文件都记录在一个数据库文件中。
但是该数据库文件并不是实时更新，默认情况下时一星期更新一次</code></pre>
<h4 id="which-查找可执行文件"><a href="#which-查找可执行文件" class="headerlink" title="which    查找可执行文件"></a>which    查找可执行文件</h4><pre><code class="line-numbers language-bash"># 会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果
-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
-p 　与-n参数相同，但此处的包括了文件的路径。
-w 　指定输出时栏位的宽度。
-V 　显示版本信息</code></pre>
<h4 id="grep-分析输出"><a href="#grep-分析输出" class="headerlink" title="grep    分析输出"></a>grep    分析输出</h4><p>该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等，比如可以加在ps, tail, cat后面</p>
<pre><code class="line-numbers language-bash">grep [-acinv] [--color=auto] &#39;查找字符串&#39; filename</code></pre>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="clear-清屏"><a href="#clear-清屏" class="headerlink" title="clear    清屏"></a>clear    清屏</h4><h4 id="date-日期显示"><a href="#date-日期显示" class="headerlink" title="date    日期显示"></a>date    日期显示</h4><pre><code class="line-numbers language-bash">$ date &#39;+%T&#39;
# 21:03:51</code></pre>
<h4 id="ln-创建链接"><a href="#ln-创建链接" class="headerlink" title="ln    创建链接"></a>ln    创建链接</h4><pre><code class="line-numbers language-bash">软链接：
1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式
2.软链接可以 跨文件系统 ，硬链接不可以
3.软链接可以对一个不存在的文件名进行链接
4.软链接可以对目录进行链接

硬链接:
1.硬链接，以文件副本的形式存在。但不占用实际空间。
2.不允许给目录创建硬链接
3.硬链接只有在同一个文件系统中才能创建</code></pre>
<pre><code class="line-numbers language-bash">ln [参数][源文件或目录][目标文件或目录]</code></pre>
<pre><code class="line-numbers language-bash"># 必要参数:
-b 删除，覆盖以前建立的链接
-d 允许超级用户制作目录的硬链接
-f 强制执行
-i 交互模式，文件存在则提示用户是否覆盖
-n 把符号链接视为一般目录
-s 软链接(符号链接)
-v 显示详细的处理过程

# 选择参数:
-S “-S&lt;字尾备份字符串&gt; ”或 “--suffix=&lt;字尾备份字符串&gt;”
-V “-V&lt;备份方式&gt;”或“--version-control=&lt;备份方式&gt;”</code></pre>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy框架笔记·Selectors数据匹配与提取类</title>
    <url>/2020/%E7%88%AC%E8%99%AB/scrapy%20Selectors/</url>
    <content><![CDATA[<p>爬虫的一个重要的任务是从爬取到的网页（HTML源码）中分析、提取数据，常用库如：</p>
<ul>
<li>BeautifulSoup：流行的网页分析库，基于HTML结构生成Python对象，但缺点也很明显：<strong>慢</strong></li>
<li>lxml：基于ElementTree的XML解析库，也可以用来解析HTML</li>
</ul>
<p>Scrapy自己实现了网页解析方法，被称为选择器，它是一个 <strong>选择器对象（scrapy.selector.Selector类实例）</strong>，该对象可以通过XPath或CSS方法表达式分析提取HTML中的数据。</p>
<a id="more"></a>

<hr>
<h3 id="classscrapy-selector-Selector-args-kwargs"><a href="#classscrapy-selector-Selector-args-kwargs" class="headerlink" title="classscrapy.selector.Selector(**args*, kwargs)"></a><em>class</em><code>scrapy.selector.Selector</code><strong>(**</strong>args*<strong>,</strong> <strong><em>kwargs</em></strong>)</h3><h4 id="xpath-选择器方法"><a href="#xpath-选择器方法" class="headerlink" title="xpath()    选择器方法"></a><code>xpath()</code>    选择器方法</h4><p><code>xpath(query, namespaces=None, **kwargs)</code></p>
<h4 id="css-选择器方法"><a href="#css-选择器方法" class="headerlink" title="css()    选择器方法"></a><code>css()</code>    选择器方法</h4><p><code>css(query)</code>    </p>
<p>应用给定的css表达式并返回 <a href="https://www.osgeo.cn/scrapy/topics/selectors.html#scrapy.selector.SelectorList"><code>SelectorList</code></a> 实例，<code>query</code> 是包含要应用的CSS选择器的字符串。</p>
<p>源码实现为：使用 <span class="exturl" data-url="aHR0cHM6Ly9weXBpLnB5dGhvbi5vcmcvcHlwaS9jc3NzZWxlY3Qv">cssselect<i class="fa fa-external-link-alt"></i></span> 类库与运行 <code>.xpath()</code> 方法。</p>
<h4 id="get"><a href="#get" class="headerlink" title="get()"></a><code>get()</code></h4><p>返回匹配到的第一个结果字符串，缺省值None</p>
<h4 id="attrib-属性字典"><a href="#attrib-属性字典" class="headerlink" title="attrib    属性字典"></a><code>attrib</code>    属性字典</h4><p>返回基础元素的属性字典。</p>
<h3 id="如何构建一个选择器对象"><a href="#如何构建一个选择器对象" class="headerlink" title="如何构建一个选择器对象"></a>如何构建一个选择器对象</h3><p>selector对象是以字符串或网页响应构造的Selector类实例，<code>Selector</code> automatically chooses the best parsing rules (XML vs HTML) based on input type.</p>
<p>以字符串构造</p>
<pre><code class="line-numbers language-python">from scrapy.selector import Selector

body = &#39;&lt;html&gt;&lt;body&gt;&lt;span&gt;good&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;&#39;
Selector(text=body).xpath(&#39;//span/text()&#39;).get()
# &#39;good&#39;</code></pre>
<p>以响应构造</p>
<pre><code class="line-numbers language-python">import requests
from scrapy.selector import Selector

response = Selector(response=requests.get(&#39;http://www.baidu.com&#39;))
response.xpath(&#39;//title/text()&#39;).get()
# &#39;百度一下，你就知道&#39;</code></pre>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>目标网页：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNjcmFweS5vcmcvZW4vbGF0ZXN0L19zdGF0aWMvc2VsZWN0b3JzLXNhbXBsZTEuaHRtbA==">https://docs.scrapy.org/en/latest/_static/selectors-sample1.html<i class="fa fa-external-link-alt"></i></span> ，源代码：</p>
<pre><code class="line-numbers language-html">&lt;html&gt;
 &lt;head&gt;
  &lt;base href=&#39;http://example.com/&#39; /&gt;
  &lt;title&gt;Example website&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;div id=&#39;images&#39;&gt;
   &lt;a href=&#39;image1.html&#39;&gt;Name: My image 1 &lt;br /&gt;&lt;img src=&#39;image1_thumb.jpg&#39; /&gt;&lt;/a&gt;
   &lt;a href=&#39;image2.html&#39;&gt;Name: My image 2 &lt;br /&gt;&lt;img src=&#39;image2_thumb.jpg&#39; /&gt;&lt;/a&gt;
   &lt;a href=&#39;image3.html&#39;&gt;Name: My image 3 &lt;br /&gt;&lt;img src=&#39;image3_thumb.jpg&#39; /&gt;&lt;/a&gt;
   &lt;a href=&#39;image4.html&#39;&gt;Name: My image 4 &lt;br /&gt;&lt;img src=&#39;image4_thumb.jpg&#39; /&gt;&lt;/a&gt;
   &lt;a href=&#39;image5.html&#39;&gt;Name: My image 5 &lt;br /&gt;&lt;img src=&#39;image5_thumb.jpg&#39; /&gt;&lt;/a&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;</code></pre>
<pre><code class="line-numbers language-bash">scrapy shell https://docs.scrapy.org/en/latest/_static/selectors-sample1.html</code></pre>
<p>当shell加载完成后会出现两个对象：<code>response</code>、<code>response.selector</code>用于数据的提取</p>
<pre><code class="line-numbers language-python">response.xpath(&#39;//title/text()&#39;)
# [&lt;Selector xpath=&#39;//title/text()&#39; data=&#39;Example website&#39;&gt;]</code></pre>
<p>上面使用xpath提取了网站的标题，但结果保存在对象内，使用对象方法提取数据</p>
<table>
<thead>
<tr>
<th align="right">方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td align="right">Selector.get() / Selector.extract_first()</td>
<td>返回单个（列表中的第一个）结果字符串</td>
</tr>
<tr>
<td align="right">Selector.getall() / Selector.extract()</td>
<td>返回所有结果列表</td>
</tr>
<tr>
<td align="right">Selector.re(pattern)</td>
<td>对结果进行二次筛选</td>
</tr>
</tbody></table>
<pre><code class="line-numbers language-python">response.xpath(&#39;//title/text()&#39;).get()
# &#39;Example website&#39;

response.xpath(&#39;//title/text()&#39;).getall()
# [&#39;Example website&#39;]

response.xpath(&#39;//title/text()&#39;).re(&#39;\w+&#39;)
# [&#39;Example&#39;, &#39;website&#39;]</code></pre>
<p>假如没有匹配到数据，会返回None，我们预设字符串替换这个空值</p>
<pre><code class="line-numbers language-python">response.xpath(&#39;//code/text()&#39;).get() is None
# True

response.xpath(&#39;//code/text()&#39;).get(&#39;未找到&#39;)
# &#39;未找到&#39;</code></pre>
<p>因为xpath与css返回的都是Selector对象，所以匹配方法还可以混合使用</p>
<pre><code class="line-numbers language-python">response.css(&#39;img&#39;).xpath(&#39;@src&#39;).getall()
# [&#39;image1_thumb.jpg&#39;,
#  &#39;image2_thumb.jpg&#39;,
#  &#39;image3_thumb.jpg&#39;,
#  &#39;image4_thumb.jpg&#39;,
#  &#39;image5_thumb.jpg&#39;]</code></pre>
<p>另一种方法，<code>.attrib[&#39;属性&#39;]</code>用于提取属性值</p>
<pre><code class="line-numbers language-python">response.css(&#39;img::attr(src)&#39;).get()
# &#39;image1_thumb.jpg&#39;

response.xpath(&#39;//img/@src&#39;).get()
# &#39;image1_thumb.jpg&#39;

response.css(&#39;img&#39;).attrib[&#39;src&#39;]
# &#39;image1_thumb.jpg&#39;</code></pre>
<p>获取image链接的所有方法</p>
<pre><code class="line-numbers language-python">response.xpath(&#39;//base/@href&#39;).get()
# &#39;http://example.com/&#39;
response.css(&#39;base::attr(href)&#39;).get()
# &#39;http://example.com/&#39;
response.css(&#39;base&#39;).attrib[&#39;href&#39;]
# &#39;http://example.com/&#39;

response.xpath(&#39;//a[contains(@href, &quot;image&quot;)]/@href&#39;).getall()
[&#39;image1.html&#39;,
 &#39;image2.html&#39;,
 &#39;image3.html&#39;,
 &#39;image4.html&#39;,
 &#39;image5.html&#39;]
response.css(&#39;a[href*=image]::attr(href)&#39;).getall()
[&#39;image1.html&#39;,
 &#39;image2.html&#39;,
 &#39;image3.html&#39;,
 &#39;image4.html&#39;,
 &#39;image5.html&#39;]
response.xpath(&#39;//a[contains(@href, &quot;image&quot;)]/img/@src&#39;).getall()
[&#39;image1_thumb.jpg&#39;,
 &#39;image2_thumb.jpg&#39;,
 &#39;image3_thumb.jpg&#39;,
 &#39;image4_thumb.jpg&#39;,
 &#39;image5_thumb.jpg&#39;]
response.css(&#39;a[href*=image] img::attr(src)&#39;).getall()
[&#39;image1_thumb.jpg&#39;,
 &#39;image2_thumb.jpg&#39;,
 &#39;image3_thumb.jpg&#39;,
 &#39;image4_thumb.jpg&#39;,
 &#39;image5_thumb.jpg&#39;]</code></pre>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy框架笔记·框架命令</title>
    <url>/2020/%E7%88%AC%E8%99%AB/scrapy%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>scrapy命令行包括：</p>
<ul>
<li>全局命令：包括创建项目、创建spider、shell、测试等方法</li>
<li>项目命令：运行爬虫等</li>
</ul>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNjcmFweS5vcmcvZW4vbGF0ZXN0L3RvcGljcy9jb21tYW5kcy5odG1s">scrapy document v2.1<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>

<h2 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h2><ul>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/commands.html#std-command-startproject"><code>startproject</code></a>： 创建项目，不指定project_dir会使用project_name作为文件夹名称</p>
<pre><code class="line-numbers language-bash">scrapy startproject &lt;project_name&gt; [project_dir]</code></pre>
</li>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/commands.html#std-command-genspider"><code>genspider</code></a>：生成spider</p>
<pre><code class="line-numbers language-bash">scrapy genspider [-t template] &lt;name&gt; &lt;domain&gt;</code></pre>
<pre><code>[-t template] - 模板
    basic    默认
    crawl    
      csvfeed    
      xmlfeed    
&lt;name&gt; - spider.name
&lt;domain&gt; - spider.allowed_domains 和 spider.start_urls</code></pre>
</li>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/commands.html#std-command-settings"><code>settings</code></a>：输出scrapy设置信息</p>
<pre><code class="line-numbers language-bash">Usage
=====
  scrapy settings [options]

Get settings values

Options
=======
--help, -h              show this help message and exit
--get=SETTING           print raw setting value
--getbool=SETTING       print setting value, interpreted as a boolean
--getint=SETTING        print setting value, interpreted as an integer
--getfloat=SETTING      print setting value, interpreted as a float
--getlist=SETTING       print setting value, interpreted as a list</code></pre>
</li>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/commands.html#std-command-runspider"><code>runspider</code></a>：运行爬虫文件</p>
<pre><code class="line-numbers language-bash">scrapy runspider &lt;spider_file.py&gt;</code></pre>
</li>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/commands.html#std-command-shell"><code>shell</code></a>：调试shell</p>
</li>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/commands.html#std-command-bench"><code>fetch</code></a>：将网页内容下载下来，然后在终端打印当前返回的内容，相当于 request 和 urllib 方法</p>
<pre><code class="line-numbers language-bash">$ scrapy fetch --headers http://www.baidu.com --nolog
&gt; Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
&gt; Accept-Language: zh
&gt; User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0
&gt; Accept-Encoding: gzip, deflate
&gt; Cookie: BD_LAST_QID=15460141949146650168; BAIDUID=2FF1A075ECD55EC599C8BD353B1850A0:FG=1;\
BIDUPSID=2FF1A075ECD55EC53959A8386AEC227B; PSTM=1599746512
&gt;
&lt; Bdpagetype: 1
&lt; Bdqid: 0x95ab807d0000113c
&lt; Cache-Control: private
&lt; Content-Type: text/html;charset=utf-8
&lt; Date: Thu, 10 Sep 2020 14:01:53 GMT
&lt; Expires: Thu, 10 Sep 2020 14:01:53 GMT
&lt; Server: BWS/1.1
&lt; Set-Cookie: BDSVRTM=13; path=/
&lt; Set-Cookie: BD_HOME=1; path=/
&lt; Set-Cookie: H_PS_PSSID=7511_32617_1437_32693_7567_7543_32327_7612_32673_7623_32117_7565; path=/; domain=.baidu.com
&lt; Strict-Transport-Security: max-age=172800
&lt; Traceid: 1599746513242128615410784855007028056380
&lt; X-Ua-Compatible: IE=Edge,chrome=1</code></pre>
<p>Supported options:</p>
<ul>
<li><p><code>--spider=SPIDER</code>: bypass spider autodetection and force use of specific spider</p>
</li>
<li><p><code>--a NAME=VALUE</code>: set spider argument (may be repeated)</p>
</li>
<li><p><code>--callback</code> or <code>-c</code>: spider method to use as callback for parsing the response</p>
</li>
<li><p><code>--meta</code> or <code>-m</code>: additional request meta that will be passed to the callback request. This must be a valid json string. Example: –meta=’{“foo” : “bar”}’</p>
</li>
<li><p><code>--cbkwargs</code>: additional keyword arguments that will be passed to the callback. This must be a valid json string. Example: –cbkwargs=’{“foo” : “bar”}’</p>
</li>
<li><p><code>--pipelines</code>: process items through pipelines</p>
</li>
<li><p><code>--rules</code> or <code>-r</code>: use <a href="https://docs.scrapy.org/en/latest/topics/spiders.html#scrapy.spiders.CrawlSpider"><code>CrawlSpider</code></a> rules to discover the callback (i.e. spider method) to use for parsing the response</p>
</li>
<li><p><code>--noitems</code>: don’t show scraped items</p>
</li>
<li><p><code>--nolinks</code>: don’t show extracted links</p>
</li>
<li><p><code>--nocolour</code>: avoid using pygments to colorize the output</p>
</li>
<li><p><code>--depth</code> or <code>-d</code>: depth level for which the requests should be followed recursively (default: 1)</p>
</li>
<li><p><code>--verbose</code> or <code>-v</code>: display information for each depth level</p>
</li>
<li><p><code>--output</code> or <code>-o</code>: dump scraped items to a file</p>
<p>New in version 2.3.</p>
</li>
</ul>
</li>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/commands.html#std-command-view"><code>view</code></a>：将网页内容保存下来，并在浏览器中打开当前网页内容，直观呈现要爬取网页的内容</p>
</li>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/commands.html#std-command-version"><code>version</code></a></p>
</li>
</ul>
<h2 id="项目级命令"><a href="#项目级命令" class="headerlink" title="项目级命令"></a>项目级命令</h2><ul>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/commands.html#std-command-crawl"><code>crawl</code></a>：运行爬虫</p>
<pre><code class="line-numbers language-bash">scrapy crawl &lt;spider.name&gt;
[ ... myspider starts crawling ... ]</code></pre>
</li>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/commands.html#std-command-check"><code>check</code></a>：检查spider文件有无语法错误</p>
<pre><code class="line-numbers language-bash">scrapy check [-l] &lt;spider&gt;</code></pre>
<pre><code class="line-numbers language-bash">$ scrapy check -l
first_spider
  * parse
  * parse_item
second_spider
  * parse
  * parse_item

$ scrapy check
[FAILED] first_spider:parse_item
&gt;&gt;&gt; &#39;RetailPricex&#39; field is missing

[FAILED] first_spider:parse
&gt;&gt;&gt; Returned 92 requests, expected 0..4</code></pre>
</li>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/commands.html#std-command-list"><code>list</code></a>：列出当前项目的所有spider.name</p>
</li>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/commands.html#std-command-edit"><code>edit</code></a>：vim编辑spider文件，其实IDE方式更为合适</p>
</li>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/commands.html#std-command-parse"><code>parse</code></a>：输出格式化内容</p>
</li>
<li><p>bench：测试爬取性能</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy框架笔记·常用自定义组件</title>
    <url>/2020/%E7%88%AC%E8%99%AB/scrapy%E5%B8%B8%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<ul>
<li>自定义组件的启用流程</li>
<li>随机请求头middleware</li>
<li>HTTP代理middleware</li>
<li>Mysql异步写入pipeline</li>
<li>图片下载pipeline</li>
</ul>
<a id="more"></a>

<hr>
<h4 id="自定义组件的启用流程"><a href="#自定义组件的启用流程" class="headerlink" title="自定义组件的启用流程"></a>自定义组件的启用流程</h4><ul>
<li><p>编写组件</p>
</li>
<li><p>settings.py启用组件</p>
<pre><code class="line-numbers language-python"># middleware
DOWNLOADER_MIDDLEWARES = &#123;
    &#39;yourProjectName.middlewares.classname&#39;: 312,
&#125;
# pipeline
ITEM_PIPELINES = &#123;
    &#39;yourProjectName.pipelines.classname&#39;: 312,
&#125;</code></pre>
</li>
</ul>
<h4 id="设置随机请求头"><a href="#设置随机请求头" class="headerlink" title="设置随机请求头"></a>设置随机请求头</h4><p>安装fake-useragent库</p>
<pre><code class="line-numbers language-bash">pip install fake-useragent</code></pre>
<pre><code class="line-numbers language-python"># middleware.py
from fake_useragent import UserAgent

class RandomUserAgentMiddlware(object):
    def __init__(self,crawler):
        super(RandomUserAgentMiddlware,self).__init__()
        self.ua = UserAgent()

    @classmethod
    def from_crawler(cls,crawler):
        return cls(crawler)

    def process_request(self,request,spider):
        request.headers.setdefault(&quot;User-Agent&quot;,self.ua.random)</code></pre>
<p>启用中间件</p>
<pre><code class="line-numbers language-python">DOWNLOADER_MIDDLEWARES = &#123;
    &#39;yourProjectName.middlewares.RandomUserAgentMiddlware&#39;: 312,
&#125;</code></pre>
<h4 id="设置HTTP代理"><a href="#设置HTTP代理" class="headerlink" title="设置HTTP代理"></a>设置HTTP代理</h4><p>我使用的是<a href="">阿布云</a>的代理</p>
<pre><code class="line-numbers language-python"># middleware.py
import base64

proxyServer = &quot;http://http-dyn.abuyun.com:9020&quot;
proxyUser = &quot;your proxyUser&quot;
proxyPass = &quot;your proxyPass&quot;

proxyAuth = &quot;Basic &quot; + base64.urlsafe_b64encode(bytes((proxyUser + &quot;:&quot; + proxyPass), &quot;ascii&quot;)).decode(&quot;utf8&quot;)

class ProxyMiddleware(object):
    def process_request(self, request, spider):
        request.meta[&quot;proxy&quot;] = proxyServer
        request.headers[&quot;Proxy-Authorization&quot;] = proxyAuth</code></pre>
<h4 id="Mysql异步写入"><a href="#Mysql异步写入" class="headerlink" title="Mysql异步写入"></a>Mysql异步写入</h4><pre><code class="line-numbers language-python"># pipelines.py
from yourProjectName.settings import MYSQL_DBNAME, MYSQL_HOST,MYSQL_PASSWORD,MYSQL_PORT,MYSQL_USER

class MysqlTwistedPipeline(object):
    &quot;&quot;&quot;
    异步写入mysql
    &quot;&quot;&quot;
    def __init__(self, dbpool):
        self.dbpool = dbpool

    @classmethod
    def from_settings(cls,setting):
        dbparms = dict(
            host=MYSQL_HOST,
            db=MYSQL_DBNAME,
            user=MYSQL_USER,
            passwd=MYSQL_PASSWORD,
            port=MYSQL_PORT,
            charset=&#39;utf8&#39;,
            cursorclass=pymysql.cursors.DictCursor,
            use_unicode=False,
        )
        dbpool = adbapi.ConnectionPool(&quot;pymysql&quot;, **dbparms)
        return cls(dbpool)

    def process_item(self, item, spider):
        query = self.dbpool.runInteraction(self.do_insert, item)
        query.addCallback(self.handle_error)

    def handle_error(self, failure):
        print(&quot;MysqlTwistedPipeline error is :&quot;,failure)

    def do_insert(self, cursor, item):
        insert_sql = &quot;&quot;&quot;insert_sql&quot;&quot;&quot;
        cursor.execute(insert_sql, ())#有些情况需使用pymysql.escape_string()对item字段进行转义</code></pre>
<h4 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h4><pre><code class="line-numbers language-python"># pipelines.py
from scrapy import Request
from scrapy.pipelines.images import ImagesPipeline
class ImagePipeline(ImagesPipeline):
    headers = &#123;
        &quot;&quot;&quot;如果网站有headers检测就加上&quot;&quot;&quot;
    &#125;

    def get_media_requests(self, item, info):
        # 循环每一张图片地址下载，若传过来的不是集合则无需循环直接yield
        for image_url in item[&#39;imgurl&#39;]:
            headers = self.headers
            headers[&#39;Referer&#39;] = item[&#39;from_url&#39;]
            # meta里面的数据是从spider获取，然后通过meta传递给下面方法：file_path
            yield Request(image_url,headers=headers,meta=&#123;&#39;foldername&#39;: item[&#39;foldername&#39;], &#39;imgname&#39;: item[&#39;imgname&#39;]&#125;)
    # 重命名，若不重写这函数，图片名为哈希
    def file_path(self, request, response=None, info=None):
        pic_format = request.url.split(&quot;.&quot;)[-1]
        imgname = request.meta[&#39;imgname&#39;]
        # 接收meta传递过来的图集名称
        foldername = request.meta[&#39;foldername&#39;]
        # 过滤windows字符串
        foldername = re.sub(r&#39;[？\\*|“&lt;&gt;:/]&#39;, &#39;&#39;, foldername)
        filename = fr&#39;&#123;foldername&#125;/&#123;imgname&#125;.&#123;pic_format&#125;&#39;
        return filename</code></pre>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>反爬虫手段的解决办法</title>
    <url>/2020/%E7%88%AC%E8%99%AB/%E5%8F%8D%E7%88%AC%E8%99%AB%E6%89%8B%E6%AE%B5%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li>防盗链</li>
<li>禁止爬虫</li>
</ul>
<a id="more"></a>

<hr>
<h3 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h3><p>爬取过程中可能遇到这样的</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200913211504.png"></p>
<p>或者这样的</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200913211535.png"></p>
<p>问题出现的原因就是服务器会检测我们的请求来源，也就是headers的refer键的值。</p>
<p>解决办法也很简单，从上个请求中获取URL保存到本次请求头的refer字段即可</p>
<h4 id="禁止爬虫"><a href="#禁止爬虫" class="headerlink" title="禁止爬虫"></a>禁止爬虫</h4><p>修改请求头的User-Agent属性为浏览器头</p>
<p>或者使用模拟类库</p>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 及 Github的使用</title>
    <url>/2020/%E9%9A%8F%E7%AC%94/Git%20%E5%8F%8A%20Github%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<ul>
<li>Git：一个开源的分布式版本控制系统</li>
<li>Github：一个代码仓库网站</li>
</ul>
<a id="more"></a>

<h3 id="git本地设置"><a href="#git本地设置" class="headerlink" title="git本地设置"></a>git本地设置</h3><pre><code class="line-numbers language-bash">git config --global user.name &quot;yuandongxu97&quot;
git config --global user.email &quot;431980110@qq.com&quot;</code></pre>
<h3 id="push时不替换换行符"><a href="#push时不替换换行符" class="headerlink" title="push时不替换换行符"></a>push时不替换换行符</h3><pre><code></code></pre>
<h3 id="本地创建推送流程"><a href="#本地创建推送流程" class="headerlink" title="本地创建推送流程"></a>本地创建推送流程</h3><pre><code class="line-numbers language-bash">mkdir study
cd study
git init
touch README.md
git add .
git commit
git remote add origin https://github.com/yuandongxu97/study
git push -u origin master</code></pre>
<h3 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h3><h4 id="config-配置相关"><a href="#config-配置相关" class="headerlink" title="config    配置相关"></a>config    配置相关</h4><pre><code class="line-numbers language-bash">git config --list
git config --global --list</code></pre>
<h4 id="init-创建-初始化一个仓库"><a href="#init-创建-初始化一个仓库" class="headerlink" title="init    创建/初始化一个仓库"></a>init    创建/初始化一个仓库</h4><h4 id="clone-克隆仓库到本地目录"><a href="#clone-克隆仓库到本地目录" class="headerlink" title="clone    克隆仓库到本地目录"></a>clone    克隆仓库到本地目录</h4><h4 id="add-将文件添加到暂存区"><a href="#add-将文件添加到暂存区" class="headerlink" title="add    将文件添加到暂存区"></a>add    将文件添加到暂存区</h4><pre><code class="line-numbers language-bash">git add file    # 添加file
git add .        # 添加当前目录所有已修改</code></pre>
<h4 id="commit-将暂存区提交到存储库"><a href="#commit-将暂存区提交到存储库" class="headerlink" title="commit    将暂存区提交到存储库"></a>commit    将暂存区提交到存储库</h4><pre><code class="line-numbers language-bash">git commit -a            # git add + git commit    
git commit -m “备注”      # 为提交节点添加备注</code></pre>
<h4 id="diff-当前文件与暂存区域差异"><a href="#diff-当前文件与暂存区域差异" class="headerlink" title="diff    当前文件与暂存区域差异"></a>diff    当前文件与暂存区域差异</h4><pre><code class="line-numbers language-bash">git diff –staged        # 暂存区和存储库差异
git diff [first branch] [second branch]        # 分支差异</code></pre>
<h4 id="reset-撤销操作"><a href="#reset-撤销操作" class="headerlink" title="reset    撤销操作"></a>reset    撤销操作</h4><pre><code class="line-numbers language-bash">git reset [file]        # </code></pre>
<h4 id="status-仓库状态"><a href="#status-仓库状态" class="headerlink" title="status    仓库状态"></a>status    仓库状态</h4><h4 id="log-提交日志"><a href="#log-提交日志" class="headerlink" title="log    提交日志"></a>log    提交日志</h4><pre><code class="line-numbers language-bash">git log
git log [file]</code></pre>
<h4 id="show-显示对象"><a href="#show-显示对象" class="headerlink" title="show    显示对象"></a>show    显示对象</h4><h4 id="branch-分支的显示、创建与删除"><a href="#branch-分支的显示、创建与删除" class="headerlink" title="branch    分支的显示、创建与删除"></a>branch    分支的显示、创建与删除</h4><pre><code class="line-numbers language-bash">git branch        # 显示本地分支列表
git branch &lt;branch_name&gt;        # 创建新分支
git branch -d &lt;branch_name&gt;        # 删除分支</code></pre>
<h4 id="checkout-分支切换"><a href="#checkout-分支切换" class="headerlink" title="checkout    分支切换"></a>checkout    分支切换</h4><pre><code class="line-numbers language-bash">git checkout &lt;branch_name&gt;        # 切换至
git checkout -b &lt;branch_name&gt;    # 创建并切换至</code></pre>
<h4 id="merge-合并"><a href="#merge-合并" class="headerlink" title="merge    合并"></a>merge    合并</h4><h4 id="remote-链接本地与远程库"><a href="#remote-链接本地与远程库" class="headerlink" title="remote    链接本地与远程库"></a>remote    链接本地与远程库</h4><pre><code class="line-numbers language-bash">git remote add [variable name] [Remote Server Link]</code></pre>
<h4 id="push-推送本地至远程仓库"><a href="#push-推送本地至远程仓库" class="headerlink" title="push    推送本地至远程仓库"></a>push    推送本地至远程仓库</h4><pre><code class="line-numbers language-bash">git push [variable name] master        # 推送主分支
git push [variable name] [branch]    # 推送指定分支
git push –all [variable name]        # 推送所有分支
    # 删除远程存储库上的分支</code></pre>
<h4 id="pull-拉取并集合"><a href="#pull-拉取并集合" class="headerlink" title="pull    拉取并集合"></a>pull    拉取并集合</h4><pre><code class="line-numbers language-bash">git pull [Repository Link]</code></pre>
]]></content>
      <tags>
        <tag>常用</tag>
        <tag>随笔</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy框架笔记·文件、图片pipeline使用解析</title>
    <url>/2020/%E7%88%AC%E8%99%AB/Scrapy%20%E6%96%87%E4%BB%B6%E3%80%81%E5%9B%BE%E7%89%87pipeline/</url>
    <content><![CDATA[<p>当我们的scrapy项目需要爬取媒体内容时，可以使用以下两条scrapy模块自带的pipeline管道进行下载处理，都包含了两个默认特殊字段：</p>
<ul>
<li>对于文件：<code>scrapy.pipelines.files.FilesPipeline</code><ul>
<li><code>item[&#39;file_urls&#39;]</code> - 下载链接列表</li>
<li><code>item[&#39;files&#39;]</code> - 管道处理结果列表（每个url的信息字典）</li>
</ul>
</li>
<li>对于图片：<code>scrapy.pipelines.images.ImagesPipeline</code><ul>
<li><code>item[&#39;image_urls&#39;]</code> - 下载链接列表</li>
<li><code>item[&#39;images&#39;]</code> - 管道处理结果列表（每个url的信息字典）</li>
</ul>
</li>
</ul>
<p>这些管道都实现了：</p>
<ul>
<li>避免重新下载最近下载的媒体</li>
<li>指定存储媒体的位置（本地、ftp位置、AmazonS3存储桶、Google云存储桶）</li>
</ul>
<p>imagespipeline作为filespipeline的子类，还实现了：</p>
<ul>
<li>将所有下载的图像转换为通用格式（JPG）和模式（RGB）</li>
<li>缩略图生成</li>
<li>图像尺寸过滤</li>
</ul>
<p>通过重写pipeline，还可以实现：</p>
<ul>
<li>自定义文件名称</li>
<li>自定义保存路径</li>
<li>爬取结果的处理</li>
</ul>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNjcmFweS5vcmcvZW4vbGF0ZXN0L3RvcGljcy9tZWRpYS1waXBlbGluZS5odG1s">scrapy document v2.3<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>

<hr>
<h2 id="1-媒体管道的使用"><a href="#1-媒体管道的使用" class="headerlink" title="1. 媒体管道的使用"></a>1. 媒体管道的使用</h2><p>（1）先在settings.py中启用管道并配置相关的存储位置。</p>
<pre><code class="line-numbers language-python">ITEM_PIPELINES = &#123;
    &#39;scrapy.pipelines.images.ImagesPipeline&#39;: 1
    &#125;
IMAGES_STORE = &#39;/data/scrapy/images&#39;</code></pre>
<p>（2）配置item字段</p>
<pre><code class="line-numbers language-python">import scrapy

class MyItem(scrapy.Item):
    # ... other item fields ...
    image_urls = scrapy.Field()        # 源文件链接
    images = scrapy.Field()        # 管道处理后的结果（爬取结果）</code></pre>
<p>（3）编码spider，将图像链接列表保存到<code>item[&#39;image_urls&#39;]</code>中</p>
<p>（4）爬取</p>
<h3 id="下载结果示例"><a href="#下载结果示例" class="headerlink" title="下载结果示例"></a>下载结果示例</h3><p>管道默认使用URL的SHA1 Hash值作为文件的名称。</p>
<p>比如说需要下载的图片URL为：<span class="exturl" data-url="aHR0cDovL3d3dy5leGFtcGxlLmNvbS9pbWFnZS5qcGc=">http://www.example.com/image.jpg<i class="fa fa-external-link-alt"></i></span></p>
<p>它的SHA1 hash为：<code>3afec3b4765f8f0a07b78f98c07b83f013567a0a</code></p>
<p>最终下载得到的文件为：<code>/data/scrapy/images/full/3afec3b4765f8f0a07b78f98c07b83f013567a0a.jpg</code></p>
<hr>
<h2 id="2-媒体管道的配置项"><a href="#2-媒体管道的配置项" class="headerlink" title="2. 媒体管道的配置项"></a>2. 媒体管道的配置项</h2><p>在项目settings.py中进行配置</p>
<h3 id="爬取结果保存位置"><a href="#爬取结果保存位置" class="headerlink" title="爬取结果保存位置"></a>爬取结果保存位置</h3><pre><code class="line-numbers language-bash">IMAGES_STORE = &#39;/path/to/valid/dir&#39;        # 图像保存位置
FILES_STORE = &#39;/path/to/valid/dir&#39;        # 文件保存位置</code></pre>
<p>FILES_STORE和IMAGES_STORE可以指向一个FTP服务器，Scrapy会自动将文件上传到服务器，FILES_STORE和IMAGES_STORE应该以下列形式之一写入:</p>
<pre><code class="line-numbers language-bash">ftp://username:password@address:port/path
ftp://address:port/path</code></pre>
<p>如果未提供用户名和密码，则分别取自</p>
<pre><code class="line-numbers language-bash">FTP_USER = &#39;admin&#39;
FTP_PASSWORD = &#39;admin&#39;</code></pre>
<h3 id="自定义item字段名称"><a href="#自定义item字段名称" class="headerlink" title="自定义item字段名称"></a>自定义item字段名称</h3><p>配置该字段可以替换掉初始的<code>file_urls</code>与<code>file</code></p>
<pre><code class="line-numbers language-bash"># 对于文件管道
FILES_URLS_FIELD = &#39;field_name_for_your_files_urls&#39;
FILES_RESULT_FIELD = &#39;field_name_for_your_processed_files&#39;
# 对于图像管道
IMAGES_URLS_FIELD = &#39;field_name_for_your_images_urls&#39;
IMAGES_RESULT_FIELD = &#39;field_name_for_your_processed_images&#39;</code></pre>
<h3 id="文件过期"><a href="#文件过期" class="headerlink" title="文件过期"></a>文件过期</h3><p>为了避免重复下载最近下载过的文件、图片，默认90day</p>
<pre><code class="line-numbers language-bash"># 120 days of delay for files expiration
FILES_EXPIRES = 120
# 30 days of delay for images expiration
IMAGES_EXPIRES = 30</code></pre>
<p>对于重写的子类pipeline，配置项添加自定义的类名作为前缀</p>
<pre><code class="line-numbers language-bash">MYPIPELINECLASSNAME_FILES_EXPIRES = 180</code></pre>
<h3 id="图片管道的缩略图"><a href="#图片管道的缩略图" class="headerlink" title="图片管道的缩略图"></a>图片管道的缩略图</h3><p>图像管道可以自动创建下载图像的缩略图，要使用此功能，必须设置 <a href="https://www.osgeo.cn/scrapy/topics/media-pipeline.html#std:setting-IMAGES_THUMBS"><code>IMAGES_THUMBS</code></a> 到一个字典，其中键是缩略图名称，值是它们的尺寸。</p>
<pre><code class="line-numbers language-bash">IMAGES_THUMBS = &#123;
    &#39;small&#39;: (50, 50),
    &#39;big&#39;: (270, 270),
&#125;</code></pre>
<p>使用此功能时，图像管道将保存缩略图到下列位置：</p>
<pre><code class="line-numbers language-bash">&lt;IMAGES_STORE&gt;/thumbs/&lt;size_name&gt;/&lt;image_id&gt;.jpg
# &lt;size_name&gt; 是在 IMAGES_THUMBS 字典键 (small ， big 等）
# &lt;image_id&gt; 是 SHA1 hash 图像URL的
# 实例
&lt;IMAGES_STORE&gt;/full/63bbfea82b8880ed33cdb762aa11fab722a90a24.jpg        # 原始
&lt;IMAGES_STORE&gt;/thumbs/small/63bbfea82b8880ed33cdb762aa11fab722a90a24.jpg
&lt;IMAGES_STORE&gt;/thumbs/big/63bbfea82b8880ed33cdb762aa11fab722a90a24.jpg</code></pre>
<h3 id="图像尺寸过滤"><a href="#图像尺寸过滤" class="headerlink" title="图像尺寸过滤"></a>图像尺寸过滤</h3><p>使用图像管道时，可以过滤过小的图像，但不影响缩略图的生成。</p>
<pre><code class="line-numbers language-bash">IMAGES_MIN_HEIGHT = 110
IMAGES_MIN_WIDTH = 110</code></pre>
<h3 id="下载失败处理"><a href="#下载失败处理" class="headerlink" title="下载失败处理"></a>下载失败处理</h3><p>管道默认忽略掉失败的下载请求，如果需要重新处理失败的请求，配置：</p>
<pre><code class="line-numbers language-bash">MEDIA_ALLOW_REDIRECTS = True</code></pre>
<h2 id="3-重写媒体管道类"><a href="#3-重写媒体管道类" class="headerlink" title="3. 重写媒体管道类"></a>3. 重写媒体管道类</h2><p>自定义类继承原管道并重写媒体管道中的方法可以对爬取中的细节进行处理</p>
<h3 id="class-scrapy-pipelines-files-FilesPipeline"><a href="#class-scrapy-pipelines-files-FilesPipeline" class="headerlink" title="class scrapy.pipelines.files.FilesPipeline"></a><em>class</em> <code>scrapy.pipelines.files.FilesPipeline</code></h3><h4 id="get-media-requests"><a href="#get-media-requests" class="headerlink" title="get_media_requests"></a><code>get_media_requests</code></h4><p><code>get_media_requests</code>(<em>item</em>, <em>info</em>)</p>
<p>因为item中保存下载链接的是一个列表字段，该方法用于从中分离单个链接并创建下载请求</p>
<pre><code class="line-numbers language-python">def get_media_requests(self, item, info):
    for file_url in item[&#39;file_urls&#39;]:
        yield scrapy.Request(file_url)</code></pre>
<p>下载完成后，结果将发送到 <a href="https://www.osgeo.cn/scrapy/topics/media-pipeline.html#scrapy.pipelines.files.FilesPipeline.item_completed"><code>item_completed()</code></a> 方法，生成一个两元素的set<code>(success, file_info_or_error)</code></p>
<pre><code class="line-numbers language-bash">[(True,
  &#123;&#39;checksum&#39;: &#39;2b00042f7481c7b056c4b410d28f33cf&#39;,
   &#39;path&#39;: &#39;full/0a79c461a4062ac383dc4fade7bc09f1384a3910.jpg&#39;,
   &#39;url&#39;: &#39;http://www.example.com/files/product1.pdf&#39;,
   &#39;status&#39;: &#39;downloaded&#39;&#125;),
 (False,
  Failure(...))]</code></pre>
<ul>
<li><p><code>success</code> - True下载成功，False下载失败</p>
</li>
<li><p><code>file_info_or_error</code> is a dict containing the following keys (if success is <code>True</code>) or a <a href="https://twistedmatrix.com/documents/current/api/twisted.python.failure.Failure.html"><code>Failure</code></a> if there was a problem.</p>
<ul>
<li><p><code>url</code> - 文件的源URL链接. This is the url of the request returned from the <a href="https://docs.scrapy.org/en/latest/topics/media-pipeline.html#scrapy.pipelines.files.FilesPipeline.get_media_requests"><code>get_media_requests()</code></a> method.</p>
</li>
<li><p><code>path</code> - 保存路径（FILES_STORE + path）</p>
</li>
<li><p><code>checksum</code> - 数据的MD5</p>
</li>
<li><p><code>status</code> - 状态指示，scrapy&gt;2.2版本提供</p>
<p>It can be one of the following:</p>
<ul>
<li><code>downloaded</code> - file was downloaded.</li>
<li><code>uptodate</code> - file was not downloaded, as it was downloaded recently, according to the file expiration policy.</li>
<li><code>cached</code> - file was already scheduled for download, by another item sharing the same file.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>默认情况下 <a href="https://www.osgeo.cn/scrapy/topics/media-pipeline.html#scrapy.pipelines.files.FilesPipeline.get_media_requests"><code>get_media_requests()</code></a> 方法返回 <code>None</code> ，这意味着该项目没有可下载的文件。</p>
<h4 id="file-path"><a href="#file-path" class="headerlink" title="file_path"></a><code>file_path</code></h4><p><code>file_path</code>(<em>self</em>, <em>request</em>, <em>response=None</em>, <em>info=None</em>)</p>
<p>（1）可以重写此方法以自定义每个文件的下载路径，默认情况下 <a href="https://www.osgeo.cn/scrapy/topics/media-pipeline.html#scrapy.pipelines.files.FilesPipeline.file_path"><code>file_path()</code></a> 方法返回 <code>full/&lt;request URL hash&gt;.&lt;extension&gt;</code> .</p>
<p>（2）重写以下载图片到files文件夹并保持原始的文件名称：即<code>https://example.com/a/b/c/foo.png --&gt; files/foo.png</code></p>
<pre><code class="line-numbers language-python">import os
from urllib.parse import urlparse

from scrapy.pipelines.files import FilesPipeline

class MyFilesPipeline(FilesPipeline):

    def file_path(self, request, response, info):
        return &#39;files/&#39; + os.path.basename(urlparse(request.url).path)</code></pre>
<h4 id="item-completed"><a href="#item-completed" class="headerlink" title="item_completed"></a><code>item_completed</code></h4><p><code>item_completed</code>(<em>results</em>, <em>item</em>, <em>info</em>)</p>
<p>当媒体管道处理完成了一项spider传递的item时（全部请求完毕，success or failed）会调用该方法，该方法用于为处理item的相关内容并返回item交给下一级管道</p>
<p>实例：将下载文件的路径传入item的<code>file_paths</code>字段中</p>
<pre><code class="line-numbers language-python">from scrapy.exceptions import DropItem

def item_completed(self, results, item, info):
    file_paths = [x[&#39;path&#39;] for ok, x in results if ok]
    if not file_paths:
        raise DropItem(&quot;Item contains no files&quot;)
    item[&#39;file_paths&#39;] = file_paths
    return item</code></pre>
<h3 id="class-scrapy-pipelines-images-ImagesPipeline"><a href="#class-scrapy-pipelines-images-ImagesPipeline" class="headerlink" title="class scrapy.pipelines.images.``ImagesPipeline"></a><em>class</em> <code>scrapy.pipelines.images.``ImagesPipeline</code></h3><p>同上</p>
<h2 id="4-自定义的文件pipeline实例"><a href="#4-自定义的文件pipeline实例" class="headerlink" title="4. 自定义的文件pipeline实例"></a>4. 自定义的文件pipeline实例</h2><p>实现功能</p>
<ul>
<li>文件使用原名称重命名</li>
<li>按title文件夹归类</li>
<li>下载结果保存</li>
</ul>
<pre><code class="line-numbers language-python">import os, scrapy
from scrapy.pipelines.files import FilesPipeline
from urllib.parse import urlparse


class MyFilesPipeline(FilesPipeline):

    def get_media_requests(self, item, info):
        &quot;&quot;&quot;重命名&quot;&quot;&quot;
        for file_url in item[&#39;file_urls&#39;]:
            yield scrapy.Request(file_url, meta=&#123;&#39;item&#39;: item.copy()&#125;)

    def file_path(self, request, response=None, info=None):
        &quot;&quot;&quot;归类&quot;&quot;&quot;
        name = request.meta[&#39;item&#39;][&#39;name&#39;]
        title = request.meta[&#39;item&#39;][&#39;title&#39;]
        return &quot;%s/%s/%s&quot; % (name, title, os.path.basename(urlparse(request.url).path))

    def item_completed(self, results, item, info):
        &quot;&quot;&quot;下载结果处理&quot;&quot;&quot;
        data = &#123;&#125;
        for status, result in results:
            data[item[&#39;title&#39;]].append(result) if status else None
        file = &#39;./%s.json&#39; % item[&#39;name&#39;]  # 以spidername命名
        with open(file, &#39;w+&#39;) as f:
            f.writelines(data)
        return item</code></pre>
<p>item.py</p>
<pre><code class="line-numbers language-python">from scrapy import Field, Item

class FilespiderItem(Item):
    file_urls = Field()
    files = Field()
    name = Field()
    title = Field()</code></pre>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy框架笔记·部署工具scrapyd的使用</title>
    <url>/2020/%E7%88%AC%E8%99%AB/Scrapyd%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Scrapyd是一个scrapy框架爬虫的端对端部署工具，scrapyd能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务。</p>
<a id="more"></a>

<hr>
<h2 id="1-Scrapyd服务"><a href="#1-Scrapyd服务" class="headerlink" title="1. Scrapyd服务"></a>1. Scrapyd服务</h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><pre><code class="line-numbers language-bash">pip install scrapyd</code></pre>
<pre><code class="line-numbers language-bash">pip install scrapyd-client</code></pre>
<h3 id="1-2-启动Scrapyd服务"><a href="#1-2-启动Scrapyd服务" class="headerlink" title="1.2 启动Scrapyd服务"></a>1.2 启动Scrapyd服务</h3><p>作为测试，本地主机（localhost）安装完成服务端后运行<code>scrapyd</code>开启服务端，浏览器访问<code>localhost:6800</code>即可访问scrapyd服务</p>
<pre><code class="line-numbers language-bash">scrapyd</code></pre>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200906142415.png"></p>
<h4 id="服务端的外网访问"><a href="#服务端的外网访问" class="headerlink" title="服务端的外网访问"></a>服务端的外网访问</h4><p>比如我的主机公网IP为<code>47.93.230.127</code>，使用命令<code>scrapyd</code>开启服务，本地主机浏览器访问<code>47.93.230.127:6800</code>是访问不到的，因为scrapyd默认bind为127.0.0.1</p>
<p>编辑scrapyd的配置文件，我的为：<code>/usr/local/lib/python3.8/dist-packages/scrapyd/default_scrapyd.conf</code>，修改</p>
<pre><code class="line-numbers language-json">bind_address = 0.0.0.0        # 绑定域名</code></pre>
<p>开启服务</p>
<pre><code class="line-numbers language-bash">$ scrapyd
2020-01-06T14:28:57+0800 [-] Loading /usr/local/lib/python3.8/dist-packages/scrapyd/txapp.py...
2020-01-06T14:28:57+0800 [-] Scrapyd web console available at http://0.0.0.0:6800/</code></pre>
<h3 id="1-3-配置Scrapy项目"><a href="#1-3-配置Scrapy项目" class="headerlink" title="1.3 配置Scrapy项目"></a>1.3 配置Scrapy项目</h3><p>配置scrapy项目文件夹下的scrapy.cfg文件</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>[deploy:target]</td>
<td>多目标deploy时使用target指定scrapyd服务</td>
<td></td>
</tr>
<tr>
<td>url</td>
<td>scrapy服务地址</td>
<td></td>
</tr>
<tr>
<td>project</td>
<td>scrapyd服务中的项目名称</td>
<td></td>
</tr>
</tbody></table>
<pre><code class="line-numbers language-bash">vim scrapy.cfg</code></pre>
<pre><code class="line-numbers language-json">[settings]
default = filespider.settings

[deploy:aliyun]
url = http://47.93.230.127:6800/
project = filespider</code></pre>
<p>扫描项目中的deploy配置信息</p>
<pre><code class="line-numbers language-bash">scrapyd-deploy -l
# aliyun               http://47.93.230.127:6800/</code></pre>
<h3 id="1-4-项目部署"><a href="#1-4-项目部署" class="headerlink" title="1.4 项目部署"></a>1.4 项目部署</h3><p>编译项目</p>
<pre><code class="line-numbers language-bash"># scrapyd-deploy &lt;target&gt; -p &lt;project&gt; --version &lt;version&gt;
scrapy</code></pre>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux使用Docker搭建FileBrowser主机文件浏览器</title>
    <url>/2020/Docker/Docker%E9%83%A8%E7%BD%B2FileBrowser/</url>
    <content><![CDATA[<p>预览Linux服务器上的音视频文件是一个很不容易的事情，在服务器上部署FileBrowser服务是一个解决问题的好方法</p>
<a id="more"></a>

<hr>
<p>docker获取FileBrowser镜像</p>
<pre><code class="line-numbers language-bash">docker pull filebrowser/filebrowser</code></pre>
<p>创建FileBrowser挂载所需要的目录</p>
<pre><code class="line-numbers language-bash">mkdir -p  /data/filebrowser
cd /data/filebrowser</code></pre>
<p>创建新的FileBrowser实例</p>
<pre><code class="line-numbers language-bash">docker run -d \
-v /:/srv  \
-v /data/filebrowser/filebrowserconfig.json:/etc/config.json  \
-v /data/filebrowser/database.db:/etc/database.db \
-p 80:80 --name filebrowser filebrowser/filebrowser</code></pre>
<blockquote>
<p>filebrowser默认的登陆用户为：admin，密码为：admin</p>
<p>通过浏览器访问服务器的<code>公网IP:端口</code>即可登陆File Browser服务，因为映射到了本地80所以不必指定端口</p>
<p>/srv为filebrowser admin用户登陆后的根目录，将外部的/挂载到/srv结果为登陆后默认显示服务器的<code>/</code></p>
</blockquote>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200828153104.png"></p>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linxu各种发行版本更换软件源的方法</title>
    <url>/2020/Linux/Linux%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%E6%9B%B4%E6%8D%A2%E8%BD%AF%E4%BB%B6%E6%BA%90%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>使用官方源会发生：安装速度慢、安装失败、包数量少等各种疑难杂症</p>
<ul>
<li>Ubuntu20</li>
<li>Centos7</li>
<li>Centos8</li>
</ul>
<a id="more"></a>

<hr>
<h2 id="Ubuntu20"><a href="#Ubuntu20" class="headerlink" title="Ubuntu20"></a>Ubuntu20</h2><p>备份现有源</p>
<pre><code class="line-numbers language-bash">sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak</code></pre>
<p>新建新的配置文件</p>
<pre><code class="line-numbers language-bash">sudo vim /etc/apt/sources.list</code></pre>
<p>添加源配置</p>
<pre><code class="line-numbers language-shell"># 阿里云源
deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</code></pre>
<p>更新</p>
<pre><code class="line-numbers language-bash">sudo apt update</code></pre>
<h2 id="Centos7"><a href="#Centos7" class="headerlink" title="Centos7"></a>Centos7</h2><p>备份现有配置文件</p>
<pre><code class="line-numbers language-bash">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</code></pre>
<p>下载新的CentOS-Base.repo 到/etc/yum.repos.d/</p>
<pre><code class="line-numbers language-bash">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo        # 阿里云
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo        # 或者网易</code></pre>
<p>生成缓存</p>
<pre><code class="line-numbers language-bash">yum makecache</code></pre>
<h2 id="Centos8"><a href="#Centos8" class="headerlink" title="Centos8"></a>Centos8</h2><p>其他与centos7相似，仅配置文件</p>
<pre><code class="line-numbers language-bash">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo</code></pre>
<p>对于非阿里云机器（如非aliyunECS），替换相关字段</p>
<pre><code class="line-numbers language-bash">sed -i -e &#39;/mirrors.cloud.aliyuncs.com/d&#39; -e &#39;/mirrors.aliyuncs.com/d&#39; /etc/yum.repos.d/CentOS-Base.repo</code></pre>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Python包管理器PIP配置使用</title>
    <url>/2020/Python/pip/</url>
    <content><![CDATA[<ul>
<li>pip的使用方法</li>
<li>pip常用命令</li>
<li>pip更换安装源的方法</li>
</ul>
<a id="more"></a>

<hr>
<h3 id="1-Pip包管理器"><a href="#1-Pip包管理器" class="headerlink" title="1. Pip包管理器"></a>1. Pip包管理器</h3><p>pip 是一个 Python 包安装与管理工具。</p>
<h4 id="1-1-使用方法"><a href="#1-1-使用方法" class="headerlink" title="1.1 使用方法"></a>1.1 使用方法</h4><p>从<span class="exturl" data-url="aHR0cHM6Ly9weXBpLm9yZy8=">PyPI<i class="fa fa-external-link-alt"></i></span>安装软件包：</p>
<pre><code class="line-numbers language-bash">$ pip install SomePackage
[...]
Successfully installed SomePackage</code></pre>
<p>安装已经从<span class="exturl" data-url="aHR0cHM6Ly9weXBpLm9yZy8=">PyPI<i class="fa fa-external-link-alt"></i></span>下载或从其他地方获得的软件包：</p>
<pre><code class="line-numbers language-bash">$ pip install SomePackage-1.0-py2.py3-none-any.whl
[...]
Successfully installed SomePackage</code></pre>
<p>显示安装了哪些文件：</p>
<pre><code class="line-numbers language-bash">$ pip show --files SomePackage
Name: SomePackage
Version: 1.0
Location: /my/env/lib/pythonx.x/site-packages
Files:
  ../somepackage/__init__.py
  [...]</code></pre>
<p>列出哪些软件包已过期：</p>
<pre><code class="line-numbers language-bash">$ pip list --outdated
SomePackage (Current: 1.0 Latest: 2.0)</code></pre>
<p>升级软件包：</p>
<pre><code class="line-numbers language-bash">$ pip install --upgrade SomePackage
[...]
Found existing installation: SomePackage 1.0
Uninstalling SomePackage:
  Successfully uninstalled SomePackage
Running setup.py install for SomePackage
Successfully installed SomePackage</code></pre>
<p>卸载软件包：</p>
<pre><code class="line-numbers language-bash">$ pip uninstall SomePackage
Uninstalling SomePackage:
  /my/env/lib/pythonx.x/site-packages/somepackage
Proceed (y/n)? y
Successfully uninstalled SomePackage</code></pre>
<h4 id="1-2-常用命令"><a href="#1-2-常用命令" class="headerlink" title="1.2 常用命令"></a>1.2 常用命令</h4><pre><code class="line-numbers language-bash">install                     # 下载并安装包
download                    # 下载包
uninstall                   # 移除包
freeze                      # 以需求格式输出已安装的包（默认：PackageName==version）
list                        # 已安装包列表
show                        # 显示已安装包的信息
check                       # 验证已安装的包具有兼容的依赖关系
config                      # 管理本地和全局配置
search                      # 在PyPI中搜索包
wheel                       # 根据您的需求构建轮子
hash                        # 计算包的散列值（HASH）
completion                  # A helper command used for command completion.
debug                       # 显示有用的调试信息
help                        # 显示帮助信息</code></pre>
<h4 id="1-3-更换安装源的方法"><a href="#1-3-更换安装源的方法" class="headerlink" title="1.3 更换安装源的方法"></a>1.3 更换安装源的方法</h4><p>pip是python的包管理器，但仓库服务器位于国外··，所以我们需要为pip配置国内的镜像仓库，国内镜像一般同步延迟在十分钟之内，没有太大问题。</p>
<p><strong>单次使用：</strong><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas</code>，这样就会从清华镜像安装pandas库。</p>
<p><strong>永久生效：</strong></p>
<pre><code class="line-numbers language-bash">pip config set global.index-url http://mirrors.aliyun.com/pypi/simple
pip config set install.trusted-host mirrors.aliyun.com        # 当使用http源时不添加信任容易error</code></pre>
<p><strong>常用镜像源</strong></p>
<table>
<thead>
<tr>
<th>镜像源名称</th>
<th>源地址</th>
</tr>
</thead>
<tbody><tr>
<td>清华源</td>
<td><span class="exturl" data-url="aHR0cHM6Ly9weXBpLnR1bmEudHNpbmdodWEuZWR1LmNuL3NpbXBsZQ==">https://pypi.tuna.tsinghua.edu.cn/simple<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>阿里源</td>
<td><span class="exturl" data-url="aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS9weXBpL3NpbXBsZQ==">http://mirrors.aliyun.com/pypi/simple<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>中科大源</td>
<td><span class="exturl" data-url="aHR0cDovL3B5cGkubWlycm9ycy51c3RjLmVkdS5jbi9zaW1wbGUv">http://pypi.mirrors.ustc.edu.cn/simple/<i class="fa fa-external-link-alt"></i></span></td>
</tr>
</tbody></table>
<h4 id="1-4-安装scrapy出现ERROR-Command-errored-out-with-exit-status-1-python-setup-py-egg-info-Check-the-logs-for-full-command-output-错误的解决办法"><a href="#1-4-安装scrapy出现ERROR-Command-errored-out-with-exit-status-1-python-setup-py-egg-info-Check-the-logs-for-full-command-output-错误的解决办法" class="headerlink" title="1.4 安装scrapy出现ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output.错误的解决办法"></a>1.4 安装scrapy出现ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output.错误的解决办法</h4><pre><code class="line-numbers language-bash">    distutils.errors.DistutilsError: Command &#39;[&#39;/usr/bin/python3&#39;, &#39;-m&#39;, &#39;pip&#39;, &#39;--disable-pip-version-check&#39;, &#39;wheel&#39;, &#39;--no-deps&#39;, &#39;-w&#39;, &#39;/tmp/tmpomo0h8v3&#39;, &#39;--quiet&#39;, &#39;--index-url&#39;, &#39;http://mirrors.cloud.aliyuncs.com/pypi/simple/&#39;, &#39;incremental&gt;=16.10.1&#39;]&#39; returned non-zero exit status 1.
    ----------------------------------------
ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output.</code></pre>
<p>解决办法</p>
<pre><code class="line-numbers language-bash">pip install incremental</code></pre>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据库·数据结构与使用命令</title>
    <url>/2020/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E7%AC%94%E8%AE%B0%C2%B7%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>redis是键值对数据库，它的键类型只能为字符串（string），但其值的类型却有5种：字符串string、哈希hash、列表list、集合set、有序集合zset。</p>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200913223017.png"></p>
<a id="more"></a>

<h2 id="键操作"><a href="#键操作" class="headerlink" title="键操作"></a>键操作</h2><pre><code>keys *            # 查询键列表，*为pattern
exists key        # 存在否
type key        # 查询类型
del key1 key2 ...    # 删除键
expire key seconds    # 设置过期时间
ttl key                # 查看有效时间</code></pre>
<h2 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h2><p>字符串类型是Redis中最为基础的数据存储类型，<strong>它在Redis中是二进制安全的</strong>，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。</p>
<pre><code class="line-numbers language-bash">set key value
mset key1 value1 key2 value2 ...    # 设置多个键值

setex key seconds value        # 设置键值及过期时间，以秒为单位
append key value            # 追加

get key
mget key1 key2 ...            # 获取多个

# 值长度
strlen key</code></pre>
<h2 id="HashMAP"><a href="#HashMAP" class="headerlink" title="HashMAP"></a>HashMAP</h2><p>可以将hash类型的key视为一个对象，其value就是对象的属性及其值的键值对。</p>
<pre><code class="line-numbers language-bash">hkeys key                        # 获取键的所有属性列表
hvals key                        # 获取所有属性值
hget key field                    # 获取属性值
hmget key field1 field2 ...        # 获取多个属性值
hdel key field1 field2 ...        # 删除属性
hmset key field1 value1 field2 value2 ...        # 设置值</code></pre>
<h2 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h2><p>列表的元素类型为string，按照插⼊顺序排序</p>
<pre><code class="line-numbers language-bash">lpush [···, ···, ···, ]    rpush        # 添加
lpop  [···, ···, ···, ]    rpop        # 删除
lpush key v1 v2 v3
lpop key</code></pre>
<pre><code class="line-numbers language-bash"># 返回列表⾥指定范围内的元素
lrange key start stop    

# 在指定元素的前或后插⼊新元素
linsert key before或after 现有元素 新元素    

# 设置指定索引位置的元素值
lset key index value

# 将列表中前count次出现的值为value的元素移除
# count &gt; 0: --&gt;
# count &lt; 0: &lt;--
# count = 0: 移除所有
lrem key count value</code></pre>
<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><p>⽆序、元素为string类型、元素具有唯⼀性，不重复、对于集合没有修改操作</p>
<pre><code class="line-numbers language-bash"># add
sadd key member1 member2 ...

# 返回all
smembers key

# 删除指定
srem key</code></pre>
<h2 id="Zset有序集合"><a href="#Zset有序集合" class="headerlink" title="Zset有序集合"></a>Zset有序集合</h2><ul>
<li>sorted set，有序集合</li>
<li>元素为string类型</li>
<li>元素具有唯⼀性，不重复</li>
<li>每个元素都会关联⼀个double类型的score，表示权重，通过权重将元素从⼩到⼤排序</li>
</ul>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200913231902.png" alt="img"></p>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200913232001.png" alt="img"></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Web前端代码自动补全插件Emmet</title>
    <url>/2020/%E9%9A%8F%E7%AC%94/Emmet%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E7%A5%9E%E5%99%A8/</url>
    <content><![CDATA[<p>Emmet是一款提升编写 HTML/CSS 代码效率的文本编辑器插件。</p>
<p>本文主要学习记录一下emmet的详细用法（仅html使用emmet，css缩写的语法请参考这里）</p>
<a id="more"></a>

<hr>
<h2 id="1-Emmet简述"><a href="#1-Emmet简述" class="headerlink" title="1. Emmet简述"></a>1. Emmet简述</h2><p>Emmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具. 在前端开发的过程中，一大部分的工作是写  HTML、CSS 代码。特别是手动编写 HTML 代码的时候，效率会特别低下，因为需要敲打很多尖括号，而且很多标签都需要闭合标签等。于是，就有了 Emmet，它可以极大的提高代码编写的效率，它提供了一种非常简练的语法规则，然后立刻生成对应的 HTML 结构或者 CSS  代码，同时还有多种实用的功能帮助进行前端开发，emmet语法基本规则如下:</p>
<pre><code>E 代表HTML标签。
E#id 代表id属性。
E.class 代表class属性。
E[attr=foo] 代表某一个特定属性。
E&#123;foo&#125; 代表标签包含的内容是foo。
E&gt;N 代表N是E的子元素。
E+N 代表N是E的同级元素。
E^N 代表N是E的上级元素。</code></pre>
<blockquote>
<ol>
<li>pycharm内置集成了emmet，使用方法为：输入完成后<kbd>return</kbd>会自动展开，如果输入完成后输入了<kbd>esc</kbd>的话，使用<kbd>tab</kbd>唤醒emmet</li>
<li>VsCode同样内置了emmet，使用方法与pycharm大同小异，但要注意：在VsCode新版本中按Tab不再默认启用Emmet展开缩写，需要在首选项配置中将emmet.triggerExpansionOnTab设置为true值!</li>
</ol>
</blockquote>
<hr>
<h2 id="2-基础用法"><a href="#2-基础用法" class="headerlink" title="2. 基础用法"></a>2. 基础用法</h2><p><strong>元素(Elements)</strong><br> 您可以使用元素的名称，如div或p来生成HTML标签。Emmet没有一组可用的标签名称，可以写任何单词并将其转换为标签。也就是只要知道元素的缩写,Emmet会自动转换成对应标签.<br> 形如:</p>
<pre><code>div =&gt; &lt;div&gt; &lt;/div&gt;
foo =&gt; &lt;foo&gt; &lt;/foo&gt;
html:5 =&gt; 将生成html5标准的包含body为空基本dom
html:xt =&gt; 生成XHTML过渡文档类型,DOCTYPE为XHTML
html:4s =&gt; 生成HTML4严格文档类型,DOCTYPE为HTML 4.01
a:mail          =&gt; &lt;a href=&quot;mailto:&quot;&gt;&lt;/a&gt;
a:link          =&gt; &lt;a href=&quot;http://&quot;&gt;&lt;/a&gt;
base            =&gt; &lt;base href=&quot;&quot;&gt;
br              =&gt; &lt;br&gt;
link            =&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;
script:src      =&gt; &lt;script src=&quot;&quot;&gt;&lt;/script&gt;
form:get        =&gt; &lt;form action=&quot;&quot; method=&quot;get&quot;&gt;&lt;/form&gt;
label           =&gt; &lt;label for=&quot;&quot;&gt;&lt;/label&gt;
input           =&gt; &lt;input type=&quot;text&quot;&gt;
inp             =&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot;&gt;
input:hidden    =&gt; &lt;input type=&quot;hidden&quot; name=&quot;&quot;&gt; input:h亦可
input:email     =&gt; &lt;input type=&quot;email&quot; name=&quot;&quot; id=&quot;&quot;&gt;
input:password  =&gt; &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;&quot;&gt;
input:checkbox  =&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot;&gt;
input:radio     =&gt; &lt;input type=&quot;radio&quot; name=&quot;&quot; id=&quot;&quot;&gt;
select          =&gt; &lt;select name=&quot;&quot; id=&quot;&quot;&gt;&lt;/select&gt;
option          =&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt;
bq              =&gt; &lt;blockquote&gt;&lt;/blockquote&gt;
btn             =&gt; &lt;button&gt;&lt;/button&gt;
btn:s           =&gt; &lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;
btn:r           =&gt; &lt;button type=&quot;reset&quot;&gt;&lt;/button&gt;</code></pre>
<p><strong>文本操作符(Text)</strong><br> 如果想在生成元素的同时添加文本内容可以使用{}</p>
<pre><code>div&#123;这是一段文本&#125;
&lt;div&gt;这是一段文本&lt;/div&gt;
a&#123;点我点我&#125;
&lt;a href=&quot;&quot;&gt;点我点我&lt;/a&gt;  </code></pre>
<p><strong>属性操作符(Attribute operators)</strong><br> 属性运算符用于修改输出元素的属性.</p>
<ul>
<li>Id和Class   (elem#id and elem.class )</li>
</ul>
<pre><code>div.test  =&gt; &lt;div class=&quot;test&quot;&gt;&lt;/div&gt;
div#pageId =&gt; &lt;div id=&quot;pageId&quot;&gt;&lt;/div&gt;</code></pre>
<p>隐式标签则会自动联想生成对应元素,根据配置规则不同生成的结果也是不同的.</p>
<pre><code>.class
=&gt;
&lt;div class&gt;&lt;/div&gt;
em&gt;.class
=&gt;
&lt;em&gt;&lt;span class&gt;&lt;/span&gt;&lt;/em&gt;
table&gt;.row&gt;.col
=&gt;
&lt;table&gt;
    &lt;tr class=&quot;row&quot;&gt;
        &lt;td class=&quot;col&quot;&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;</code></pre>
<p>绑定多个类名用.符号连续起来即可</p>
<pre><code>div.test1.test2.test3
=&gt;
&lt;div class=&quot;test1 test2 test3&quot;&gt;&lt;/div&gt;</code></pre>
<ul>
<li>自定义属性使用 [attr1=’’ attr2=’’]</li>
</ul>
<pre><code>a[href=&#39;#&#39; data-title=&#39;customer&#39; target=&#39;_blank&#39;]
=&gt;
&lt;a href=&quot;#&quot; data-title=&quot;customer&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;</code></pre>
<p><strong>嵌套操作符(Nesting operators)</strong><br> 嵌套操作符用于将缩写元素放置在生成的树中,是否应放置在上下文元素的内部或附近.</p>
<ul>
<li><p>子级:&gt;</p>
<p>通过&gt;标识元素可以生成嵌套子级元素,可以配合元素属性进行连写</p>
<pre><code>div#pageId&gt;ul&gt;li 
=&gt; 
&lt;div id=&quot;pageId&quot;&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;</code></pre>
</li>
<li><p>同级:+</p>
<p>+字符表示生成兄弟级元素.</p>
<pre><code>div#pageId+div.child
=&gt;
&lt;div id=&quot;pageId&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</code></pre>
</li>
<li><p>父级:^</p>
<p>用于生成父级元素的同级元素,从这个</p>
<p>字符所在位置开始,查找左侧最近的元素的父级元素并生成其兄弟级元素.</p>
<pre><code>div&gt;p.parent&gt;span.child^ul.brother&gt;li
=&gt;
&lt;div&gt;
    &lt;p class=&quot;parent&quot;&gt;&lt;span class=&quot;child&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;ul class=&quot;brother&quot;&gt;
        &lt;li&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;</code></pre>
</li>
</ul>
<p><strong>分组操作符(Grouping)</strong><br> 分组使用()来实现缩写的分离.比如这个例子,如果不加括号那么a将作为span的子级元素生成.加上括号a将于()内的元素同级.</p>
<pre><code>div&gt;(ul&gt;li+span)&gt;a
=&gt;
&lt;div&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;span&gt;&lt;/span&gt;
    &lt;/ul&gt;
    &lt;a href=&quot;&quot;&gt;&lt;/a&gt;
&lt;/div&gt;</code></pre>
<p><strong>乘法(Multiplication)</strong><br> 使用<em>N即可自动生成重复项.N是一个正整数.在使用时请注意</em>N所在位置,位置不同生成的结果不同.</p>
<pre><code>ul&gt;li*3
=&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p><strong>自动计数(numbering)</strong><br> 这个功能挺方便的对于生成重复项时增加一个序号,只需要加上$符号即可.</p>
<pre><code>ul&gt;li.item$&#123;item number:$&#125;*3
&lt;ul&gt;
    &lt;li class=&quot;item1&quot;&gt;item number:1&lt;/li&gt;
    &lt;li class=&quot;item2&quot;&gt;item number:2&lt;/li&gt;
    &lt;li class=&quot;item3&quot;&gt;item number:3&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p>如果生成两位数则使用两个连续的$$,更多位数以此类推…<br> 使用@修饰符，可以更改编号方向（升序或降序）和基数（例如起始值）.注意这个操作符在$之后添加<br> @-表示降序,@+表示升序,默认使用升序.<br> @N可以改变起始值.需要注意的是如果配合升降序使用的话N是放到+-符后.</p>
<pre><code>ul&gt;li.item$@-*3
=&gt;
&lt;ul&gt;
    &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
---------------------------
ul&gt;li.item$@-10*3
=&gt;
&lt;ul&gt;
    &lt;li class=&quot;item12&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;item11&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;item10&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p>上述的操作是可以搭配使用进而得出酷炫的效果,使用时请注意空格的问题,缩写代码不要有空格否则是不会进行转换的.<br> 另外如果你的编辑器中已经有了一些html智能提示代码段,比如我的VsCode还装了HTML Snippets插件,这个与Emmet语法有部分冲突,使用Tab键时会优先使用插件的代码提示,建议禁用.<br> 组合起来看看效果:</p>
<pre><code>table.table-row[role=&#39;table&#39;]&gt;(thead&gt;tr&gt;td&#123;item $@120&#125;*5)+(tbody&gt;tr&gt;(td.item$$@-)lorem10*5)</code></pre>
<p>这段目的在于生成一个类名为table-row,且自定义了属性role的table标签,内部包含了thead与tbody,分别生成5个td.<br> thead中td的内容是item加上自增序号,自增序号基数从120开始.<br> tbody中td拥有一个名为item加降序自增符号类名,且每个td内容随机填充10个单词.</p>
<pre><code>&lt;table class=&quot;table-row&quot; role=&quot;table&quot;&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td&gt;item 120&lt;/td&gt;
            &lt;td&gt;item 121&lt;/td&gt;
            &lt;td&gt;item 122&lt;/td&gt;
            &lt;td&gt;item 123&lt;/td&gt;
            &lt;td&gt;item 124&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;
                &lt;td class=&quot;item05&quot;&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Odit, assumenda.&lt;/td&gt;
            &lt;/td&gt;
            &lt;td&gt;
                &lt;td class=&quot;item04&quot;&gt;Magnam possimus molestias ipsum animi rem placeat, ut obcaecati laudantium.&lt;/td&gt;
            &lt;/td&gt;
            &lt;td&gt;
                &lt;td class=&quot;item03&quot;&gt;Consequuntur, labore ad optio cupiditate iusto dolores fugit quidem officiis.&lt;/td&gt;
            &lt;/td&gt;
            &lt;td&gt;
                &lt;td class=&quot;item02&quot;&gt;Veniam, explicabo consequuntur blanditiis at dicta fuga ratione eos beatae.&lt;/td&gt;
            &lt;/td&gt;
            &lt;td&gt;
                &lt;td class=&quot;item01&quot;&gt;Fuga voluptatum illo quis ducimus ad eveniet non. Saepe, eveniet.&lt;/td&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;</code></pre>
<p>再来个配合嵌套元素和计数的大栗子.</p>
<pre><code>div.nav&gt;(nav#navbar&gt;(ul&gt;li&gt;(a[href=&quot;/xxx/product/$&quot; data-index=$]&gt;lorem4)*5))+div.btn[type=&#39;button&#39;]&gt;span&#123;--&#125;^^div#main</code></pre>
<p>这个有点复杂,看下效果:</p>
<pre><code>&lt;div class=&quot;nav&quot;&gt;
    &lt;nav id=&quot;navbar&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;
                &lt;a href=&quot;/xxx/product/1&quot; data-index=&quot;1&quot;&gt;Lorem ipsum dolor sit.&lt;/a&gt;
                &lt;a href=&quot;/xxx/product/2&quot; data-index=&quot;2&quot;&gt;Dolor vel, quia quas.&lt;/a&gt;
                &lt;a href=&quot;/xxx/product/3&quot; data-index=&quot;3&quot;&gt;Qui hic, corrupti eum!&lt;/a&gt;
                &lt;a href=&quot;/xxx/product/4&quot; data-index=&quot;4&quot;&gt;Necessitatibus perspiciatis, corrupti. Praesentium!&lt;/a&gt;
                &lt;a href=&quot;/xxx/product/5&quot; data-index=&quot;5&quot;&gt;Nostrum quos, voluptate. Velit!&lt;/a&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/nav&gt;
    &lt;div class=&quot;btn&quot; type=&quot;button&quot;&gt;&lt;span&gt;--&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;main&quot;&gt;&lt;/div&gt;</code></pre>
<h2 id="3-进阶高级用法"><a href="#3-进阶高级用法" class="headerlink" title="3. 进阶高级用法"></a>3. 进阶高级用法</h2><p><strong>模拟文本/随机文本</strong><br> 在开发时经常要填充一些文本内容占位,Emmet内置了Lorem Ipsum功能来实现.loremN或者lipsumN,N表示生成的单词数,正整数.可以不填.</p>
<pre><code>lorem
=&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Suscipit quia commodi vero sint omnis fugiat excepturi reiciendis necessitatibus totam asperiores, delectus saepe nulla consequuntur nostrum! Saepe suscipit recusandae repellendus assumenda.

p&gt;lorem4
=&gt;
&lt;p&gt;Lorem ipsum dolor sit.&lt;/p&gt;

(p&gt;lorem4)*3
=&gt;
&lt;p&gt;Lorem ipsum dolor sit.&lt;/p&gt;
&lt;p&gt;Labore aperiam, consequuntur architecto.&lt;/p&gt;
&lt;p&gt;Quidem nisi, cum odio!&lt;/p&gt;</code></pre>
<p><strong>包装文本</strong><br> 听起来可能有点绕,通俗点解释就是把一段指定的文本包装成我们想要的结构.注意这个功能需要编辑器的支持,举个大栗子:<br> 比如PM给了这样一段文本</p>
<pre><code>首页
产品介绍
相关案例
关于我们
联系我们
而我们预期的效果是这样
&lt;nav&gt;
    &lt;ul&gt;
        &lt;li&gt;首页&lt;/li&gt;
        &lt;li&gt;产品介绍&lt;/li&gt;
        &lt;li&gt;相关案例&lt;/li&gt;
        &lt;li&gt;关于我们&lt;/li&gt;
        &lt;li&gt;联系我们&lt;/li&gt;
    &lt;/ul&gt;
&lt;/nav&gt;</code></pre>
<ol>
<li>选中文本,按下<code>ctrl+shift+p</code>打开命令窗口输入ewrap</li>
<li>选择<code>Emmet:使用缩写进行包装(Wrap with Abbreviation)</code>选项<br> <img src="https://images2015.cnblogs.com/blog/648483/201706/648483-20170605122055715-1250857112.png" alt="img"></li>
<li>输入缩写字符<code>nav&gt;ul&gt;li*</code>按下回车键即可看到效果.<br> 当然也可以在菜单=&gt;编辑=&gt;Emmet(M)..然后输入.</li>
</ol>
<blockquote>
<p>这里需要的注意的地方是输入的缩写代码中*所在位置不同得到的效果也是不同的.</p>
</blockquote>
<p>另外如果给的文本带有序号的情况,我们也是可以通过缩写来处理,而不是手动删除,主要用的是<code>|t</code>来处理.<br> 比如:</p>
<pre><code>    1.首页
    2.产品介绍
    3.相关案例
    4.关于我们
    5.联系我们
    输入包装字符命令
    nav&gt;ul&gt;li*|t
    即可看到生成的html中自动去掉了序号</code></pre>
<p>针对上边说的几种情况来演示一下.<br> <img src="https://images2015.cnblogs.com/blog/648483/201706/648483-20170605122015012-1752202759.gif" alt="img"></p>
]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux配置ZSH终端环境</title>
    <url>/2020/Linux/Linux%E9%85%8D%E7%BD%AEZSH%E7%BB%88%E7%AB%AF%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>ZSH是mac的默认终端，相当于Linux发行版的bash，本文主要记录了Linux中zsh+onmyzsh的配置方法及优化过程，zsh优点：</p>
<p>1.完全兼容bash,之前bash下的使用习惯,shell脚本都可以完全兼容。 </p>
<p>2.更强大的tab补全,当你切换目录敲两下tab,他可以列出当前目录下面的所有目录,…</p>
<p>3.更智能的切换目录,比如你要进入一个很深的目录，zsh会帮助你完成路径的补全</p>
<p>4.命令选项补齐,比如输入yum,然后按tab,即可显示出yum都有哪些命令选项。 </p>
<p>5.命令参数补齐,比如要kill一个进程,直接输入kill 进程名,会自动显示出进程的pid</p>
<p>···</p>
<a id="more"></a>

<hr>
<h2 id="1-ZSH的安装"><a href="#1-ZSH的安装" class="headerlink" title="1. ZSH的安装"></a>1. ZSH的安装</h2><h3 id="1-1-安装zsh"><a href="#1-1-安装zsh" class="headerlink" title="1.1 安装zsh"></a>1.1 安装zsh</h3><p>如果你用 Redhat Linux，执行：sudo yum install zsh<br>如果你用 Ubuntu Linux，执行：sudo apt-get install zsh</p>
<p>查看系统中的shell版本</p>
<pre><code class="line-numbers language-bash">cat /etc/shells        </code></pre>
<p>切换系统默认shell为zsh</p>
<pre><code class="line-numbers language-bash">chsh -s /bin/zsh    </code></pre>
<h3 id="1-2-安装-ohmyzsh"><a href="#1-2-安装-ohmyzsh" class="headerlink" title="1.2 安装 ohmyzsh"></a>1.2 安装 ohmyzsh</h3><p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200901232057.png"></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29obXl6c2gvb2hteXpzaC9uZXR3b3Jr">ohmyzsh的GitHub项目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>自动安装：</p>
<pre><code class="line-numbers language-bash">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code></pre>
<p>手动安装：</p>
<pre><code class="line-numbers language-bash">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 
cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></pre>
<p>或者前两种方式都不合适，可以尝试此种：</p>
<pre><code class="line-numbers language-tex">1. 到项目仓库下载zip包
2. 安装unzip
3. unzip master.zip
4. cd cd ./ohmyzsh-master/tools/ &amp;&amp; sh install.sh</code></pre>
<p>都不复杂，安装完成之后退出当前会话重新打开一个终端窗口，你就可以见到彩色的提示了</p>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200901210857.png"></p>
<hr>
<h2 id="2-ZSH的优化"><a href="#2-ZSH的优化" class="headerlink" title="2. ZSH的优化"></a>2. ZSH的优化</h2><p>zsh 的配置在<code>~/.zshrc</code>文件</p>
<h3 id="2-1-配置主题"><a href="#2-1-配置主题" class="headerlink" title="2.1 配置主题"></a>2.1 配置主题</h3><p><strong>ohmyzsh默认主题为robbyrussell，更换为agnoster</strong></p>
<p>由于<code>oh my zsh</code>会经常更新，为了防止ohmyzsh更新个人配置被覆盖，将本地的主题文件复制出一份</p>
<pre><code class="line-numbers language-bash">cp ~/.oh-my-zsh/themes/agnoster.zsh-theme ~/.oh-my-zsh/themes/agnoster-my.zsh-theme</code></pre>
<pre><code class="line-numbers language-bash">vim ~/.zshrc</code></pre>
<pre><code class="line-numbers language-bash">ZSH_THEME=&quot;agnoster-my&quot;</code></pre>
<pre><code class="line-numbers language-bash">source .zshrc</code></pre>
<h3 id="2-2-zsh隐藏终端用户名和计算机名"><a href="#2-2-zsh隐藏终端用户名和计算机名" class="headerlink" title="2.2 zsh隐藏终端用户名和计算机名"></a>2.2 zsh隐藏终端用户名和计算机名</h3><p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200901215129.png"></p>
<p>修改主题文件</p>
<pre><code class="line-numbers language-bash">vim ~/.oh-my-zsh/themes/agnoster-my.zsh-theme</code></pre>
<p>注释末尾配置</p>
<pre><code class="line-numbers language-shell"># Main prompt
build_prompt() &#123;
  RETVAL=$?
  prompt_status
  prompt_virtualenv
 # prompt_context
  prompt_dir
  prompt_git
  prompt_hg
  prompt_end
&#125;</code></pre>
<p>修改<code>~/.zshrc</code></p>
<pre><code class="line-numbers language-bash">ZSH_THEME=&quot;agnoster-my&quot;</code></pre>
<p>立即生效环境变量</p>
<pre><code class="line-numbers language-bash">source ~/.zshrc</code></pre>
<h2 id="3-插件"><a href="#3-插件" class="headerlink" title="3. 插件"></a>3. 插件</h2><p>插件放置文件夹：<code>$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins</code></p>
<p>插件启用：<code>~/.zshrc</code>的</p>
<pre><code class="line-numbers language-bash"># plugins
plugins=(
  zsh-history-substring-search
  sudo
  git
)</code></pre>
<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>自带插件。按两下 <code>ESC</code> 键，自动为命令前加上 sudo。</p>
<h3 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h3><p>这个插件会根据历史输入指令的记录即时的提示</p>
<pre><code class="line-numbers language-bash">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</code></pre>
<h3 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h3><p>这是一个命令高亮插件，输入为绿色时表示正确的命令，路径带有下划线时表示可用路径</p>
<pre><code class="line-numbers language-bash">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git \
$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</code></pre>
<h3 id="git-open"><a href="#git-open" class="headerlink" title="git-open"></a>git-open</h3><p>在git目录打开相应的github页面</p>
<pre><code class="line-numbers language-bash">git clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-open  </code></pre>
<h3 id="thefuck"><a href="#thefuck" class="headerlink" title="thefuck"></a>thefuck</h3><p>输入 fuck 纠正前一条输错的命令, 需要先下载</p>
<pre><code class="line-numbers language-bash">sudo apt install thefuck</code></pre>
<h3 id="history-substring-search"><a href="#history-substring-search" class="headerlink" title="history-substring-search"></a>history-substring-search</h3><p>强大的历史命令搜索插件</p>
<pre><code class="line-numbers language-bash">git clone https://github.com/zsh-users/zsh-history-substring-search \
$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-history-substring-search</code></pre>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Awk文本分析命令的使用</title>
    <url>/2020/Linux/awk%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。</p>
<p>之所以叫 AWK 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。</p>
<pre><code class="line-numbers language-bash">awk &#39;&#123;foo argv1,argv2,···&#125;&#39; filename</code></pre>
<a id="more"></a>

<h2 id="什么是awk"><a href="#什么是awk" class="headerlink" title="什么是awk"></a>什么是awk</h2><pre><code class="line-numbers language-bash">awk &#39;&#123;print $0&#125;&#39; /etc/passwd</code></pre>
<pre><code class="line-numbers language-bash">root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
···</code></pre>
<p>调用 awk时，我们指定/etc/passwd 作为输入文件。执行 awk 时，它依次对/etc/passwd 中的每一行执行 print 命令，所有输出都发送到 stdout，所得到的结果与执行 cat /etc/passwd 完全相同。<br>现在，解释{ print }代码块。在 awk 中，花括号用于将几块代码组合到一起，这一点类似于 C 语言。在代码块中只有一条 print 命令。在 awk 中，如果只出现 print 命令，那么将打印当前行的全部内容。</p>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200909221217.jpg"></p>
<pre><code>文本中每个被记录分隔符（默认为换行符）为一个记录
记录中每个被字段分隔符（默认为空白字符）分割的为一个字段，-F&quot;:&quot;，将冒号指定为字段分隔符
</code></pre>
<h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><h4 id="输出指定字段"><a href="#输出指定字段" class="headerlink" title="输出指定字段"></a>输出指定字段</h4><pre><code class="line-numbers language-bash">awk -F&quot;:&quot; &#39;&#123; print $1 $3 &#125;&#39; /etc/passwd</code></pre>
<pre><code>root0
daemon1
bin2
sys3
sync4
games5</code></pre>
<pre><code class="line-numbers language-bash">awk -F&quot;:&quot; &#39;&#123; print $1,$3 &#125;&#39; /etc/passwd</code></pre>
<pre><code>root 0
daemon 1
bin 2
sys 3
sync 4
games 5</code></pre>
<h4 id="格式化输出指定字段"><a href="#格式化输出指定字段" class="headerlink" title="格式化输出指定字段"></a>格式化输出指定字段</h4><pre><code class="line-numbers language-bash">awk [参数] &#123; 函数 函数参数,[变量前缀]变量1,[变量前缀]变量2,··· &#125; 文件</code></pre>
<pre><code class="line-numbers language-bash">awk -F&quot;:&quot; &#39;&#123; printf &quot;%-30s %-10s\n&quot;,&quot;username: &quot;$1,&quot;uid: &quot;$3 &#125;&#39; /etc/passwd</code></pre>
<pre><code>username: root                 uid: 0
username: daemon               uid: 1
username: bin                  uid: 2
username: sys                  uid: 3
username: sync                 uid: 4
username: games                uid: 5</code></pre>
<h4 id="统计账户人数"><a href="#统计账户人数" class="headerlink" title="统计账户人数"></a>统计账户人数</h4><pre><code></code></pre>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客使用经验</title>
    <url>/2020/%E9%9A%8F%E7%AC%94/Hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>Hexo使用过程中的一些经验</p>
<a id="more"></a>

<hr>
<h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><h3 id="博客生成"><a href="#博客生成" class="headerlink" title="博客生成"></a>博客生成</h3><blockquote>
<p>Hexo GitHub项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhv">https://github.com/hexojs/hexo<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>安装Hexo</p>
<pre><code class="line-numbers language-bash">$ npm install hexo-cli -g</code></pre>
<p>创建博客</p>
<pre><code class="line-numbers language-bash">$ hexo init blog
$ cd blog</code></pre>
<p>博客使用</p>
<pre><code class="line-numbers language-bash">$ hexo clean         # 清理缓存（public文件夹）
$ hexo generate      # 生成博客静态文件
$ hexo server        # 开启调试本地服务器</code></pre>
<h3 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h3><p>安装Next 5：</p>
<pre><code class="line-numbers language-bash">$ cd hexo-blog
$ git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre>
<p>安装Next 6&amp;7：</p>
<pre><code class="line-numbers language-bash">$ cd hexo-blog
$ git clone https://github.com/theme-next/hexo-theme-next themes/next</code></pre>
<h2 id="博客优化"><a href="#博客优化" class="headerlink" title="博客优化"></a>博客优化</h2><h3 id="1-常规配置"><a href="#1-常规配置" class="headerlink" title="1. 常规配置"></a>1. 常规配置</h3><h4 id="1-1-prism代码高亮"><a href="#1-1-prism代码高亮" class="headerlink" title="1.1 prism代码高亮"></a>1.1 prism代码高亮</h4><p>hexo自带highlight、primsjs代码高亮插件</p>
<h3 id="2-网页样式修改"><a href="#2-网页样式修改" class="headerlink" title="2. 网页样式修改"></a>2. 网页样式修改</h3><p>next主题配置文件<code>blog/themes/next/ _config.yml</code>，取消行注释</p>
<pre><code class="line-numbers language-yml">custom_file_path:
  ···
  style: source/_data/styles.styl</code></pre>
<p>新建文件夹及文件：<code>blog/source/_data/styles.styl</code></p>
<h4 id="2-1-添加网页背景图片"><a href="#2-1-添加网页背景图片" class="headerlink" title="2.1 添加网页背景图片"></a>2.1 添加网页背景图片</h4><pre><code class="line-numbers language-css">body &#123;
    background:url(/assets/background.jpg);        // 背景图片位置
    background-repeat: no-repeat;        // 若果背景图片不能全屏，那么是否平铺显示，充满屏幕
    background-attachment: fixed;        // 背景是否随着网页上下滚动而滚动，fixed为固定
    background-position:50% 50%;        // 位置
    opacity: 0.9;
    background-size:cover;
&#125;</code></pre>
<h4 id="2-2-博客网页宽度自适应"><a href="#2-2-博客网页宽度自适应" class="headerlink" title="2.2 博客网页宽度自适应"></a>2.2 博客网页宽度自适应</h4><p>调整<code>line1、3</code>的百分数值可以调整网页宽度</p>
<pre><code class="line-numbers language-css">header&#123; width: 80% !important; &#125;
header.post-header &#123;
  width: auto !important;
&#125;
.container .main-inner &#123; width: 80%; &#125;
.content-wrap &#123; width: calc(100% - 260px); &#125;

.header &#123;
  +tablet() &#123;
    width: auto !important;
  &#125;
  +mobile() &#123;
    width: auto !important;
  &#125;
&#125;

.container .main-inner &#123;
  +tablet() &#123;
    width: auto !important;
  &#125;
  +mobile() &#123;
    width: auto !important;
  &#125;
&#125;

.content-wrap &#123;
  +tablet() &#123;
    width: 100% !important;
  &#125;
  +mobile() &#123;
    width: 100% !important;
  &#125;
&#125;</code></pre>
<h4 id="2-3-文章标题样式"><a href="#2-3-文章标题样式" class="headerlink" title="2.3 文章标题样式"></a>2.3 文章标题样式</h4><p>CSS样式测试网址：<span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL3RpeS90LmFzcA==">https://www.w3school.com.cn/tiy/t.asp<i class="fa fa-external-link-alt"></i></span></p>
<p>蓝色样式</p>
<pre><code class="line-numbers language-css">.post-body &#123;
  .h1, h2, h3, h4, h5, h6 &#123;
    background: #2B6695;
    border-radius: 6px 6px 6px 6px;
    box-shadow: 0 0 0 1px #5F5A4B, 1px 1px 6px 1px rgba(10, 10, 0, 0.5);
    color: #FFFFFF;
    font-family: &quot;微软雅黑&quot; , &quot;宋体&quot; , &quot;黑体&quot; ,Arial;
    font-weight: bold;
    height: 25px;
    line-height: 22px;
    margin: 15px 0 !important;
    padding: 5px 0px 5px 20px;
    text-shadow: 2px 2px 3px #222222;
    &#125;
  &#125;</code></pre>
<p>透明样式</p>
<pre><code class="line-numbers language-css">.post-body &#123;
  .h1, h2, h3, h4, h5, h6 &#123;
    border-left: 5px solid #21759b;
    border-right: 5px solid #21759b;
    background: transparent url(https://images.cnblogs.com/cnblogs_com/Renyi-Fan/1188097/o_33.png) repeat scroll 0% 0%;
    /* background: linear-gradient(-30deg, rgb(241, 226, 198), rgb(242, 226, 198) 30%, rgb(243, 227, 198) 60%, rgb(244, 230, 189) 100%); */
    border-radius: 6px 6px 6px 6px !important;
    font-size: 16px;
    font-weight: bold;
    padding: 5px 0 3px 15px;
    box-shadow: 0 0 0 1px #5F5A4B, 0px 0px 6px 0px rgba(10, 10, 0, 0.5);
    color: #FF0000 !important;
    box-shadow: 0 0 8px #aaa;
    &#125;
  &#125;</code></pre>
<h3 id="3-扩展功能（extension）"><a href="#3-扩展功能（extension）" class="headerlink" title="3. 扩展功能（extension）"></a>3. 扩展功能（extension）</h3><h4 id="3-1-本地搜索"><a href="#3-1-本地搜索" class="headerlink" title="3.1 本地搜索"></a>3.1 本地搜索</h4><p>安装包</p>
<pre><code class="line-numbers language-bash">$ cd blog
$ npm install hexo-generator-searchdb </code></pre>
<p>Hexo站点配置文件</p>
<pre><code class="line-numbers language-yaml">search:
  path: search.xml
  field: post
  format: html
  limit: 10000</code></pre>
<p>Next主题配置文件</p>
<pre><code class="line-numbers language-yaml"># Local Search
# Dependencies: https://github.com/theme-next/hexo-generator-searchdb
local_search:
  enable: true</code></pre>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>常用快捷键笔记</title>
    <url>/2020/%E9%9A%8F%E7%AC%94/%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<ul>
<li>Pycharm（jetbrains家族）</li>
<li>浏览器（文件管理器部分适用）</li>
<li>Terminal（命令行）</li>
<li>VS code</li>
</ul>
<a id="more"></a>

<hr>
<h3 id="Pycharm"><a href="#Pycharm" class="headerlink" title="Pycharm"></a>Pycharm</h3><h4 id="常用快捷"><a href="#常用快捷" class="headerlink" title="常用快捷"></a>常用快捷</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + Q</td>
<td>快速查看文档</td>
</tr>
<tr>
<td>Ctrl + F1</td>
<td>显示错误描述或警告信息</td>
</tr>
<tr>
<td>Ctrl + /</td>
<td>行注释（可选中多行）</td>
</tr>
<tr>
<td>Ctrl + Alt + L</td>
<td>代码格式化</td>
</tr>
<tr>
<td>Ctrl + Alt + O</td>
<td>自动导入</td>
</tr>
<tr>
<td>Ctrl + Alt + I</td>
<td>自动缩进</td>
</tr>
<tr>
<td>Tab / Shift + Tab</td>
<td>缩进、不缩进当前行（可选中多行）</td>
</tr>
<tr>
<td>Ctrl+C/Ctrl+Insert</td>
<td>复制当前行或选定的代码块到剪贴板</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>复制选定的区域</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>删除当前行</td>
</tr>
<tr>
<td>Shift + Enter</td>
<td>换行（不用鼠标操作了）</td>
</tr>
<tr>
<td>Ctrl +Ｊ</td>
<td>插入模版</td>
</tr>
<tr>
<td>Ctrl + Shift +/-</td>
<td>展开/折叠全部代码块</td>
</tr>
<tr>
<td>Ctrl + Numpad+</td>
<td>全部展开</td>
</tr>
<tr>
<td>Ctrl + Numpad-</td>
<td>全部折叠</td>
</tr>
<tr>
<td>Ctrl + Delete</td>
<td>删除到字符结束</td>
</tr>
<tr>
<td>Ctrl + Backspace</td>
<td>删除到字符开始</td>
</tr>
<tr>
<td>Ctrl + Shift + F7</td>
<td>将当前单词在整个文件中高亮，F3移动到下一个，ESC取消高亮。</td>
</tr>
<tr>
<td>Alt + up/down</td>
<td>方法上移或下移动</td>
</tr>
<tr>
<td>Alt + Shift + up/down</td>
<td>当前行上移或下移动</td>
</tr>
<tr>
<td>Ctrl + B/鼠标左键</td>
<td>转到方法定义处</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>选中增加的代码块</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>方法或变量重命名</td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>最近访问的文件</td>
</tr>
<tr>
<td>Esc</td>
<td>从其他窗口回到编辑窗口</td>
</tr>
<tr>
<td>Shift + Esc</td>
<td>隐藏当前窗口，焦点到编辑窗口</td>
</tr>
<tr>
<td>F12</td>
<td>回到先前的工具窗口</td>
</tr>
<tr>
<td>Ctrl + Shift + up</td>
<td>快速上移某一行</td>
</tr>
<tr>
<td>Ctrl + Shift + down</td>
<td>快速下移某一行</td>
</tr>
<tr>
<td>ctrl+alt+左箭头</td>
<td>返回上一个光标的位置（CTRL进入函数后返回）</td>
</tr>
<tr>
<td>ctrl+alt+右箭头</td>
<td>前进到后一个光标的位置</td>
</tr>
</tbody></table>
<h4 id="全部快捷键"><a href="#全部快捷键" class="headerlink" title="全部快捷键"></a>全部快捷键</h4><h5 id="1、编辑（Editing）"><a href="#1、编辑（Editing）" class="headerlink" title="1、编辑（Editing）"></a>1、编辑（Editing）</h5><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + Space</td>
<td>基本的代码完成（类、方法、属性）</td>
</tr>
<tr>
<td>Ctrl + Alt + Space</td>
<td>快速导入任意类</td>
</tr>
<tr>
<td>Ctrl + Shift + Enter</td>
<td>语句完成</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>参数信息（在方法中调用参数）</td>
</tr>
<tr>
<td>Ctrl + Q</td>
<td>快速查看文档</td>
</tr>
<tr>
<td>Shift + F1</td>
<td>外部文档</td>
</tr>
<tr>
<td>Ctrl + 鼠标</td>
<td>简介</td>
</tr>
<tr>
<td>Ctrl + F1</td>
<td>显示错误描述或警告信息</td>
</tr>
<tr>
<td>Alt + Insert</td>
<td>自动生成代码</td>
</tr>
<tr>
<td>Ctrl + O</td>
<td>重新方法</td>
</tr>
<tr>
<td>Ctrl + Alt + T</td>
<td>选中</td>
</tr>
<tr>
<td>Ctrl + /</td>
<td>行注释</td>
</tr>
<tr>
<td>Ctrl + Shift + /</td>
<td>块注释</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>选中增加的代码块</td>
</tr>
<tr>
<td>Ctrl + Shift + W</td>
<td>回到之前状态</td>
</tr>
<tr>
<td>Ctrl + Shift + ]/[</td>
<td>选定代码块结束、开始</td>
</tr>
<tr>
<td>Alt + Enter</td>
<td>快速修正</td>
</tr>
<tr>
<td>Ctrl + Alt + L</td>
<td>代码格式化</td>
</tr>
<tr>
<td>Ctrl + Alt + O</td>
<td>自动导入</td>
</tr>
<tr>
<td>Ctrl + Alt + I</td>
<td>自动缩进</td>
</tr>
<tr>
<td>Tab / Shift + Tab</td>
<td>缩进、不缩进当前行</td>
</tr>
<tr>
<td>Ctrl+X/Shift+Delete</td>
<td>剪切当前行或选定的代码块到剪贴板</td>
</tr>
<tr>
<td>Ctrl+C/Ctrl+Insert</td>
<td>复制当前行或选定的代码块到剪贴板</td>
</tr>
<tr>
<td>Ctrl+V/Shift+Insert</td>
<td>从剪贴板粘贴</td>
</tr>
<tr>
<td>Ctrl + Shift + V</td>
<td>从最近的缓冲区粘贴</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>复制选定的区域或行到后面或下一行</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>删除当前行</td>
</tr>
<tr>
<td>Ctrl + Shift + J</td>
<td>添加智能线</td>
</tr>
<tr>
<td>Ctrl + Enter</td>
<td>智能线切割</td>
</tr>
<tr>
<td>Shift + Enter</td>
<td>下一行另起一行</td>
</tr>
<tr>
<td>Ctrl + Shift + U</td>
<td>在选定的区域或代码块间切换</td>
</tr>
<tr>
<td>Ctrl + Delete</td>
<td>删除到字符结束</td>
</tr>
<tr>
<td>Ctrl + Backspace</td>
<td>删除到字符开始</td>
</tr>
<tr>
<td>Ctrl + Numpad+/-</td>
<td>展开折叠代码块</td>
</tr>
<tr>
<td>Ctrl + Numpad+</td>
<td>全部展开</td>
</tr>
<tr>
<td>Ctrl + Numpad-</td>
<td>全部折叠</td>
</tr>
<tr>
<td>Ctrl + F4</td>
<td>关闭运行的选项卡</td>
</tr>
</tbody></table>
<h5 id="2、查找-替换-Search-Replace"><a href="#2、查找-替换-Search-Replace" class="headerlink" title="2、查找/替换(Search/Replace)"></a>2、查找/替换(Search/Replace)</h5><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>F3</td>
<td>下一个</td>
</tr>
<tr>
<td>Shift + F3</td>
<td>前一个</td>
</tr>
<tr>
<td>Ctrl + R</td>
<td>替换</td>
</tr>
<tr>
<td>Ctrl + Shift + F</td>
<td>全局查找</td>
</tr>
<tr>
<td>Ctrl + Shift + R</td>
<td>全局替换</td>
</tr>
</tbody></table>
<h5 id="3、运行-Running"><a href="#3、运行-Running" class="headerlink" title="3、运行(Running)"></a>3、运行(Running)</h5><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Alt + Shift + F10</td>
<td>运行模式配置</td>
</tr>
<tr>
<td>Alt + Shift + F9</td>
<td>调试模式配置</td>
</tr>
<tr>
<td>Shift + F10</td>
<td>运行</td>
</tr>
<tr>
<td>Shift + F9</td>
<td>调试</td>
</tr>
<tr>
<td>Ctrl + Shift + F10</td>
<td>运行编辑器配置</td>
</tr>
<tr>
<td>Ctrl + Alt + R</td>
<td>运行manage.py任务</td>
</tr>
</tbody></table>
<h5 id="4、调试-Debugging"><a href="#4、调试-Debugging" class="headerlink" title="4、调试(Debugging)"></a>4、调试(Debugging)</h5><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>F8</td>
<td>跳过</td>
</tr>
<tr>
<td>F7</td>
<td>进入</td>
</tr>
<tr>
<td>Shift + F8</td>
<td>退出</td>
</tr>
<tr>
<td>Alt + F9</td>
<td>运行游标</td>
</tr>
<tr>
<td>Alt + F8</td>
<td>验证表达式</td>
</tr>
<tr>
<td>Ctrl + Alt + F8</td>
<td>快速验证表达式</td>
</tr>
<tr>
<td>F9</td>
<td>恢复程序</td>
</tr>
<tr>
<td>Ctrl + F8</td>
<td>断点开关</td>
</tr>
<tr>
<td>Ctrl + Shift + F8</td>
<td>查看断点</td>
</tr>
</tbody></table>
<h5 id="5、导航-Navigation"><a href="#5、导航-Navigation" class="headerlink" title="5、导航(Navigation)"></a>5、导航(Navigation)</h5><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + N</td>
<td>跳转到类</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Shift + N</td>
<td>跳转到符号</td>
<td></td>
</tr>
<tr>
<td>Alt + Right/Left</td>
<td>跳转到下一个、前一个编辑的选项卡</td>
<td></td>
</tr>
<tr>
<td>F12</td>
<td>回到先前的工具窗口</td>
<td></td>
</tr>
<tr>
<td>Esc</td>
<td>从其他窗口回到编辑窗口</td>
<td></td>
</tr>
<tr>
<td>Shift + Esc</td>
<td>隐藏当前窗口，焦点到编辑窗口</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Shift + F4</td>
<td>关闭主动运行的选项卡</td>
<td></td>
</tr>
<tr>
<td>Ctrl + G</td>
<td>查看当前行号、字符号</td>
<td></td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>最近访问的文件</td>
<td></td>
</tr>
<tr>
<td>Ctrl+Alt+Left/Right</td>
<td>后退、前进</td>
<td></td>
</tr>
<tr>
<td>Ctrl+Shift+Backspace</td>
<td>导航到最近编辑区域</td>
<td></td>
</tr>
<tr>
<td>Alt + F1</td>
<td>查找当前文件或标识</td>
<td></td>
</tr>
<tr>
<td>Ctrl+B / Ctrl+Click</td>
<td>跳转到声明</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Alt + B</td>
<td>跳转到实现</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Shift + I</td>
<td>查看快速定义</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Shift + B</td>
<td>跳转到类型声明</td>
<td></td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>跳转到父方法、父类</td>
<td></td>
</tr>
<tr>
<td>Alt + Up/Down</td>
<td>跳转到上一个、下一个方法</td>
<td></td>
</tr>
<tr>
<td>Ctrl + ]/[</td>
<td>跳转到代码块结束、开始</td>
<td></td>
</tr>
<tr>
<td>Ctrl + F12</td>
<td>弹出文件结构</td>
<td></td>
</tr>
<tr>
<td>Ctrl + H</td>
<td>类型层次结构</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Shift + H</td>
<td>方法层次结构</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Alt + H</td>
<td>调用层次结构</td>
<td></td>
</tr>
<tr>
<td>F2 / Shift + F2</td>
<td>下一条、前一条高亮的错误</td>
<td></td>
</tr>
<tr>
<td>F4 / Ctrl + Enter</td>
<td>编辑资源、查看资源</td>
<td></td>
</tr>
<tr>
<td>Alt + Home</td>
<td>显示导航条F11书签开关</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Shift +F11</td>
<td>书签助记开关</td>
<td></td>
</tr>
<tr>
<td>Ctrl #[0-9]</td>
<td>+</td>
<td>跳转到标识的书签</td>
</tr>
<tr>
<td>Shift +</td>
<td>F11显示书签</td>
<td></td>
</tr>
</tbody></table>
<h5 id="6、搜索相关-Usage-Search"><a href="#6、搜索相关-Usage-Search" class="headerlink" title="6、搜索相关(Usage Search)"></a>6、搜索相关(Usage Search)</h5><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Alt + F7/Ctrl + F7</td>
<td>文件中查询用法</td>
</tr>
<tr>
<td>Ctrl + Shift + F7</td>
<td>文件中用法高亮显示</td>
</tr>
<tr>
<td>Ctrl + Alt + F7</td>
<td>显示用法</td>
</tr>
</tbody></table>
<h5 id="7、重构-Refactoring"><a href="#7、重构-Refactoring" class="headerlink" title="7、重构(Refactoring)"></a>7、重构(Refactoring)</h5><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>F5</td>
<td>复制</td>
</tr>
<tr>
<td>F6</td>
<td>剪切</td>
</tr>
<tr>
<td>Alt + Delete</td>
<td>安全删除</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>方法或变量重命名</td>
</tr>
<tr>
<td>Ctrl + F6</td>
<td>更改签名</td>
</tr>
<tr>
<td>Ctrl + Alt + N</td>
<td>内联</td>
</tr>
<tr>
<td>Ctrl + Alt + M</td>
<td>提取方法</td>
</tr>
<tr>
<td>Ctrl + Alt + V</td>
<td>提取属性</td>
</tr>
<tr>
<td>Ctrl + Alt + F</td>
<td>提取字段</td>
</tr>
<tr>
<td>Ctrl + Alt + C</td>
<td>提取常量</td>
</tr>
<tr>
<td>Ctrl + Alt + P</td>
<td>提取参数</td>
</tr>
</tbody></table>
<h5 id="8、控制VCS-Local-History"><a href="#8、控制VCS-Local-History" class="headerlink" title="8、控制VCS/Local History"></a>8、控制VCS/Local History</h5><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + K</td>
<td>提交项目</td>
</tr>
<tr>
<td>Ctrl + T</td>
<td>更新项目</td>
</tr>
<tr>
<td>Alt + Shift + C</td>
<td>查看最近的变化</td>
</tr>
<tr>
<td>Alt + BackQuote(’)VCS</td>
<td>快速弹出</td>
</tr>
<tr>
<td>Ctrl + Alt + J</td>
<td>当前行使用模版</td>
</tr>
</tbody></table>
<h5 id="9、模版-Live-Templates"><a href="#9、模版-Live-Templates" class="headerlink" title="9、模版(Live Templates)"></a>9、模版(Live Templates)</h5><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + Alt + J</td>
<td>当前行使用模版</td>
</tr>
<tr>
<td>Ctrl +Ｊ</td>
<td>插入模版</td>
</tr>
</tbody></table>
<h5 id="10、基本-General"><a href="#10、基本-General" class="headerlink" title="10、基本(General)"></a>10、基本(General)</h5><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Alt + #[0-9]</td>
<td>打开相应编号的工具窗口</td>
</tr>
<tr>
<td>Ctrl + Alt + Y</td>
<td>同步</td>
</tr>
<tr>
<td>Ctrl + Shift + F12</td>
<td>最大化编辑开关</td>
</tr>
<tr>
<td>Alt + Shift + F</td>
<td>添加到最喜欢</td>
</tr>
<tr>
<td>Alt + Shift + I</td>
<td>根据配置检查当前文件</td>
</tr>
<tr>
<td>Ctrl + BackQuote(’)</td>
<td>快速切换当前计划</td>
</tr>
<tr>
<td>Ctrl + Alt + S</td>
<td>打开设置页</td>
</tr>
<tr>
<td>Ctrl + Shift + A</td>
<td>查找编辑器里所有的动作</td>
</tr>
<tr>
<td>Ctrl + Tab</td>
<td>在窗口间进行切换</td>
</tr>
</tbody></table>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><h4 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + n</td>
<td>打开新窗口。</td>
</tr>
<tr>
<td>Ctrl + shift + n</td>
<td>在隐身模式下打开新窗口。</td>
</tr>
<tr>
<td>Ctrl + t</td>
<td>打开新的标签页。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>Ctrl + Shift + t</td>
<td>重新打开最后关闭的标签页。</td>
</tr>
<tr>
<td>Ctrl + Tab 或 Ctrl + Pgdn</td>
<td>跳转到下一个打开的标签页，如果当前为最后一个标签页，则跳转到第一个标签页。</td>
</tr>
<tr>
<td>Ctrl + Shift + Tab 或 Ctrl + Pgup</td>
<td>跳转到上一个打开的标签页。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>Alt + ←</td>
<td>打开历史记录中的上一页。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>Alt + →</td>
<td>打开历史记录中的下一页。</td>
</tr>
<tr>
<td>Ctrl + 1 到 Ctrl + 8</td>
<td>跳转到指定索引号的标签页。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>Ctrl + 9</td>
<td>跳转到最后一个标签页。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>Alt + home</td>
<td>在当前标签页中打开主页。</td>
</tr>
<tr>
<td>Ctrl + w 或 Ctrl + F4</td>
<td>关闭当前标签页。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>Ctrl + Shift + w</td>
<td>关闭所有已打开的标签页并关闭当前 Chrome 浏览器（如果开了多个浏览器，则只关闭当前的浏览器）。</td>
</tr>
<tr>
<td>Ctrl + Shift + q 或 Alt + F4</td>
<td>关闭所有 Chrome 浏览器。（<em>慎用</em>）</td>
</tr>
</tbody></table>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + h</td>
<td>在新标签页中打开”历史记录”页。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>Ctrl + j</td>
<td>在新标签页中打开”下载内容”页。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>Shift + Esc</td>
<td>打开 Chrome 任务管理器。</td>
</tr>
<tr>
<td>Ctrl + f 或 F3</td>
<td>打开关键字搜索框。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>Ctrl + g</td>
<td>跳转到与关键字搜索框中的文本相匹配的下一条内容。</td>
</tr>
<tr>
<td>Ctrl + Shift + g</td>
<td>跳转到与关键字搜索框中的文本相匹配的上一条内容。</td>
</tr>
<tr>
<td>Alt + f 或 Alt + e 或 F10</td>
<td>打开右上角的菜单栏。F10 只是选择菜单栏的图标，还需要键入回车或空格后，才能完全打开。</td>
</tr>
<tr>
<td>Ctrl + Shift + b</td>
<td>显示或隐藏书签栏。</td>
</tr>
<tr>
<td>Ctrl + Shift + o</td>
<td>打开书签管理器。</td>
</tr>
<tr>
<td>Shift + Alt + t</td>
<td>把焦点放在 Chrome 工具栏的第一项上。</td>
</tr>
<tr>
<td>F6</td>
<td>在地址栏与书签栏之间向前切换焦点。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>在地址栏与书签栏之间向后切换焦点。</td>
</tr>
<tr>
<td>F12 或 Ctrl + Shift + j</td>
<td>打开 “开发者工具”。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>Ctrl + Shift + Delete</td>
<td>打开 “清除浏览数据” 选项。</td>
</tr>
<tr>
<td>F1</td>
<td>打开 Chrome 帮助中心。</td>
</tr>
<tr>
<td>Ctrl + Shift + m</td>
<td>打开 Chrome 账户登陆对话框。</td>
</tr>
</tbody></table>
<h4 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + u</td>
<td>显示当前网页的 HTML 源代码【不可修改】。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>Ctrl + d</td>
<td>打开【将当前网页保存为书签】的对话框。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>Ctrl + Shift + d</td>
<td>打开【将所有打开的标签页以书签的形式保存在新文件夹】的对话框。</td>
</tr>
<tr>
<td>空格键或 Pgdn</td>
<td>向下滚动网页，一次一个屏幕。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>Shift + 空格键或 PgUp</td>
<td>向上滚动网页，一次一个屏幕。<em>Shift + 空格键实测不可用。</em></td>
</tr>
<tr>
<td>Ctrl 和 +</td>
<td>放大网页。</td>
</tr>
<tr>
<td>Ctrl 和 -</td>
<td>缩小网页。</td>
</tr>
<tr>
<td>Ctrl + 0</td>
<td>将网页恢复到默认大小。</td>
</tr>
<tr>
<td>Esc</td>
<td>停止加载网页。</td>
</tr>
<tr>
<td>Ctrl + p</td>
<td>打开打印选项。</td>
</tr>
<tr>
<td>Ctrl + s</td>
<td>保存当前网页。</td>
</tr>
<tr>
<td>F5 或 Ctrl + r</td>
<td>重新加载当前网页。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>Shift + F5 或 Ctrl + Shift + r</td>
<td>重新加载当前网页（忽略缓存内容）。</td>
</tr>
<tr>
<td>Tab</td>
<td>浏览下一个可点击项。</td>
</tr>
<tr>
<td>Shift + Tab</td>
<td>浏览上一个可点击项。</td>
</tr>
<tr>
<td>Ctrl + o</td>
<td>打开选择文件框。</td>
</tr>
<tr>
<td>F11</td>
<td>开启或关闭全屏模式。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>home</td>
<td>转到网页顶部。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>end</td>
<td>转到网页底部。</td>
</tr>
<tr>
<td>按住 Shift 并滚动鼠标滚轮</td>
<td>在网页上水平滚动。</td>
</tr>
</tbody></table>
<h4 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标+"></a>鼠标+</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>按住 Ctrl 并点击网页链接</td>
<td>在新的标签页中打开网页。（<strong>常用</strong>）</td>
</tr>
<tr>
<td>按住 Alt 并点击网页链接</td>
<td>下载链接目前的网页。</td>
</tr>
<tr>
<td>将网页链接拖拽到标签栏的空白位置</td>
<td>在新的标签页中打开网页。</td>
</tr>
<tr>
<td>按住 Shift 并点击网页链接</td>
<td>在新窗口中打开网页。</td>
</tr>
<tr>
<td>将标签页拖出标签栏</td>
<td>在新窗口中打开网页。</td>
</tr>
<tr>
<td>将标签页拖进现有窗口</td>
<td>将标签页移至当前窗口。</td>
</tr>
<tr>
<td>双击标签栏的空白区域</td>
<td>最大化或最小化当前窗口。</td>
</tr>
<tr>
<td>按住 Ctrl 并向上滚动鼠标滚轮</td>
<td>放大网页。</td>
</tr>
<tr>
<td>按住 Ctrl 并向下滚动鼠标滚轮</td>
<td>缩小网页。</td>
</tr>
</tbody></table>
<h3 id="Terminal（命令行）"><a href="#Terminal（命令行）" class="headerlink" title="Terminal（命令行）"></a>Terminal（命令行）</h3><h4 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+Alt+T</td>
<td>启动终端</td>
</tr>
<tr>
<td>F1</td>
<td>打开帮助指南</td>
</tr>
<tr>
<td>F10</td>
<td>激活菜单栏</td>
</tr>
<tr>
<td>F11</td>
<td>全屏切换</td>
</tr>
<tr>
<td>Alt+F</td>
<td>打开 “文件” 菜单（file）</td>
</tr>
<tr>
<td>Alt+E</td>
<td>打开 “编辑” 菜单（edit）</td>
</tr>
<tr>
<td>Alt+V</td>
<td>打开 “查看” 菜单（view）</td>
</tr>
<tr>
<td>Alt+S</td>
<td>打开 “搜索” 菜单（search）</td>
</tr>
<tr>
<td>Alt+T</td>
<td>打开 “终端” 菜单（terminal）</td>
</tr>
<tr>
<td>Alt+H</td>
<td>打开 “帮助” 菜单（help）</td>
</tr>
<tr>
<td>Ctrl+Shift+C</td>
<td>复制</td>
</tr>
<tr>
<td>Ctrl+Shift+V</td>
<td>粘贴</td>
</tr>
<tr>
<td>Ctrl+Shift+T</td>
<td>新建标签页</td>
</tr>
<tr>
<td>Ctrl+Shift+W</td>
<td>关闭标签页</td>
</tr>
<tr>
<td>Ctrl+Shift+N</td>
<td>新建终端窗口</td>
</tr>
<tr>
<td>Ctrl+Shift+Q</td>
<td>关闭终端窗口</td>
</tr>
<tr>
<td>Ctrl+Shift+PgUp</td>
<td>标签页左移</td>
</tr>
<tr>
<td>Ctrl+Shift+PgDn</td>
<td>标签页右移</td>
</tr>
<tr>
<td>Alt+N</td>
<td>切换到第 N 个标签页（N=0…9）</td>
</tr>
<tr>
<td>Ctrl+PgUp</td>
<td>切换到上一个标签页（page up）</td>
</tr>
<tr>
<td>Ctrl+PgDn</td>
<td>切换到下一个标签页（page down）</td>
</tr>
<tr>
<td>Ctrl+Alt+Fn</td>
<td>切换到字符界面（n=1…6）  如果需要切换回图形界面，需要使用 Ctrl+Alt+F7 或 Alt+F7</td>
</tr>
<tr>
<td>Ctrl+Shift++</td>
<td>放大窗口（包括窗口内的字体）</td>
</tr>
<tr>
<td>Ctrl+-</td>
<td>缩写窗口（包括窗口内的字体）</td>
</tr>
<tr>
<td>Ctrl+0</td>
<td>普通大小（阿拉伯数字 0）</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>在空白处执行将结束当前会话（同 exit 命令功能）</td>
</tr>
<tr>
<td>Ctrl+P</td>
<td>显示上一条历史命令（同 up arrow 功能）</td>
</tr>
<tr>
<td>Ctrl+N</td>
<td>显示下一条历史命令（同 down arrow 功能）</td>
</tr>
<tr>
<td>Ctrl+R</td>
<td>反向搜索历史命令</td>
</tr>
<tr>
<td>Ctrl+O</td>
<td>回车（同 enter 键功能）</td>
</tr>
<tr>
<td>Ctrl+J</td>
<td>回车（同 enter 键功能）</td>
</tr>
<tr>
<td>Ctrl+M</td>
<td>回车（同 enter 键功能）</td>
</tr>
<tr>
<td>Ctrl+A</td>
<td>光标移动到行的开头</td>
</tr>
<tr>
<td>Ctrl+E</td>
<td>光标移动到行的结尾</td>
</tr>
<tr>
<td>Ctrl+B</td>
<td>光标向后移动一个位置（backward）</td>
</tr>
<tr>
<td>Ctrl+F</td>
<td>光标向前移动一个位置（forward）</td>
</tr>
<tr>
<td>Ctrl+Left-Arrow</td>
<td>光标移动到上一个单词的词首</td>
</tr>
<tr>
<td>Ctrl+Right-Arrow</td>
<td>光标移动到下一个单词的词尾</td>
</tr>
<tr>
<td>Ctrl+T</td>
<td>将光标位置的字符和前一个字符进行位置交换</td>
</tr>
<tr>
<td>Ctrl+U</td>
<td>剪切从行的开头到光标前一个位置的所有字符</td>
</tr>
<tr>
<td>Ctrl+K</td>
<td>剪切从光标位置到行末的所有字符</td>
</tr>
<tr>
<td>Ctrl+Y</td>
<td>粘贴 ctrl+u 或者 ctrl+k 剪切的内容</td>
</tr>
<tr>
<td>Ctrl+H</td>
<td>删除光标位置的前一个字符（同 backspace 键功能）</td>
</tr>
<tr>
<td>Ctrl+*</td>
<td>删除光标位置的前一个字符（同 ctrl+h 组合键功能）</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>删除光标位置的一个字符（同 delete 键功能）</td>
</tr>
<tr>
<td>Ctrl+W</td>
<td>删除光标位置的前一个单词（同 alt+backspace 组合键功能）</td>
</tr>
<tr>
<td>Ctrl+&amp;</td>
<td>恢复 ctrl+h 或者 ctrl+d 或者 ctrl+w 删除的内容</td>
</tr>
<tr>
<td>Ctrl+L</td>
<td>清除当前屏幕内容（同 clear 命令功能）</td>
</tr>
<tr>
<td>Ctrl+S</td>
<td>暂停屏幕输出</td>
</tr>
<tr>
<td>Ctrl+Q</td>
<td>继续屏幕输出</td>
</tr>
</tbody></table>
<h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>在终端窗口命令提示符下，连续按两次 Tab 键、或者连续按三次 Esc 键、或者按 Ctrl+I 组合键，将显示所有的命令及工具名称。</p>
<p>Ubuntu 系统切换到字符界面： <strong><em>\</em>Ctrl+Alt+Fn**</strong>（n=1…6）；切换回图形界面： Ctrl+Alt+F7 或 Alt+F7。</p>
<p>CentOS 系统切换到字符界面： Ctrl+Alt+Fn（n=2…6）；切换回图形界面： Ctrl+Alt+F1 或 Alt+F1。</p>
<h3 id="VS-code"><a href="#VS-code" class="headerlink" title="VS code"></a>VS code</h3><table>
<thead>
<tr>
<th>按 Press</th>
<th>功能 Function</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + Shift + P，F1</td>
<td>显示命令面板 Show Command Palette</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>快速打开 Quick Open</td>
</tr>
<tr>
<td>Ctrl + Shift + N</td>
<td>新窗口/实例 New window/instance</td>
</tr>
<tr>
<td>Ctrl + Shift + W</td>
<td>关闭窗口/实例 Close window/instance</td>
</tr>
</tbody></table>
<h4 id="基础编辑-Basic-editing"><a href="#基础编辑-Basic-editing" class="headerlink" title="基础编辑 Basic editing"></a>基础编辑 Basic editing</h4><table>
<thead>
<tr>
<th>按 Press</th>
<th>功能 Function</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+X</td>
<td>剪切行（空选定） Cut line (empty selection)</td>
</tr>
<tr>
<td>Ctrl+C</td>
<td>复制行（空选定）Copy line (empty selection)</td>
</tr>
<tr>
<td>Alt+ ↑ / ↓</td>
<td>向上/向下移动行 Move line up/down</td>
</tr>
<tr>
<td>Shift+Alt + ↓ / ↑</td>
<td>向上/向下复制行 Copy line up/down</td>
</tr>
<tr>
<td>Ctrl+Shift+K</td>
<td>删除行 Delete line</td>
</tr>
<tr>
<td>Ctrl+Enter</td>
<td>在下面插入行 Insert line below</td>
</tr>
<tr>
<td>Ctrl+Shift+Enter</td>
<td>在上面插入行 Insert line above</td>
</tr>
<tr>
<td>Ctrl+Shift+\</td>
<td>跳到匹配的括号 Jump to matching bracket</td>
</tr>
<tr>
<td>Ctrl+] / [</td>
<td>缩进/缩进行 Indent/outdent line</td>
</tr>
<tr>
<td>Home</td>
<td>转到行首 Go to beginning of line</td>
</tr>
<tr>
<td>End</td>
<td>转到行尾 Go to end of line</td>
</tr>
<tr>
<td>Ctrl+Home</td>
<td>转到文件开头 Go to beginning of file</td>
</tr>
<tr>
<td>Ctrl+End</td>
<td>转到文件末尾 Go to end of file</td>
</tr>
<tr>
<td>Ctrl+↑ / ↓</td>
<td>向上/向下滚动行 Scroll line up/down</td>
</tr>
<tr>
<td>Alt+PgUp / PgDown</td>
<td>向上/向下滚动页面 Scroll page up/down</td>
</tr>
<tr>
<td>Ctrl+Shift+[</td>
<td>折叠（折叠）区域 Fold (collapse) region</td>
</tr>
<tr>
<td>Ctrl+Shift+]</td>
<td>展开（未折叠）区域 Unfold (uncollapse) region</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+[</td>
<td>折叠（未折叠）所有子区域 Fold (collapse) all subregions</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+]</td>
<td>展开（未折叠）所有子区域 Unfold (uncollapse) all subregions</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+0</td>
<td>折叠（折叠）所有区域 Fold (collapse) all regions</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+J</td>
<td>展开（未折叠）所有区域 Unfold (uncollapse) all regions</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+C</td>
<td>添加行注释 Add line comment</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+U</td>
<td>删除行注释 Remove line comment</td>
</tr>
<tr>
<td>Ctrl+/</td>
<td>切换行注释 Toggle line comment</td>
</tr>
<tr>
<td>Shift+Alt+A</td>
<td>切换块注释 Toggle block comment</td>
</tr>
<tr>
<td>Alt+Z</td>
<td>切换换行 Toggle word wrap</td>
</tr>
</tbody></table>
<h4 id="导航-Navigation"><a href="#导航-Navigation" class="headerlink" title="导航 Navigation"></a>导航 Navigation</h4><table>
<thead>
<tr>
<th>按 Press</th>
<th>功能 Function</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + T</td>
<td>显示所有符号 Show all Symbols</td>
</tr>
<tr>
<td>Ctrl + G</td>
<td>转到行… Go to Line…</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>转到文件… Go to File…</td>
</tr>
<tr>
<td>Ctrl + Shift + O</td>
<td>转到符号… Go to Symbol…</td>
</tr>
<tr>
<td>Ctrl + Shift + M</td>
<td>显示问题面板 Show Problems panel</td>
</tr>
<tr>
<td>F8</td>
<td>转到下一个错误或警告 Go to next error or warning</td>
</tr>
<tr>
<td>Shift + F8</td>
<td>转到上一个错误或警告 Go to previous error or warning</td>
</tr>
<tr>
<td>Ctrl + Shift + Tab</td>
<td>导航编辑器组历史记录 Navigate editor group history</td>
</tr>
<tr>
<td>Alt + ←/→</td>
<td>返回/前进 Go back / forward</td>
</tr>
<tr>
<td>Ctrl + M</td>
<td>切换选项卡移动焦点 Toggle Tab moves focus</td>
</tr>
</tbody></table>
<h4 id="搜索和替换-Search-and-replace"><a href="#搜索和替换-Search-and-replace" class="headerlink" title="搜索和替换 Search and replace"></a>搜索和替换 Search and replace</h4><table>
<thead>
<tr>
<th>按 Press</th>
<th>功能 Function</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + F</td>
<td>查找 Find</td>
</tr>
<tr>
<td>Ctrl + H</td>
<td>替换 Replace</td>
</tr>
<tr>
<td>F3 / Shift + F3</td>
<td>查找下一个/上一个 Find next/previous</td>
</tr>
<tr>
<td>Alt + Enter</td>
<td>选择查找匹配的所有出现 Select all occurences of Find match</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>将选择添加到下一个查找匹配 Add selection to next Find match</td>
</tr>
<tr>
<td>Ctrl + K Ctrl + D</td>
<td>将最后一个选择移至下一个查找匹配项 Move last selection to next Find match</td>
</tr>
<tr>
<td>Alt + C / R / W</td>
<td>切换区分大小写/正则表达式/整个词 Toggle case-sensitive / regex / whole word</td>
</tr>
</tbody></table>
<h4 id="多光标和选择-Multi-cursor-and-selection"><a href="#多光标和选择-Multi-cursor-and-selection" class="headerlink" title="多光标和选择 Multi-cursor and selection"></a>多光标和选择 Multi-cursor and selection</h4><table>
<thead>
<tr>
<th>按 Press</th>
<th>功能 Function</th>
</tr>
</thead>
<tbody><tr>
<td>Alt +单击</td>
<td>插入光标 Insert cursor</td>
</tr>
<tr>
<td>Ctrl + Alt +↑/↓</td>
<td>在上/下插入光标 Insert cursor above / below</td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>撤消上一个光标操作 Undo last cursor operation</td>
</tr>
<tr>
<td>Shift + Alt + I</td>
<td>在选定的每一行的末尾插入光标 Insert cursor at end of each line selected</td>
</tr>
<tr>
<td>Ctrl + I</td>
<td>选择当前行 Select current line</td>
</tr>
<tr>
<td>Ctrl + Shift + L</td>
<td>选择当前选择的所有出现 Select all occurrences of current selection</td>
</tr>
<tr>
<td>Ctrl + F2</td>
<td>选择当前字的所有出现 Select all occurrences of current word</td>
</tr>
<tr>
<td>Shift + Alt + →</td>
<td>展开选择 Expand selection</td>
</tr>
<tr>
<td>Shift + Alt + ←</td>
<td>缩小选择 Shrink selection</td>
</tr>
<tr>
<td>Shift + Alt + （拖动鼠标）</td>
<td>列（框）选择 Column (box) selection</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt +（箭头键）</td>
<td>列（框）选择 Column (box) selection</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt + PgUp / PgDown</td>
<td>列（框）选择页上/下 Column (box) selection page up/down</td>
</tr>
</tbody></table>
<h4 id="丰富的语言编辑-Rich-languages-editing"><a href="#丰富的语言编辑-Rich-languages-editing" class="headerlink" title="丰富的语言编辑 Rich languages editing"></a>丰富的语言编辑 Rich languages editing</h4><table>
<thead>
<tr>
<th>按 Press</th>
<th>功能 Function</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + 空格</td>
<td>触发建议 Trigger suggestion</td>
</tr>
<tr>
<td>Ctrl + Shift + Space</td>
<td>触发器参数提示 Trigger parameter hints</td>
</tr>
<tr>
<td>Tab</td>
<td>Emmet 展开缩写 Emmet expand abbreviation</td>
</tr>
<tr>
<td>Shift + Alt + F</td>
<td>格式化文档 Format document</td>
</tr>
<tr>
<td>Ctrl + K Ctrl + F</td>
<td>格式选定区域 Format selection</td>
</tr>
<tr>
<td>F12</td>
<td>转到定义 Go to Definition</td>
</tr>
<tr>
<td>Alt + F12</td>
<td>Peek定义 Peek Definition</td>
</tr>
<tr>
<td>Ctrl + K F12</td>
<td>打开定义到边 Open Definition to the side</td>
</tr>
<tr>
<td>Ctrl + .</td>
<td>快速解决 Quick Fix</td>
</tr>
<tr>
<td>Shift + F12</td>
<td>显示引用 Show References</td>
</tr>
<tr>
<td>F2</td>
<td>重命名符号 Rename Symbol</td>
</tr>
<tr>
<td>Ctrl + Shift + . /，</td>
<td>替换为下一个/上一个值 Replace with next/previous value</td>
</tr>
<tr>
<td>Ctrl + K Ctrl + X</td>
<td>修剪尾随空格 Trim trailing whitespace</td>
</tr>
<tr>
<td>Ctrl + K M</td>
<td>更改文件语言 Change file language</td>
</tr>
</tbody></table>
<h4 id="编辑器管理-Editor-management"><a href="#编辑器管理-Editor-management" class="headerlink" title="编辑器管理 Editor management"></a>编辑器管理 Editor management</h4><table>
<thead>
<tr>
<th>按 Press</th>
<th>功能 Function</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+F4, Ctrl+W</td>
<td>关闭编辑器 Close editor</td>
</tr>
<tr>
<td>Ctrl+K F</td>
<td>关闭文件夹 Close folder</td>
</tr>
<tr>
<td>Ctrl+\</td>
<td>拆分编辑器 Split editor</td>
</tr>
<tr>
<td>Ctrl+ 1 / 2 / 3</td>
<td>聚焦到第1，第2或第3编辑器组 Focus into 1st, 2nd or 3rd editor group</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+ ←/→</td>
<td>聚焦到上一个/下一个编辑器组 Focus into previous/next editor group</td>
</tr>
<tr>
<td>Ctrl+Shift+PgUp / PgDown</td>
<td>向左/向右移动编辑器 Move editor left/right</td>
</tr>
<tr>
<td>Ctrl+K ← / →</td>
<td>移动活动编辑器组 Move active editor group</td>
</tr>
</tbody></table>
<h4 id="文件管理-File-management"><a href="#文件管理-File-management" class="headerlink" title="文件管理 File management"></a>文件管理 File management</h4><table>
<thead>
<tr>
<th>按 Press</th>
<th>功能 Function</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+N</td>
<td>新文件 New File</td>
</tr>
<tr>
<td>Ctrl+O</td>
<td>打开文件… Open File…</td>
</tr>
<tr>
<td>Ctrl+S</td>
<td>保存 Save</td>
</tr>
<tr>
<td>Ctrl+Shift+S</td>
<td>另存为… Save As…</td>
</tr>
<tr>
<td>Ctrl+K S</td>
<td>全部保存 Save All</td>
</tr>
<tr>
<td>Ctrl+F4</td>
<td>关闭 Close</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+W</td>
<td>关闭所有 Close All</td>
</tr>
<tr>
<td>Ctrl+Shift+T</td>
<td>重新打开关闭的编辑器 Reopen closed editor</td>
</tr>
<tr>
<td>Ctrl+K</td>
<td>输入保持打开 Enter Keep Open</td>
</tr>
<tr>
<td>Ctrl+Tab</td>
<td>打开下一个 Open next</td>
</tr>
<tr>
<td>Ctrl+Shift+Tab</td>
<td>打开上一个 Open previous</td>
</tr>
<tr>
<td>Ctrl+K P</td>
<td>复制活动文件的路径 Copy path of active file</td>
</tr>
<tr>
<td>Ctrl+K R</td>
<td>显示资源管理器中的活动文件 Reveal active file in Explorer</td>
</tr>
<tr>
<td>Ctrl+K O</td>
<td>显示新窗口/实例中的活动文件 Show active file in new window/instance</td>
</tr>
</tbody></table>
<h4 id="显示-Display"><a href="#显示-Display" class="headerlink" title="显示 Display"></a>显示 Display</h4><table>
<thead>
<tr>
<th>按 Press</th>
<th>功能 Function</th>
</tr>
</thead>
<tbody><tr>
<td>F11</td>
<td>切换全屏 Toggle full screen</td>
</tr>
<tr>
<td>Shift+Alt+1</td>
<td>切换编辑器布局 Toggle editor layout</td>
</tr>
<tr>
<td>Ctrl+ = / -</td>
<td>放大/缩小 Zoom in/out</td>
</tr>
<tr>
<td>Ctrl+B</td>
<td>切换侧栏可见性 Toggle Sidebar visibility</td>
</tr>
<tr>
<td>Ctrl+Shift+E</td>
<td>显示浏览器/切换焦点 Show Explorer / Toggle focus</td>
</tr>
<tr>
<td>Ctrl+Shift+F</td>
<td>显示搜索 Show Search</td>
</tr>
<tr>
<td>Ctrl+Shift+G</td>
<td>显示Git Show Git</td>
</tr>
<tr>
<td>Ctrl+Shift+D</td>
<td>显示调试 Show Debug</td>
</tr>
<tr>
<td>Ctrl+Shift+X</td>
<td>显示扩展 Show Extensions</td>
</tr>
<tr>
<td>Ctrl+Shift+H</td>
<td>替换文件 Replace in files</td>
</tr>
<tr>
<td>Ctrl+Shift+J</td>
<td>切换搜索详细信息 Toggle Search details</td>
</tr>
<tr>
<td>Ctrl+Shift+C</td>
<td>打开新命令提示符/终端 Open new command prompt/terminal</td>
</tr>
<tr>
<td>Ctrl+Shift+U</td>
<td>显示输出面板 Show Output panel</td>
</tr>
<tr>
<td>Ctrl+Shift+V</td>
<td>切换Markdown预览 Toggle Markdown preview</td>
</tr>
<tr>
<td>Ctrl+K V</td>
<td>从旁边打开Markdown预览 Open Markdown preview to the side</td>
</tr>
</tbody></table>
<h4 id="调试-Debug"><a href="#调试-Debug" class="headerlink" title="调试 Debug"></a>调试 Debug</h4><table>
<thead>
<tr>
<th>按 Press</th>
<th>功能 Function</th>
</tr>
</thead>
<tbody><tr>
<td>F9</td>
<td>切换断点 Toggle breakpoint</td>
</tr>
<tr>
<td>F5</td>
<td>开始/继续 Start/Continue</td>
</tr>
<tr>
<td>Shift+F5</td>
<td>停止 Stop</td>
</tr>
<tr>
<td>F11 / Shift+F11</td>
<td>下一步/上一步 Step into/out</td>
</tr>
<tr>
<td>F10</td>
<td>跳过 Step over</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+I</td>
<td>显示悬停 Show hover</td>
</tr>
</tbody></table>
<h4 id="集成终端-Integrated-terminal"><a href="#集成终端-Integrated-terminal" class="headerlink" title="集成终端 Integrated terminal"></a>集成终端 Integrated terminal</h4><table>
<thead>
<tr>
<th>按 Press</th>
<th>功能 Function</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+`</td>
<td>显示集成终端 Show integrated terminal</td>
</tr>
<tr>
<td>Ctrl+Shift+`</td>
<td>创建新终端 Create new terminal</td>
</tr>
<tr>
<td>Ctrl+Shift+C</td>
<td>复制选定 Copy selection</td>
</tr>
<tr>
<td>Ctrl+Shift+V</td>
<td>粘贴到活动端子 Paste into active terminal</td>
</tr>
<tr>
<td>Ctrl+↑ / ↓</td>
<td>向上/向下滚动 Scroll up/down</td>
</tr>
<tr>
<td>Shift+PgUp / PgDown</td>
<td>向上/向下滚动页面 Scroll page up/down</td>
</tr>
<tr>
<td>Ctrl+Home / End</td>
<td>滚动到顶部/底部 Scroll to top/bottom</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>常用</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬取网页中JavaScript动态添加的内容</title>
    <url>/2019/Python/Python%20%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%B8%ADJavaScript%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<p><strong>方法一</strong>：用Web kit，Web kit 可以实现浏览器所能处理的任何事情，Web kit是QT库的一部分，因此如果你已经安装QT和PyQT库，那么你可以直接运行使用。</p>
<p><strong>方法二</strong>：使用 selenium + phantomjs 实现</p>
<a id="more"></a>

<hr>
<h2 id="1-Web-Kit渲染"><a href="#1-Web-Kit渲染" class="headerlink" title="1. Web Kit渲染"></a>1. Web Kit渲染</h2><p><strong>环境安装</strong></p>
<ul>
<li><p>Ubuntu：<code>sudo apt install python-qt4</code></p>
</li>
<li><p>Windows：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vSmltYy9wLzk3MTcyMzguaHRtbA==">https://www.cnblogs.com/Jimc/p/9717238.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<p><strong>方法</strong>：首先通过 Web kit 发送请求信息，然后等待网页被完全加载后将其赋值到某个变量中。接下来我们利用<code>lxml</code>从 HTML 数据中提取出有效的信息。这个过程需要一点时间。</p>
<pre><code class="line-numbers language-python">import sys
from PyQt4.QtWebKit import *
from PyQt4.QtGui import *
from PyQt4.QtCore import *
class Render(QWebPage):  # 用来渲染网页,将url中的所有信息加载下来并存到一个新的框架中
    def __init__(self,url):
        self.app = QApplication(sys.argv)
        QWebPage.__init__(self)
        self.loadFinished.connect(self._loadFinished)
        self.mainFrame().load(QUrl(url))
        self.app.exec_()
    def _loadFinished(self, result):
        self.frame = self.mainFrame()
        self.app.quit()

url = &#39;http://jandan.net/ooxx&#39;
r = Render(url)
html = r.frame.toHtml()
print(html)</code></pre>
<h2 id="2-使用selenium-phantomjs"><a href="#2-使用selenium-phantomjs" class="headerlink" title="2. 使用selenium + phantomjs"></a>2. 使用selenium + phantomjs</h2>]]></content>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云对象存储OSS的原理及使用</title>
    <url>/2019/Python/%E9%98%BF%E9%87%8C%E4%BA%91OSS/</url>
    <content><![CDATA[<p>OpenStorageService，简称OSS，是阿里云对外提供的海量，安全，低成本，高可靠的云存储服务。用户可以通过简单的REST接口，在任何时间、任何地点、任何互联网设备上进行上传和下载数据，也可以使用WEB页面对数据进行管理。</p>
<p>同时，OSS提供Java、 Python、 PHP、C#语言的SDK，简化用户的编程。基于OSS，用户可以搭建出各种多媒体分享网站、网盘、个人和企业数据备份等基于大规模数据的服务。</p>
<a id="more"></a>

<hr>
<h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h3 id="1-1-Python-SDK-依赖库"><a href="#1-1-Python-SDK-依赖库" class="headerlink" title="1.1 Python SDK 依赖库"></a>1.1 Python SDK 依赖库</h3><pre><code class="line-numbers language-bash">pip install oss2</code></pre>
<h3 id="1-2-OSS相关概念"><a href="#1-2-OSS相关概念" class="headerlink" title="1.2 OSS相关概念"></a>1.2 OSS相关概念</h3><p><strong>Object</strong></p>
<p>在OSS中，用户操作的基本数据单元是Object。单个Object最大允许存储5TB的数据。Object包含key、meta和data。其中，key是Object的名字；meta是用户对该object的描述，由一系列name-value对组成；data是Object的数据。</p>
<p>使用UTF-8编码、长度必须在1-1023字节之间、不能以“/”或者“\”字符开头</p>
<p><strong>Bucket</strong></p>
<p>Bucket是OSS上的命名空间，也是计费、权限控制、日志记录等高级功能的管理实体；Bucket名称在整个OSS服务中具有全局唯一性，且不能修改；存储在OSS上的每个Object必须都包含在某个Bucket中。一个应用，例如图片分享网站，可以对应一个或多个Bucket。一个用户最多可创建10个Bucket，但每个Bucket中存放的Object的数量和大小总和没有限制，用户不需要考虑数据的可扩展性。</p>
<p>只能包括小写字母，数字，短横线（-）、必须以小写字母或者数字开头、长度必须在3-63字节之间</p>
<p><strong>Access Key ID、Access Key Secret</strong></p>
<p>用户注册OSS时，系统会给用户分配一对Access Key ID和Access Key Secret，称为ID对，用于标识用户，为访问OSS做签名验证。</p>
<p><strong>Service</strong></p>
<p>OSS提供给用户的虚拟存储空间，在这个虚拟空间中，每个用户可拥有一个到多个Bucket。</p>
<h3 id="1-3-OSS基本功能"><a href="#1-3-OSS基本功能" class="headerlink" title="1.3 OSS基本功能"></a>1.3 OSS基本功能</h3><p>OSS为用户提供数据存储服务，用户可以通过以下操作来处理OSS上的数据：</p>
<ul>
<li><p>创建、查看、罗列、删除 Bucket</p>
</li>
<li><p>修改、获取Bucket的访问权限</p>
</li>
<li><p>上传、查看、罗列、删除、批量删除Object</p>
</li>
<li><p>对于大文件支持分片上传（Multi-Part Upload）</p>
</li>
<li><p>访问时支持If-Modified-Since和If-Match等HTTP参数</p>
</li>
</ul>
<h3 id="1-4-Object外链地址的构成规则"><a href="#1-4-Object外链地址的构成规则" class="headerlink" title="1.4  Object外链地址的构成规则"></a>1.4  Object外链地址的构成规则</h3><blockquote>
<p>如果一个bucket设置成公开读权限意味着你允许其他用户来访问属于你的object。你的object的外链地址构成规则如下：</p>
<p><code> http:// &lt;你的bucket名字&gt;.oss.aliyuncs.com/&lt;你的object名字&gt; </code></p>
<p>例如，在一个名为oss-example的bucket中，有一个名为”aliyun-log.png”的object（content-type为image/png）。那么这个object的外链URL为：</p>
<p><code>http://oss-example.oss.aliyuncs.com//image/aliyun-logo.png</code></p>
<p>用户可以直接该URL链接放入HTML中使用</p>
</blockquote>
<h2 id="2-Python-SDK-基础使用"><a href="#2-Python-SDK-基础使用" class="headerlink" title="2. Python SDK 基础使用"></a>2. Python SDK 基础使用</h2><p>以下代码展示了基本的文件上传、下载、罗列、删除用法。</p>
<pre><code class="line-numbers language-python">import os
import shutil
import oss2


# 首先初始化AccessKeyId、AccessKeySecret、Endpoint等信息。
# 通过环境变量获取，或者把诸如“&lt;你的AccessKeyId&gt;”替换成真实的AccessKeyId等。
#
# 以杭州区域为例，Endpoint可以是：
#   http://oss-cn-hangzhou.aliyuncs.com
#   https://oss-cn-hangzhou.aliyuncs.com
# 分别以HTTP、HTTPS协议访问。
access_key_id = os.getenv(&#39;OSS_TEST_ACCESS_KEY_ID&#39;, &#39;&lt;你的AccessKeyId&gt;&#39;)
access_key_secret = os.getenv(&#39;OSS_TEST_ACCESS_KEY_SECRET&#39;, &#39;&lt;你的AccessKeySecret&gt;&#39;)
bucket_name = os.getenv(&#39;OSS_TEST_BUCKET&#39;, &#39;&lt;你的Bucket&gt;&#39;)
endpoint = os.getenv(&#39;OSS_TEST_ENDPOINT&#39;, &#39;&lt;你的访问域名&gt;&#39;)


# 确认上面的参数都填写正确了
for param in (access_key_id, access_key_secret, bucket_name, endpoint):
    assert &#39;&lt;&#39; not in param, &#39;请设置参数：&#39; + param


# 创建Bucket对象，所有Object相关的接口都可以通过Bucket对象来进行
bucket = oss2.Bucket(oss2.Auth(access_key_id, access_key_secret), endpoint, bucket_name)


# 上传一段字符串。Object名是motto.txt，内容是一段名言。
bucket.put_object(&#39;motto.txt&#39;, &#39;Never give up. - Jack Ma&#39;)

# 获取Object的metadata
object_meta = bucket.get_object_meta(&#39;你的对象名&#39;)
print(&#39;last modified: &#39; + object_meta.last_modified)
print(&#39;etag: &#39; + object_meta.etag)
print(&#39;size: &#39; + object_meta.content_length)

# 下载到本地文件
bucket.get_object_to_file(&#39;motto.txt&#39;, &#39;本地文件名.txt&#39;)


# 把刚刚上传的Object下载到本地文件 “座右铭.txt” 中
# 因为get_object()方法返回的是一个file-like object，所以我们可以直接用shutil.copyfileobj()做拷贝
with open(oss2.to_unicode(&#39;本地座右铭.txt&#39;), &#39;wb&#39;) as f:
    shutil.copyfileobj(bucket.get_object(&#39;motto.txt&#39;), f)


# 把本地文件 “座右铭.txt” 上传到OSS，新的Object叫做 “我的座右铭.txt”
# 注意到，这次put_object()的第二个参数是file object；而上次上传是一个字符串。
# put_object()能够识别不同的参数类型
with open(oss2.to_unicode(&#39;本地座右铭.txt&#39;), &#39;rb&#39;) as f:
    bucket.put_object(&#39;云上座右铭.txt&#39;, f)


# 上面两行代码，也可以用下面的一行代码来实现
bucket.put_object_from_file(&#39;云上座右铭.txt&#39;, &#39;本地座右铭.txt&#39;)


# 列举Bucket下10个Object，并打印它们的最后修改时间、文件名
for i, object_info in enumerate(oss2.ObjectIterator(bucket)):
    print(&quot;&#123;0&#125; &#123;1&#125;&quot;.format(object_info.last_modified, object_info.key))

    if i &gt;= 9:
        break


# 删除名为motto.txt的Object
bucket.delete_object(&#39;motto.txt&#39;)

# 也可以批量删除
# 注意：重复删除motto.txt，并不会报错
bucket.batch_delete_objects([&#39;motto.txt&#39;, &#39;云上座右铭.txt&#39;])


# 确认Object已经被删除了
assert not bucket.object_exists(&#39;motto.txt&#39;)


# 获取不存在的文件会抛出oss2.exceptions.NoSuchKey异常
try:
    bucket.get_object(&#39;云上座右铭.txt&#39;)
except oss2.exceptions.NoSuchKey as e:
    print(u&#39;已经被删除了：request_id=&#123;0&#125;&#39;.format(e.request_id))
else:
    assert False

# 清除本地文件
os.remove(u&#39;本地文件名.txt&#39;)
os.remove(u&#39;本地座右铭.txt&#39;)</code></pre>
<h2 id="3-上传及下载进度条"><a href="#3-上传及下载进度条" class="headerlink" title="3. 上传及下载进度条"></a>3. 上传及下载进度条</h2><pre><code class="line-numbers language-python"># -*- coding: utf-8 -*-

import os
import sys
import tempfile

import oss2

# 以下代码展示了进度条功能的用法，包括上传进度条和下载进度条。


# 首先初始化AccessKeyId、AccessKeySecret、Endpoint等信息。
# 通过环境变量获取，或者把诸如“&lt;你的AccessKeyId&gt;”替换成真实的AccessKeyId等。
access_key_id = os.getenv(&#39;OSS_TEST_ACCESS_KEY_ID&#39;, &#39;&lt;你的AccessKeyId&gt;&#39;)
access_key_secret = os.getenv(&#39;OSS_TEST_ACCESS_KEY_SECRET&#39;, &#39;&lt;你的AccessKeySecret&gt;&#39;)
bucket_name = os.getenv(&#39;OSS_TEST_BUCKET&#39;, &#39;&lt;你的Bucket&gt;&#39;)
endpoint = os.getenv(&#39;OSS_TEST_ENDPOINT&#39;, &#39;&lt;你的访问域名&gt;&#39;)


# 确认上面的参数都填写正确了
for param in (access_key_id, access_key_secret, bucket_name, endpoint):
    assert &#39;&lt;&#39; not in param, &#39;请设置参数：&#39; + param

def percentage(consumed_bytes, total_bytes):
    &quot;&quot;&quot;进度条回调函数，计算当前完成的百分比

    :param consumed_bytes: 已经上传/下载的数据量
    :param total_bytes: 总数据量
    &quot;&quot;&quot;
    if total_bytes:
        rate = int(100 * (float(consumed_bytes) / float(total_bytes)))
        print(&#39;\r&#123;0&#125;% &#39;.format(rate))
        sys.stdout.flush()

def _prepare_temp_file(content):
    &quot;&quot;&quot;创建临时文件
    :param content: 文件内容
    :return 文件名
    &quot;&quot;&quot;
    fd, pathname = tempfile.mkstemp(suffix=&#39;exam-progress-&#39;)
    os.write(fd, content)
    os.close(fd)
    return pathname

key = &#39;story.txt&#39;
content = &#39;a&#39; * 1024 * 1024

# 创建Bucket对象，所有Object相关的接口都可以通过Bucket对象来进行
bucket = oss2.Bucket(oss2.Auth(access_key_id, access_key_secret), endpoint, bucket_name)

&quot;&quot;&quot;
流式上传
&quot;&quot;&quot;
# 带有进度条的覆盖上传
bucket.put_object(key, content, progress_callback=percentage)

# 删除上传的文件
bucket.delete_object(key)

&quot;&quot;&quot;
追加上传
&quot;&quot;&quot;
# 带有进度条的追加上传，每一次追加一个进度条
# 创建可追加文件，首次偏移（position）设为0
result = bucket.append_object(key, 0, content, progress_callback=percentage)
# 追加一行数据，偏移可以从上次响应中获得
# 当然，也可以通过head_object()获得当前长度作为偏移，只是比较低效
bucket.append_object(key, result.next_position, content, progress_callback=percentage)

# 删除上传的文件
bucket.delete_object(key)

&quot;&quot;&quot;
分片上传
&quot;&quot;&quot;
# 带有进度条的分片上传，每个分片上传一个进度条
parts = []
upload_id = bucket.init_multipart_upload(key).upload_id

# 上传分片
for i in range(3):
    result = bucket.upload_part(key, upload_id, i+1, content, progress_callback=percentage)
    parts.append(oss2.models.PartInfo(i+1, result.etag, size = len(content), part_crc = result.crc))

# 完成上传并回调
result = bucket.complete_multipart_upload(key, upload_id, parts)

&quot;&quot;&quot;
断点续传上传
&quot;&quot;&quot;
# 带进度条的断点续传
pathname = _prepare_temp_file(content)
oss2.resumable_upload(bucket, key, pathname, 
                      multipart_threshold=200*1024,
                      part_size=100*1024,
                      num_threads=3,
                      progress_callback=percentage)

&quot;&quot;&quot;
文件下载
&quot;&quot;&quot;
# 带进度条的下载
result = bucket.get_object(key, progress_callback=percentage)
content_got = b&#39;&#39;
for chunk in result:
    content_got += chunk
assert content == content_got

&quot;&quot;&quot;
范围下载
&quot;&quot;&quot;
# 带进度条的范围下载
result = bucket.get_object(key, byte_range=(1024, 2047), progress_callback=percentage)
content_got = b&#39;&#39;
for chunk in result:
    content_got += chunk
assert &#39;a&#39;*1024 == content_got

&quot;&quot;&quot;
断点续传下载 
&quot;&quot;&quot;
# 带进度条的断点续传下载 
filename = &#39;download.txt&#39;
oss2.resumable_download(bucket, key, filename,
                        multiget_threshold=200*1024,
                        part_size=100*1024,
                        num_threads=3,
                        progress_callback=percentage) 
os.remove(filename)

# 删除上传的文件
bucket.delete_object(key)</code></pre>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>OSS</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB数据库笔记</title>
    <url>/2019/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li>MongoDB数据库的安装</li>
<li>MongoDB数据库的使用</li>
<li>Python操作库pymongo的安装及使用</li>
</ul>
<a id="more"></a>

<h2 id="MongoDB的安装"><a href="#MongoDB的安装" class="headerlink" title="MongoDB的安装"></a>MongoDB的安装</h2><p>MongoDB 源码及安装包下载地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG93bmxvYWQtY2VudGVyI2NvbW11bml0eQ==">https://www.mongodb.com/download-center#community<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>比若说下载Ubuntu 下的安装包方法如下：</p>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200903145040.jpg"></p>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200903145100.jpg"></p>
<p>当我们得到下载链接后</p>
<pre><code class="line-numbers language-bash">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-4.2.8.tgz    # 下载
tar -zxvf mongodb-linux-x86_64-ubuntu1604-4.2.8.tgz        # 解压

mv mongodb-src-r4.2.8  /opt/mongo        # 将解压包拷贝到指定目录</code></pre>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>MongoDB 的可执行文件位于文件夹的bin 目录下，所以可以将其添加到系统环境变量 <strong>PATH</strong> 中：</p>
<pre><code class="line-numbers language-bash">vim /etc/profile.d/mongo.sh</code></pre>
<pre><code class="line-numbers language-bash">export PATH=/opt/mongo/bin:$PATH</code></pre>
<pre><code class="line-numbers language-bash">source /etc/profile.d/mongo.sh</code></pre>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><pre><code class="line-numbers language-bash">/etc/mongod.conf.orig</code></pre>
<pre><code class="line-numbers language-yaml"># mongod.conf

# Where and how to store data.
storage:
  dbPath: /var/lib/mongodb
  journal:
    enabled: true

# where to write logging data.
systemLog:
  destination: file
  logAppend: true
  path: /var/log/mongodb/mongod.log

# network interfaces
net:
  port: 27017
  bindIp: 127.0.0.1</code></pre>
<h3 id="MongoShell"><a href="#MongoShell" class="headerlink" title="MongoShell"></a>MongoShell</h3><p>Mongosh是MongoDB自带javascript shell, 可在shell中使用命令行与MongoDB实列交互，可以执行管理操作，检查运行实列等等操作。</p>
<p>当我们使用docker部署mongodb时，可以在宿主机上单独配置mongoshell使用，下载地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cubW9uZ29kYi5jb20vdHJ5L2Rvd25sb2FkL3NoZWxs">https://www.mongodb.com/try/download/shell<i class="fa fa-external-link-alt"></i></span></p>
<p>下载得到的压缩包解压后得到的是一个可执行文件<code>mongosh</code>，直接使用即可进行连接，默认输出 ：</p>
<pre><code class="line-numbers language-shell">$ mongosh
Current sessionID:  52c39be56c73153cee1840d7
Connecting to:      mongodb://127.0.0.1:27017
Using MongoDB:      4.4.0
Using Mongosh Beta: 0.2.2

For more information about mongosh, please see our docs: https://docs.mongodb.com/mongodb-shell/

&gt; &lt;your_order&gt;</code></pre>
<p>URL连接</p>
<pre><code class="line-numbers language-bash">#  Start mongosh using &#39;ships&#39; database on specified connection string:
$ mongosh mongodb://192.168.0.5:9999/ships</code></pre>
<p>连接选项帮助</p>
<pre><code class="line-numbers language-bash">$ mongosh --help</code></pre>
<h2 id="MongoDB使用方法"><a href="#MongoDB使用方法" class="headerlink" title="MongoDB使用方法"></a>MongoDB使用方法</h2><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>我想创建一个scrapy数据库，其中有一个info集合（类mysql表），添加以下数据</p>
<table>
<thead>
<tr>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>15</td>
</tr>
<tr>
<td>李四</td>
<td>16</td>
</tr>
<tr>
<td>王五</td>
<td>17</td>
</tr>
</tbody></table>
<p>mongosh代码</p>
<pre><code class="line-numbers language-shell">&gt; db    # 显示当前数据库
# test

&gt; use scrapy    # 创建/选择scrapy数据库
# switched to db scrapy

&gt; show dbs        # 显示所有数据库，不包含空库
# admin    102 kB
# config   111 kB
# local   73.7 kB</code></pre>
<p>插入数据</p>
<pre><code class="line-numbers language-bash"># 插入数据行1
&gt; db.info.insert(&#123;&quot;name&quot;:&quot;张三&quot;, &quot;age&quot;:&quot;15&quot;&#125;)        
&#123;
  acknowledged: 1,
  insertedIds: &#123; &#39;0&#39;: ObjectId(&quot;5f50a59ee4c079078fab16f4&quot;) &#125;
&#125;

# 插入数据行2
&gt; db.info.insert(&#123;&quot;name&quot;:&quot;李四&quot;, &quot;age&quot;:&quot;16&quot;&#125;)        
&#123;
  acknowledged: 1,
  insertedIds: &#123; &#39;0&#39;: ObjectId(&quot;5f50a59ee4c079078fab16f4&quot;) &#125;
&#125;

# 插入数据行3
&gt; db.info.insert(&#123;&quot;name&quot;:&quot;王五&quot;, &quot;age&quot;:&quot;17&quot;&#125;)        
&#123;
  acknowledged: 1,
  insertedIds: &#123; &#39;0&#39;: ObjectId(&quot;5f50a59ee4c079078fab16f4&quot;) &#125;
&#125;</code></pre>
<p>查看数据</p>
<pre><code class="line-numbers language-bash">&gt; db.info.find()
# [
#   &#123; _id: ObjectId(&quot;5f50a88fe8320e0817d3c1c2&quot;), name: &#39;张三&#39;, age: &#39;15&#39; &#125;,
#   &#123; _id: ObjectId(&quot;5f50a892e8320e0817d3c1c3&quot;), name: &#39;李四&#39;, age: &#39;16&#39; &#125;,
#   &#123; _id: ObjectId(&quot;5f50a896e8320e0817d3c1c4&quot;), name: &#39;王五&#39;, age: &#39;17&#39; &#125;
# ]</code></pre>
<p>删除集合、数据库</p>
<pre><code class="line-numbers language-bash">db.info.drop()        # true
db.dropDatabase()        # &#123; ok: 1, dropped: &#39;scrapy&#39; &#125;</code></pre>
<h3 id="更新文档数据"><a href="#更新文档数据" class="headerlink" title="更新文档数据"></a>更新文档数据</h3><p>首先我们在test集合里插入测试数据</p>
<pre><code class="line-numbers language-bash">use test
db.test_collection.insert( [
&#123;&quot;name&quot;:&quot;abc&quot;,&quot;age&quot;:&quot;25&quot;,&quot;status&quot;:&quot;zxc&quot;&#125;,
&#123;&quot;name&quot;:&quot;dec&quot;,&quot;age&quot;:&quot;19&quot;,&quot;status&quot;:&quot;qwe&quot;&#125;,
&#123;&quot;name&quot;:&quot;asd&quot;,&quot;age&quot;:&quot;30&quot;,&quot;status&quot;:&quot;nmn&quot;&#125;,
] )</code></pre>
<p>更新单个文档</p>
<pre><code class="line-numbers language-bash">&gt; db.test_collection.updateOne(&#123;&quot;name&quot;:&quot;abc&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:&quot;28&quot;&#125;&#125;)
&#123; &quot;acknowledged&quot; : true, &quot;matchedCount&quot; : 1, &quot;modifiedCount&quot; : 1 &#125;
&gt; db.test_collection.find()
&#123; &quot;_id&quot; : ObjectId(&quot;59c8ba673b92ae498a5716af&quot;), &quot;name&quot; : &quot;abc&quot;, &quot;age&quot; : &quot;28&quot;, &quot;status&quot; : &quot;zxc&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;59c8ba673b92ae498a5716b0&quot;), &quot;name&quot; : &quot;dec&quot;, &quot;age&quot; : &quot;19&quot;, &quot;status&quot; : &quot;qwe&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;59c8ba673b92ae498a5716b1&quot;), &quot;name&quot; : &quot;asd&quot;, &quot;age&quot; : &quot;30&quot;, &quot;status&quot; : &quot;nmn&quot; &#125;
&gt;</code></pre>
<p>更新多个文档</p>
<pre><code class="line-numbers language-bash">&gt; db.test_collection.updateMany(&#123;&quot;age&quot;:&#123;$gt:&quot;10&quot;&#125;&#125;,&#123;$set:&#123;&quot;status&quot;:&quot;xyz&quot;&#125;&#125;)
&#123; &quot;acknowledged&quot; : true, &quot;matchedCount&quot; : 3, &quot;modifiedCount&quot; : 3 &#125;
&gt; db.test_collection.find()
&#123; &quot;_id&quot; : ObjectId(&quot;59c8ba673b92ae498a5716af&quot;), &quot;name&quot; : &quot;abc&quot;, &quot;age&quot; : &quot;28&quot;, &quot;status&quot; : &quot;xyz&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;59c8ba673b92ae498a5716b0&quot;), &quot;name&quot; : &quot;dec&quot;, &quot;age&quot; : &quot;19&quot;, &quot;status&quot; : &quot;xyz&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;59c8ba673b92ae498a5716b1&quot;), &quot;name&quot; : &quot;asd&quot;, &quot;age&quot; : &quot;30&quot;, &quot;status&quot; : &quot;xyz&quot; &#125;
&gt;</code></pre>
<h3 id="删除集合数据"><a href="#删除集合数据" class="headerlink" title="删除集合数据"></a>删除集合数据</h3><p>如删除集合下全部文档：</p>
<pre><code class="line-numbers language-bash">db.inventory.deleteMany(&#123;&#125;)</code></pre>
<p>删除 status 等于 A 的全部文档：</p>
<pre><code class="line-numbers language-bash">db.inventory.deleteMany(&#123; status : &quot;A&quot; &#125;)</code></pre>
<p>删除 status 等于 D 的一个文档：</p>
<pre><code class="line-numbers language-bash">db.inventory.deleteOne( &#123; status: &quot;D&quot; &#125; )</code></pre>
<h2 id="pymongo的使用（PythonSDK）"><a href="#pymongo的使用（PythonSDK）" class="headerlink" title="pymongo的使用（PythonSDK）"></a>pymongo的使用（PythonSDK）</h2><h3 id="pymongo的安装"><a href="#pymongo的安装" class="headerlink" title="pymongo的安装"></a>pymongo的安装</h3><p>使用pip安装</p>
<pre><code class="line-numbers language-bash">python -m pip install pymongo</code></pre>
<p>使用setuptools安装</p>
<pre><code class="line-numbers language-bash">python -m easy_install pymongo</code></pre>
<p>显示python版本</p>
<pre><code class="line-numbers language-bash">python -c &quot;import sys; print(sys.version)&quot;</code></pre>
<p>显示pymongo版本</p>
<pre><code class="line-numbers language-bash">python -c &quot;import pymongo; print(pymongo.version); print(pymongo.has_c())&quot;</code></pre>
<h3 id="pymongo常用方法"><a href="#pymongo常用方法" class="headerlink" title="pymongo常用方法"></a>pymongo常用方法</h3><p>官方文档：<span class="exturl" data-url="aHR0cDovL2FwaS5tb25nb2RiLmNvbS9weXRob24vY3VycmVudC9hcGkvcHltb25nby8=">http://api.mongodb.com/python/current/api/pymongo/<i class="fa fa-external-link-alt"></i></span></p>
<pre><code class="line-numbers language-python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
&quot;&quot;&quot;
连接MongoDB
    连接MongoDB我们需要使用PyMongo库里面的MongoClient，一般来说传入MongoDB的IP及端口即可，
    第一个参数为地址host，第二个参数为端口port，端口如果不传默认是27017。
&quot;&quot;&quot;
import pymongo


# 连接数据库
# 指定属性值
client = pymongo.MongoClient(host=&#39;localhost&#39;, port=27017)
# MongoClient的第一个参数host还可以直接传MongoDB的连接字符串，以mongodb开头，
client = pymongo.MongoClient(&#39;mongodb://localhost:27017/&#39;)


# 指定数据库
# 调用client的test属性即可返回test数据库，或者以字典方式指定，两种方式是等价的。
db = client.test
db = client[&#39;test&#39;]


# 指定集合
# MongoDB的每个数据库又包含了许多集合Collection，也就类似与关系型数据库中的表，下一步我们需要指定要操作的集合，
# 在这里我们指定一个集合名称为students，学生集合。还是和指定数据库类似，指定集合也有两种方式。
collection = db.students
collection = db[&#39;students&#39;]


# 插入数据
# 对于students这个Collection，我们新建一条学生数据，以字典的形式表示：
student = &#123;
    &#39;id&#39;: &#39;20170101&#39;,
    &#39;name&#39;: &#39;Jordan&#39;,
    &#39;age&#39;: 20,
    &#39;gender&#39;: &#39;male&#39;
&#125;


# 在这里我们指定了学生的学号、姓名、年龄和性别，然后接下来直接调用collection的insert()方法即可插入数据。 
result = collection.insert(student)
print(result)
# 在MongoDB中，每条数据其实都有一个_id属性来唯一标识，如果没有显式指明_id，MongoDB会自动产生一个ObjectId类型的_id属性。
# insert()方法会在执行后返回的_id值。

# 运行结果：
# 5932a68615c2606814c91f3d
# 当然我们也可以同时插入多条数据，只需要以列表形式传递即可，示例如下：

student1 = &#123;
    &#39;id&#39;: &#39;20170101&#39;,
    &#39;name&#39;: &#39;Jordan&#39;,
    &#39;age&#39;: 20,
    &#39;gender&#39;: &#39;male&#39;
&#125;

student2 = &#123;
    &#39;id&#39;: &#39;20170202&#39;,
    &#39;name&#39;: &#39;Mike&#39;,
    &#39;age&#39;: 21,
    &#39;gender&#39;: &#39;male&#39;
&#125;

result = collection.insert([student1, student2])
print(result)
# 返回的结果是对应的_id的集合，运行结果：
# [ObjectId(&#39;5932a80115c2606a59e8a048&#39;), ObjectId(&#39;5932a80115c2606a59e8a049&#39;)]
# 实际上在PyMongo 3.X版本中，insert()方法官方已经不推荐使用了，当然继续使用也没有什么问题，
# 官方推荐使用insert_one()和insert_many()方法将插入单条和多条记录分开。

student = &#123;
    &#39;id&#39;: &#39;20170101&#39;,
    &#39;name&#39;: &#39;Jordan&#39;,
    &#39;age&#39;: 20,
    &#39;gender&#39;: &#39;male&#39;
&#125;

result = collection.insert_one(student)
print(result)
print(result.inserted_id)
# 运行结果：
# &lt;pymongo.results.InsertOneResult object at 0x10d68b558&gt;
# 5932ab0f15c2606f0c1cf6c5
# 返回结果和insert()方法不同，这次返回的是InsertOneResult对象，我们可以调用其inserted_id属性获取_id。

# 对于insert_many()方法，我们可以将数据以列表形式传递即可，示例如下：

student1 = &#123;
    &#39;id&#39;: &#39;20170101&#39;,
    &#39;name&#39;: &#39;Jordan&#39;,
    &#39;age&#39;: 20,
    &#39;gender&#39;: &#39;male&#39;
&#125;

student2 = &#123;
    &#39;id&#39;: &#39;20170202&#39;,
    &#39;name&#39;: &#39;Mike&#39;,
    &#39;age&#39;: 21,
    &#39;gender&#39;: &#39;male&#39;
&#125;

result = collection.insert_many([student1, student2])
print(result)
print(result.inserted_ids)
# insert_many()方法返回的类型是InsertManyResult，调用inserted_ids属性可以获取插入数据的_id列表，运行结果：

# &lt;pymongo.results.InsertManyResult object at 0x101dea558&gt;
# [ObjectId(&#39;5932abf415c2607083d3b2ac&#39;), ObjectId(&#39;5932abf415c2607083d3b2ad&#39;)]
# 查询，插入数据后我们可以利用find_one()或find()方法进行查询，find_one()查询得到是单个结果，find()则返回多个结果。

result = collection.find_one(&#123;&#39;name&#39;: &#39;Mike&#39;&#125;)
print(type(result))
print(result)
# 在这里我们查询name为Mike的数据，它的返回结果是字典类型，运行结果：
# &lt;class&#39;dict&#39;&gt;
# &#123;&#39;_id&#39;: ObjectId(&#39;5932a80115c2606a59e8a049&#39;), &#39;id&#39;: &#39;20170202&#39;, &#39;name&#39;: &#39;Mike&#39;, &#39;age&#39;: 21, &#39;gender&#39;: &#39;male&#39;&#125;
# 可以发现它多了一个_id属性，这就是MongoDB在插入的过程中自动添加的。

# 我们也可以直接根据ObjectId来查询，这里需要使用bson库里面的ObjectId。

from bson.objectid import ObjectId

result = collection.find_one(&#123;&#39;_id&#39;: ObjectId(&#39;593278c115c2602667ec6bae&#39;)&#125;)
print(result)
# 其查询结果依然是字典类型，运行结果：

# &#123;&#39; ObjectId(&#39;593278c115c2602667ec6bae&#39;), &#39;id&#39;: &#39;20170101&#39;, &#39;name&#39;: &#39;Jordan&#39;, &#39;age&#39;: 20, &#39;gender&#39;: &#39;male&#39;&#125;
# 当然如果查询_id&#39;:结果不存在则会返回None。

# 对于多条数据的查询，我们可以使用find()方法，例如在这里查找年龄为20的数据，示例如下：

results = collection.find(&#123;&#39;age&#39;: 20&#125;)
print(results)
for result in results:
    print(result)
# 运行结果：

# &lt;pymongo.cursor.Cursor object at 0x1032d5128&gt;
# &#123;&#39;_id&#39;: ObjectId(&#39;593278c115c2602667ec6bae&#39;), &#39;id&#39;: &#39;20170101&#39;, &#39;name&#39;: &#39;Jordan&#39;, &#39;age&#39;: 20, &#39;gender&#39;: &#39;male&#39;&#125;
# &#123;&#39;_id&#39;: ObjectId(&#39;593278c815c2602678bb2b8d&#39;), &#39;id&#39;: &#39;20170102&#39;, &#39;name&#39;: &#39;Kevin&#39;, &#39;age&#39;: 20, &#39;gender&#39;: &#39;male&#39;&#125;
# &#123;&#39;_id&#39;: ObjectId(&#39;593278d815c260269d7645a8&#39;), &#39;id&#39;: &#39;20170103&#39;, &#39;name&#39;: &#39;Harden&#39;, &#39;age&#39;: 20, &#39;gender&#39;: &#39;male&#39;&#125;
# 返回结果是Cursor类型，相当于一个生成器，我们需要遍历取到所有的结果，每一个结果都是字典类型。

# 如果要查询年龄大于20的数据，则写法如下：

results = collection.find(&#123;&#39;age&#39;: &#123;&#39;$gt&#39;: 20&#125;&#125;)
# 在这里查询的条件键值已经不是单纯的数字了，而是一个字典，其键名为比较符号$gt，意思是大于，键值为20，这样便可以查询出所有
# 年龄大于20的数据。

# 在这里将比较符号归纳如下表：
&quot;&quot;&quot;
符号含义示例
$lt小于&#123;&#39;age&#39;: &#123;&#39;$lt&#39;: 20&#125;&#125;
$gt大于&#123;&#39;age&#39;: &#123;&#39;$gt&#39;: 20&#125;&#125;
$lte小于等于&#123;&#39;age&#39;: &#123;&#39;$lte&#39;: 20&#125;&#125;
$gte大于等于&#123;&#39;age&#39;: &#123;&#39;$gte&#39;: 20&#125;&#125;
$ne不等于&#123;&#39;age&#39;: &#123;&#39;$ne&#39;: 20&#125;&#125;
$in在范围内&#123;&#39;age&#39;: &#123;&#39;$in&#39;: [20, 23]&#125;&#125;
$nin不在范围内&#123;&#39;age&#39;: &#123;&#39;$nin&#39;: [20, 23]&#125;&#125;
&quot;&quot;&quot;
# 另外还可以进行正则匹配查询，例如查询名字以M开头的学生数据，示例如下：

results = collection.find(&#123;&#39;name&#39;: &#123;&#39;$regex&#39;: &#39;^M.*&#39;&#125;&#125;)
# 在这里使用了$regex来指定正则匹配，^M.*代表以M开头的正则表达式，这样就可以查询所有符合该正则的结果。

# 在这里将一些功能符号再归类如下：
&quot;&quot;&quot;
符号含义示例示例含义
$regex匹配正则&#123;&#39;name&#39;: &#123;&#39;$regex&#39;: &#39;^M.*&#39;&#125;&#125;name以M开头
$exists属性是否存在&#123;&#39;name&#39;: &#123;&#39;$exists&#39;: True&#125;&#125;name属性存在
$type类型判断&#123;&#39;age&#39;: &#123;&#39;$type&#39;: &#39;int&#39;&#125;&#125;age的类型为int
$mod数字模操作&#123;&#39;age&#39;: &#123;&#39;$mod&#39;: [5, 0]&#125;&#125;年龄模5余0
$text文本查询&#123;&#39;$text&#39;: &#123;&#39;$search&#39;: &#39;Mike&#39;&#125;&#125;text类型的属性中包含Mike字符串
$where高级条件查询&#123;&#39;$where&#39;: &#39;obj.fans_count == obj.follows_count&#39;&#125;自身粉丝数等于关注数
&quot;&quot;&quot;
# 这些操作的更详细用法在可以在MongoDB官方文档找到：
# https://docs.mongodb.com/manual/reference/operator/query/

# 计数
# 要统计查询结果有多少条数据，可以调用count()方法，如统计所有数据条数：

count = collection.find().count()
print(count)
# 或者统计符合某个条件的数据：

count = collection.find(&#123;&#39;age&#39;: 20&#125;).count()
print(count)
# 排序
# 可以调用sort方法，传入排序的字段及升降序标志即可，示例如下：

results = collection.find().sort(&#39;name&#39;, pymongo.ASCENDING)
print([result[&#39;name&#39;] for result in results])
# 运行结果：

# [&#39;Harden&#39;, &#39;Jordan&#39;, &#39;Kevin&#39;, &#39;Mark&#39;, &#39;Mike&#39;]
# 偏移,可能想只取某几个元素，在这里可以利用skip()方法偏移几个位置，比如偏移2，就忽略前2个元素，得到第三个及以后的元素。

results = collection.find().sort(&#39;name&#39;, pymongo.ASCENDING).skip(2)
print([result[&#39;name&#39;] for result in results])
# 运行结果：
# [&#39;Kevin&#39;, &#39;Mark&#39;, &#39;Mike&#39;]
# 另外还可以用limit()方法指定要取的结果个数，示例如下：

results = collection.find().sort(&#39;name&#39;, pymongo.ASCENDING).skip(2).limit(2)
print([result[&#39;name&#39;] for result in results])
# 运行结果：
# [&#39;Kevin&#39;, &#39;Mark&#39;]
# 如果不加limit()原本会返回三个结果，加了限制之后，会截取2个结果返回。

# 值得注意的是，在数据库数量非常庞大的时候，如千万、亿级别，最好不要使用大的偏移量来查询数据，很可能会导致内存溢出，
# 可以使用类似find(&#123;&#39;_id&#39;: &#123;&#39;$gt&#39;: ObjectId(&#39;593278c815c2602678bb2b8d&#39;)&#125;&#125;) 这样的方法来查询，记录好上次查询的_id。

# 更新
# 对于数据更新可以使用update()方法，指定更新的条件和更新后的数据即可，例如：

condition = &#123;&#39;name&#39;: &#39;Kevin&#39;&#125;
student = collection.find_one(condition)
student[&#39;age&#39;] = 25
result = collection.update(condition, student)
print(result)
# 在这里我们将name为Kevin的数据的年龄进行更新，首先指定查询条件，然后将数据查询出来，修改年龄，
# 之后调用update方法将原条件和修改后的数据传入，即可完成数据的更新。

# 运行结果：

# &#123;&#39;ok&#39;: 1, &#39;nModified&#39;: 1, &#39;n&#39;: 1, &#39;updatedExisting&#39;: True&#125;
# 返回结果是字典形式，ok即代表执行成功，nModified代表影响的数据条数。

# 另外update()方法其实也是官方不推荐使用的方法，在这里也分了update_one()方法和update_many()方法，用法更加严格，
# 第二个参数需要使用$类型操作符作为字典的键名，我们用示例感受一下。

condition = &#123;&#39;name&#39;: &#39;Kevin&#39;&#125;
student = collection.find_one(condition)
student[&#39;age&#39;] = 26
result = collection.update_one(condition, &#123;&#39;$set&#39;: student&#125;)
print(result)
print(result.matched_count, result.modified_count)
# 在这里调用了update_one方法，第二个参数不能再直接传入修改后的字典，而是需要使用&#123;&#39;$set&#39;: student&#125;这样的形式，
# 其返回结果是UpdateResult类型，然后调用matched_count和modified_count属性分别可以获得匹配的数据条数和影响的数据条数。

# 运行结果：
#
# &lt;pymongo.results.UpdateResult object at 0x10d17b678&gt;
# 1 0
# 我们再看一个例子：

condition = &#123;&#39;age&#39;: &#123;&#39;$gt&#39;: 20&#125;&#125;
result = collection.update_one(condition, &#123;&#39;$inc&#39;: &#123;&#39;age&#39;: 1&#125;&#125;)
print(result)
print(result.matched_count, result.modified_count)
# 在这里我们指定查询条件为年龄大于20，然后更新条件为&#123;&#39;$inc&#39;: &#123;&#39;age&#39;: 1&#125;&#125;，执行之后会讲第一条符合条件的数据年龄加1。

# 运行结果：
#
# &lt;pymongo.results.UpdateResult object at 0x10b8874c8&gt;
# 1 1
# 可以看到匹配条数为1条，影响条数也为1条。

# 如果调用update_many()方法，则会将所有符合条件的数据都更新，示例如下：

condition = &#123;&#39;age&#39;: &#123;&#39;$gt&#39;: 20&#125;&#125;
result = collection.update_many(condition, &#123;&#39;$inc&#39;: &#123;&#39;age&#39;: 1&#125;&#125;)
print(result)
print(result.matched_count, result.modified_count)
# 这时候匹配条数就不再为1条了，运行结果如下：
#
# &lt;pymongo.results.UpdateResult object at 0x10c6384c8&gt;
# 3 3
# 可以看到这时所有匹配到的数据都会被更新。

# 删除
# 删除操作比较简单，直接调用remove()方法指定删除的条件即可，符合条件的所有数据均会被删除，示例如下：

result = collection.remove(&#123;&#39;name&#39;: &#39;Kevin&#39;&#125;)
print(result)
# 运行结果：
#
# &#123;&#39;ok&#39;: 1, &#39;n&#39;: 1&#125;
# 另外依然存在两个新的推荐方法，delete_one()和delete_many()方法，示例如下：

result = collection.delete_one(&#123;&#39;name&#39;: &#39;Kevin&#39;&#125;)
print(result)
print(result.deleted_count)
result = collection.delete_many(&#123;&#39;age&#39;: &#123;&#39;$lt&#39;: 25&#125;&#125;)
print(result.deleted_count)
# 运行结果：

# &lt;pymongo.results.DeleteResult object at 0x10e6ba4c8&gt;
# 1
# 4
# delete_one()即删除第一条符合条件的数据，delete_many()即删除所有符合条件的数据，返回结果是DeleteResult类型，
# 可以调用deleted_count属性获取删除的数据条数。

# 更多
# 另外PyMongo还提供了一些组合方法，如find_one_and_delete()、find_one_and_replace()、find_one_and_update()，
# 就是查找后删除、替换、更新操作，用法与上述方法基本一致。

# 另外还可以对索引进行操作，如create_index()、create_indexes()、drop_index()等。</code></pre>
]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python常用代码语句说明及使用</title>
    <url>/2019/Python/Python%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p><a href="#continue">continue</a>、<a href="#break">break</a>、<a href="#return">return</a>、<a href="#pass">pass</a>、<a href="#raise">raise</a>、<a href="#assert">assert</a>、<a href="#yield">yield</a></p>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy43L3JlZmVyZW5jZS9zaW1wbGVfc3RtdHMuaHRtbA==">Python3.7官方手册<i class="fa fa-external-link-alt"></i></span> </p>
<a id="more"></a>

<hr>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>适用于 <code>while</code>与 <code>for</code>语句，在设置的条件下跳过本次循环并继续执行下个循环</p>
<pre><code class="line-numbers language-python">for i in range(10):
    if i%2==0:
        continue
    print(i, end=&quot;, &quot;)</code></pre>
<pre><code>1, 3, 5, 7, 9,</code></pre>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>类似continue，作用为条件下结束循环体</p>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>函数的返回值，返回给调用者一个表达式结果，默认为None</p>
<h3 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h3><p>适合当语法上需要一条语句但并不需要执行任何代码时用来临时占位</p>
<pre><code class="line-numbers language-python">def pass():
    pass    # 什么都没有发生</code></pre>
<h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h3><p>主动的抛出一个异常，Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数，tracback为跟踪异常对象（可选）。</p>
<pre><code class="line-numbers language-python">raise [Exception [, args [, traceback]]]</code></pre>
<p>使用逻辑</p>
<pre><code class="line-numbers language-python">try:
    正常逻辑
except Exception[ as f]:
    触发自定义异常    
else:
    其余代码</code></pre>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>根据Python<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9yZWZlcmVuY2Uvc2ltcGxlX3N0bXRzLmh0bWwjYXNzZXJ0">官方文档<i class="fa fa-external-link-alt"></i></span>说明：Assert statements are a convenient way to insert debugging assertions into a program，也就是说，assert是一种断点测试的方法，使用assert断言是一个非常好的习惯，在没完善一个程序之前，我们不知道程序在哪里会出错，与其让它在运行最崩溃，不如在出现错误条件时就崩溃，避免debug时找不到头尾</p>
<h4 id="断言的使用"><a href="#断言的使用" class="headerlink" title="断言的使用"></a>断言的使用</h4><p>使用语法为：</p>
<pre><code class="line-numbers language-python">assert expression
assert 表达式</code></pre>
<p>当程序运行到assert会进行bool测试，如果condition为false，那么raise一个AssertionError出来。逻辑上等同于：</p>
<pre><code class="line-numbers language-python">if not condition:
    raise AssertionError()</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200912175327.png"></p>
<h4 id="断言的异常参数"><a href="#断言的异常参数" class="headerlink" title="断言的异常参数"></a>断言的异常参数</h4><p>assert的异常参数，其实就是在断言表达式后添加字符串信息，用来解释断言并更好的知道是哪里出了问题。格式如下：</p>
<pre><code class="line-numbers language-python">assert expression [, arguments]
assert 表达式 [, 参数]</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200912175924.png"></p>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>等同于yield表达式，创建一个<strong>生成器函数</strong>而非普通函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200912181117.png"></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据库·概念相关</title>
    <url>/2019/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E7%AC%94%E8%AE%B0%C2%B7%E6%A6%82%E5%BF%B5%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统，使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
<ul>
<li>Redis的安装与配置</li>
<li>常用配置文件</li>
<li>Redis的工作模式</li>
<li>···</li>
</ul>
<a id="more"></a>

<h2 id="Redis安装与配置"><a href="#Redis安装与配置" class="headerlink" title="Redis安装与配置"></a>Redis安装与配置</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>进入Redis.io选择需要的安装包下载安装即可，官网下载地址：<span class="exturl" data-url="aHR0cHM6Ly9yZWRpcy5pby9kb3dubG9hZA==">https://redis.io/download<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200913182909.png"></p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><pre><code class="line-numbers language-bash">apt install redis    # server+client
apt install redis-server    # server
apt install redis-tools        # client</code></pre>
<p>默认配置文件：<code> /etc/redis/redis.conf</code></p>
<p>客户端启动：<code>redis-cli</code></p>
<h3 id="使用源码启动服务"><a href="#使用源码启动服务" class="headerlink" title="使用源码启动服务"></a>使用源码启动服务</h3><p><span class="exturl" data-url="aHR0cDovL2Rvd25sb2FkLnJlZGlzLmlvL3JlbGVhc2VzLw==">http://download.redis.io/releases/<i class="fa fa-external-link-alt"></i></span> ，下载需要版本的源码，使用步骤如下：</p>
<pre><code class="line-numbers language-bash">wget http://download.redis.io/releases/redis-5.0.0.tar.gz
tar redis-5.0.0.tar.gz
cd redis-5.0.0
make</code></pre>
<p>启动服务</p>
<pre><code class="line-numbers language-bash">redis-5.0.0/src/redis-server /etc/redis/redis.conf</code></pre>
<p><img src="C:\Users\yuan\AppData\Roaming\Typora\typora-user-images\image-20200913184519375.png" alt="image-20200913184519375"></p>
<p>启动客户端</p>
<pre><code>redis-5.0.0/src/redis-cli</code></pre>
<h2 id="常用配置文件"><a href="#常用配置文件" class="headerlink" title="常用配置文件"></a>常用配置文件</h2><pre><code class="line-numbers language-bash">vim /etc/redis/redis.conf</code></pre>
<pre><code class="line-numbers language-json">bind 0.0.0.0                            # 允许任意IP地址访问
protected-mode no                        # 不需要密码就能访问
port 6379                                # 使用的TCP端口
tcp-backlog 511
timeout 0                                # 不超时
tcp-keepalive 300                        # TCP连接保持时间,5min
supervised no
pidfile /var/run/redis_6379.pid
loglevel notice
logfile &quot;&quot;
databases 16
always-show-logo yes
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
dir ./
slave-serve-stale-data yes
slave-read-only yes
repl-diskless-sync no
repl-diskless-sync-delay 5
repl-disable-tcp-nodelay no
slave-priority 100
lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
slave-lazy-flush no
appendonly no
appendfilename &quot;appendonly.aof&quot;
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
aof-load-truncated yes
aof-use-rdb-preamble no
lua-time-limit 5000
slowlog-log-slower-than 10000
slowlog-max-len 128
latency-monitor-threshold 0
notify-keyspace-events &quot;&quot;
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-size -2
list-compress-depth 0
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
hll-sparse-max-bytes 3000
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
aof-rewrite-incremental-fsync yes</code></pre>
<h2 id="Redis的工作模式"><a href="#Redis的工作模式" class="headerlink" title="Redis的工作模式"></a>Redis的工作模式</h2><p>和 MySQL 类似，Redis 系统地包括服务器端（redis-server）和客户端（redis-cli）两个角色R， 服务器通常使用 TCP 端口 6379，客户端和服务器通过 RESP 协议通信，如图 </p>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200913212940.gif"></p>
<p>其常用的工作模式是客户端发送一个请求，服务器处理该请求，然后将结果返回给客户端，</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200913213259.png"></p>
<p>另外一种工作模式是管道（pipelining）模式，其不等待前面的回应消息就发送下一条请求以提升吞吐量</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200913213350.png"></p>
<p>第三种工作模式是订阅模式，就是客户端先告诉服务器其关心哪些数据，然后在这些数据发生改变时服务器主动发送消息通知客户端。在该模式中，客户端不是主动去请求某个数据，而是服务器主动通知客户端某个数据的最新值</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuandongxu97/image-repository/img/20200913213412.png"></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker快速部署多种数据库及配置使用</title>
    <url>/2019/Docker/Docker%E9%83%A8%E7%BD%B2%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<ul>
<li><strong>redis</strong></li>
<li><strong>mongodb</strong></li>
<li><strong>mysql</strong></li>
</ul>
<a id="more"></a>

<hr>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>为了方便，我们可以将MongoDB的数据目录映射到主机上来</p>
<pre><code class="line-numbers language-bash">mkdir -p /data/mongodata        # 创建数据目录</code></pre>
<p>拉取镜像</p>
<pre><code class="line-numbers language-bash">docker pull mongo</code></pre>
<p>启动MongoDB容器</p>
<pre><code class="line-numbers language-bash">docker run -d --name mongo -v /data/mongodata:/data/db -p 27017:27017 mongo --auth</code></pre>
<ul>
<li><p>–name mongo 容器名称</p>
</li>
<li><p>–v /data/mongodata:/data/db 映射数据目录</p>
</li>
<li><p>-p 27017:27017 端口映射，前面的是主机端口，后面的是docker中的端口</p>
</li>
<li><p>mongo –auth 以账号验证模式启动</p>
</li>
</ul>
<p><strong>创建账号</strong></p>
<p>创建root用户、密码为123，所有数据库读写权限</p>
<pre><code class="line-numbers language-bash">docker exec -it mongo mongo admin --eval &quot;db.createUser(&#123;user: &#39;root&#39;, pwd: &#39;123&#39;, roles: [ &#123; role: &#39;root&#39;, db: &#39;admin&#39; &#125; , &#39;readWriteAnyDatabase&#39;] &#125;)&quot;</code></pre>
<p><strong>设置随Docker启动</strong></p>
<pre><code class="line-numbers language-bash">docker update --restart=always mongo          </code></pre>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>拉取镜像</p>
<pre><code class="line-numbers language-bash">docker pull redis</code></pre>
<p>准备一份redis配置文件，我放在了<code>/etc/redis/my.conf</code>，配置项如下：</p>
<pre><code class="line-numbers language-json">bind 0.0.0.0                            # 允许任意IP地址访问
protected-mode no                        # 不需要密码就能访问
port 6379                                # 使用的TCP端口
tcp-backlog 511
timeout 0                                # 不超时
tcp-keepalive 300                        # TCP连接保持时间,5min
supervised no
pidfile /var/run/redis_6379.pid
loglevel notice
logfile &quot;&quot;
databases 16
always-show-logo yes
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
dir ./
slave-serve-stale-data yes
slave-read-only yes
repl-diskless-sync no
repl-diskless-sync-delay 5
repl-disable-tcp-nodelay no
slave-priority 100
lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
slave-lazy-flush no
appendonly no
appendfilename &quot;appendonly.aof&quot;
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
aof-load-truncated yes
aof-use-rdb-preamble no
lua-time-limit 5000
slowlog-log-slower-than 10000
slowlog-max-len 128
latency-monitor-threshold 0
notify-keyspace-events &quot;&quot;
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-size -2
list-compress-depth 0
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
hll-sparse-max-bytes 3000
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
aof-rewrite-incremental-fsync yes</code></pre>
<p>创建容器</p>
<ul>
<li>后台模式</li>
<li>映射本地16379至容器6379，也就是说redis开放在本地16379端口，避免被扫库（我太难了）</li>
<li>映射本地配置文件至容器</li>
<li>容器命名为redis16379</li>
</ul>
<pre><code class="line-numbers language-bash">docker run -d -p 16379:6379 -v /etc/redis/my.conf:/etc/redis/redis.conf --name redis16379 redis</code></pre>
<p>设置随Docker启动</p>
<pre><code class="line-numbers language-bash">docker update --restart=always redis16379     </code></pre>
<h3 id="本地连接"><a href="#本地连接" class="headerlink" title="本地连接"></a>本地连接</h3><p>安装redis-cli</p>
<pre><code class="line-numbers language-bash">apt install redis-tools</code></pre>
<pre><code class="line-numbers language-bash">redis-cli -p 16379</code></pre>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200913214746.png"></p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>需要安装指定版本的话，查看远端的版本</p>
<pre><code class="line-numbers language-bash">$ docker search mysql</code></pre>
<p>下载MySQL镜像（image）</p>
<pre><code class="line-numbers language-bash">$ docker pull mysql            # latest
$ docker pull mysql:5.7        # 5.7</code></pre>
<p>查看本地镜像</p>
<pre><code class="line-numbers language-bash">$ docker images
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
mysql                latest              c8ee894bd2bd        2 weeks ago         456MB</code></pre>
<p>先创建一个临时的mysql，进入容器中</p>
<pre><code class="line-numbers language-bash">docker run --rm --name mysqlTemp -it -v /usr/local/mysql/:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=123456 mysql /bin/bash </code></pre>
<blockquote>
<p>– rm 退出后就删除该容器<br>-v /usr/local/mysql/:/var/lib/mysql  装主机目录/usr/local/mysql/映射Docker中的/var/lib/mysql目录<br>-it 交互模式<br>/bin/bash 进入 bash 命令模式</p>
</blockquote>
<p>查看 my.cnf文件。<br>  <code>cat /etc/mysql/my.cnf</code></p>
<pre><code class="line-numbers language-bash">$ cat /etc/mysql/my.cnf

[mysqld]
pid-file        = /var/run/mysqld/mysqld.pid
socket          = /var/run/mysqld/mysqld.sock
datadir         = /var/lib/mysql
secure-file-priv= NULL

symbolic-links=0

!includedir /etc/mysql/conf.d/</code></pre>
<p>如果是完整的my.cnf文件，直接复制出去，如果不是，则需要把includedir目录一起复到主机</p>
<p>拷贝配置文件</p>
<p>把Docker中的/etc/mysql/my.cnf文件拷贝到Docker的/var/lib/mysql目录，及主机的/usr/local/mysql/目录中</p>
<pre><code class="line-numbers language-bash">cp /etc/mysql/my.cnf /var/lib/mysql</code></pre>
<p>把Docker中includedir目录复制出去</p>
<pre><code class="line-numbers language-bash">cp -R /etc/mysql/conf.d/ /var/lib/mysql/conf.d</code></pre>
<p>退出bash，Docker中临时用的mysqlTemp会被删除</p>
<p>然后可以查看/usr/local/mysql/目录下有mysql所有的配置文件</p>
<pre><code class="line-numbers language-bash">[root@iZbp17pvndv49r9ozf5hbcZ ~]# ls /usr/local/mysql/
conf.d  my.cnf</code></pre>
<p>这里就可以修改配置了。<br>改完之后，创建正式的mysql容器</p>
<pre><code class="line-numbers language-bash">docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123455 -v /usr/local/mysql/data:/var/lib/mysql -v /usr/local/mysql/my.cnf:/etc/mysql/my.cnf -v /usr/local/mysql/conf.d:/etc/mysql/conf.d -d mysql</code></pre>
<p>如果my.cnf 是完整的配置，这里不需要映射conf.d和mysql.conf.d这二个目录</p>
<pre><code class="line-numbers language-bash">docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123455 -v /usr/local/mysql/data:/var/lib/mysql -v /usr/local/mysql/my.cnf:/etc/mysql/my.cnf  -d mysql</code></pre>
<ul>
<li>–name 容器名称</li>
<li>-p 端口映射</li>
<li>-v 配置文件映射：将 宿主机上修改的自定义配置文件，映射到 容器中</li>
<li>-e MYSQL_ROOT_PASSWORD   设置root密码</li>
<li>-d 守护进程模式运行</li>
</ul>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux源码编译安装Python</title>
    <url>/2019/Linux/Linux%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Python/</url>
    <content><![CDATA[<pre><code class="line-numbers language-bash">$ python3 --version
Python 3.8.2
$ python --version
Python 3.8.0</code></pre>
<a id="more"></a>

<hr>
<p>Python源码版本索引下载地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZy9mdHAv">Python Index of /ftp/<i class="fa fa-external-link-alt"></i></span>，选择对应版本的<code>.tgz</code>源码包下载即可，以Python 3.8.0 Ubuntu下编译安装为例</p>
<h3 id="1-源码编译安装过程"><a href="#1-源码编译安装过程" class="headerlink" title="1. 源码编译安装过程"></a>1. 源码编译安装过程</h3><h4 id="1-1-预配置"><a href="#1-1-预配置" class="headerlink" title="1.1 预配置"></a>1.1 预配置</h4><pre><code class="line-numbers language-bash"># 新建安装目录
sudo mkdir /opt/env/python38
sudo chmod 777 /opt/env/python38
# 安装依赖
sudo apt install zlib unzip</code></pre>
<h4 id="1-2-编译安装"><a href="#1-2-编译安装" class="headerlink" title="1.2 编译安装"></a>1.2 编译安装</h4><pre><code class="line-numbers language-bash">wget https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tgz
tar xvf Python-3.8.0.tgz
cd Python-3.8.0
./configure --prefix=/opt/env/python38
make &amp;&amp; sudo make install</code></pre>
<h4 id="1-3-测试"><a href="#1-3-测试" class="headerlink" title="1.3 测试"></a>1.3 测试</h4><pre><code class="line-numbers language-bash">/opt/env/python38/bin/python3 --version
# Python 3.8.0
/opt/env/python38/bin/pip3 --version
# pip 20.2.2 from /opt/env/python38/lib/python3.8/site-packages/pip (python 3.8)</code></pre>
<blockquote>
<p>如果此时出现了一些错误，解决方案大致有：</p>
<ul>
<li><p>注意非root用户编译安装需要使用sudo赋权，否则会出现SSL的通信错误</p>
</li>
<li><p><code>sudo chmod 777 -R /opt/env/python38</code>后重新测试</p>
</li>
</ul>
</blockquote>
<h4 id="1-4-配置环境变量"><a href="#1-4-配置环境变量" class="headerlink" title="1.4 配置环境变量"></a>1.4 配置环境变量</h4><p>配置到系统环境变量可以解决<code>scrapy</code>、<code>flask</code>等全局框架命令的执行问题，但要注意与系统自带的<code>python3</code>、<code>python3.8</code>的区分</p>
<pre><code class="line-numbers language-bash">vim /etc/profile.d/python38.sh
# 添加
export PATH=$PATH:/opt/env/python38/bin/</code></pre>
<p>或者配置到个人环境变量</p>
<pre><code class="line-numbers language-bash">vim ~/.bashrc
# 添加
export PATH=$PATH:/opt/env/python38/bin/</code></pre>
<p>如果使用<code>zsh</code>的话</p>
<pre><code>vim ~/.zshrc</code></pre>
<h4 id="1-5-建立符号链接"><a href="#1-5-建立符号链接" class="headerlink" title="1.5 建立符号链接"></a>1.5 建立符号链接</h4><p>建立链接可以解决与系统自带Python混淆的问题</p>
<pre><code class="line-numbers language-bash">sudo ln -s /opt/env/python38/bin/python3 /usr/bin/python
sudo ln -s /opt/env/python38/bin/pip3 /usr/bin/pip</code></pre>
<h4 id="1-6-测试"><a href="#1-6-测试" class="headerlink" title="1.6 测试"></a>1.6 测试</h4><pre><code class="line-numbers language-bash">python --version
# Python 3.8.0
pip --version
# pip 20.2.2 from /opt/env/python38/lib/python3.8/site-packages/pip (python 3.8)</code></pre>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200831151523.png"></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SSH进行远程主机登录</title>
    <url>/2019/Linux/SSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86/</url>
    <content><![CDATA[<p>SSH 为 Secure Shell 的缩写，是一种建立在应用层基础上专为远程登录会话和其他网络服务提供安全性的通信协议，初始提供于各种Unix平台，windows也年来也提供了ssh服务。</p>
<a id="more"></a>

<h4 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h4><p><strong>Linux系</strong></p>
<pre><code class="line-numbers language-bash"># centos
yum install openssh
# ubuntu
apt install openssh</code></pre>
<p><strong>windows：</strong>直接使用 或者安装git-bash</p>
<h4 id="远程登陆方法"><a href="#远程登陆方法" class="headerlink" title="远程登陆方法"></a>远程登陆方法</h4><pre><code class="line-numbers language-bash">ssh 远程主机用户名称@远程主机IP地址
ssh 远程主机用户名称@远程主机在本地hosts文件的域名映射</code></pre>
<p>执行远程连接命令后，如果是第一次的端对端连接，会提示是否信任主机的figure，输入yes信任即可，然后会提示输入登录用户的密码（passwd），输入正确后即可完成远程登陆</p>
<p>实例：用户yuan，主机公网IP47.93.230.x</p>
<pre><code class="line-numbers language-bash">ssh yuan@47.93.230.x</code></pre>
<h4 id="免密登陆配置方法"><a href="#免密登陆配置方法" class="headerlink" title="免密登陆配置方法"></a>免密登陆配置方法</h4><p>将本机的公钥保存到需要远程登陆的主机上就可以省略每次连接的输入密码的流程</p>
<p>（1）本地主机生成密钥对</p>
<pre><code class="line-numbers language-bash">ssh-keygen</code></pre>
<blockquote>
<p>常用参数</p>
<p>-t: 密钥类型, 可以选择 dsa | ecdsa | ed25519 | rsa;</p>
<p>-f: 密钥目录位置, 默认为当前用户home路径下的.ssh隐藏目录, 也就是<code>~/.ssh/</code>, 同时默认密钥文件名以<code>id_rsa</code>开头. 如果是root用户, 则在<code>/root/.ssh/id_rsa</code>, 若为其他用户, 则在<code>/home/username/.ssh/id_rsa</code>;</p>
<p>-C: 指定此密钥的备注信息, 需要配置多个免密登录时, 建议携带;</p>
<p>-N: 指定此密钥对的密码, 如果指定此参数, 则命令执行过程中就不会出现交互确认密码的信息了.</p>
</blockquote>
<p>（2）将本地公钥保存到远程主机</p>
<pre><code class="line-numbers language-bash"># 语法：ssh-copy-id -i ~/.ssh/id_rsa.pub -p 端口 用户名@IP
ssh-copy-id root@47.93.230.x</code></pre>
<p>（3）此时使用远程登陆命令即可直接进行连接</p>
<h4 id="其他方式发送公钥文件"><a href="#其他方式发送公钥文件" class="headerlink" title="其他方式发送公钥文件"></a>其他方式发送公钥文件</h4><p>上述步骤是通过<code>ssh-copy-id</code>工具发送公钥文件的, 当然我们也可以通过其他方式实现:</p>
<p>(1)  将本地的公钥文件发给远程主机:</p>
<p>通过scp命令将本地的 <strong>公钥文件</strong> 发送到远程主机的用户目录下, 因为还没有配置成功免密登录, 所以期间需要输入远程主机对应用户的密码:</p>
<pre><code class="line-numbers language-bash">[root@localhost .ssh]# scp id_rsa.pub root@47.93.230.x:/root/.ssh 
root@47.93.230.x&#39;s password: 
id_rsa.pub                                           100%  390     0.4KB/s   00:00 </code></pre>
<p>(2)  在远程主机上创建authorized_keys文件:</p>
<pre><code class="line-numbers language-bash">[root@localhost .ssh]# cd /root/.ssh/
[root@localhost .ssh]# ls
id_rsa.pub
# 通过A服务器的公钥生成&quot;authorized_keys&quot;文件:
[root@localhost .ssh]# cat id_rsa.pub &gt;&gt; authorized_keys
[root@localhost .ssh]# cat authorized_keys 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC2JpLMqgeg9jB9ZztO··· yuan</code></pre>
<p>注意: 上述重定向时使用<code>&gt;&gt;</code>进行追加, 不要用<code>&gt;</code>, 那会清空原有内容.</p>
<h4 id="关于密钥对文件的权限问题"><a href="#关于密钥对文件的权限问题" class="headerlink" title="关于密钥对文件的权限问题"></a>关于密钥对文件的权限问题</h4><p>为了让私钥文件和公钥文件能够在认证中起作用, 需要确保权限的正确性:</p>
<blockquote>
<p>①  对于<code>.ssh</code>目录以及其内部的公钥、私钥文件, 当前用户至少要有执行权限, 其他用户最多只能有执行权限.</p>
<p>②  不要图省事设置成777权限: 太大的权限不安全, 而且数字签名也不支持这种权限策略.</p>
<p>③  对普通用户, 建议设置成600权限: chmod 600  authorized_keys  id_rsa  id_rsa.pub;</p>
<p>④  对root用户, 建议设置成644权限: chmod 644  authorized_keys  id_rsa  id_rsa.pub.</p>
</blockquote>
<h4 id="pem密钥认证登陆"><a href="#pem密钥认证登陆" class="headerlink" title="pem密钥认证登陆"></a>pem密钥认证登陆</h4><p>本地pem文件位置：<code>~/.ssh/yuan.pem</code>，普通用户，权限600</p>
<pre><code>ssh -i ~/.ssh/yuan.pem root@47.93.230.127</code></pre>
<h4 id="显示登录信息"><a href="#显示登录信息" class="headerlink" title="显示登录信息"></a>显示登录信息</h4><p>有时候登陆发生问题，可以通过查看登陆过程发现问题</p>
<pre><code>ssh root@47.93.230.127 -v</code></pre>
<h4 id="无法使用ssh登陆"><a href="#无法使用ssh登陆" class="headerlink" title="无法使用ssh登陆"></a>无法使用ssh登陆</h4><pre><code class="line-numbers language-bash">vim /etc/ssh/sshd.config</code></pre>
<p>开启sshd守护进程的相关配置</p>
<pre><code class="line-numbers language-bash">RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys</code></pre>
<h4 id="etc-ssh-ssh-config配置文件"><a href="#etc-ssh-ssh-config配置文件" class="headerlink" title="/etc/ssh/ssh_config配置文件"></a><strong>/etc/ssh/ssh_config配置文件</strong></h4><pre><code class="line-numbers language-shell">选项参数                                      说明
Host *                                    选项“Host”只对能够匹配后面字串的计算机有效。“*”表示所有的计算机。
ForwardAgent no                           设置连接是否经过验证代理（如果存在）转发给远程计算机。
ForwardX11 no                             设置X11连接是否被自动重定向到安全的通道和显示集（DISPLAY set）
RhostsAuthentication no                   设置是否使用基于rhosts的安全验证
RhostsRSAAuthentication no                设置是否使用用RSA算法的基于rhosts的安全验证
RSAAuthentication yes                     设置是否使用RSA算法进行安全验证
PasswordAuthentication yes                设置是否使用口令验证
FallBackToRsh no                          设置如果用ssh连接出现错误是否自动使用rsh
UseRsh no                                 设置是否在这台计算机上使用“rlogin/rsh”
BatchMode no                              如果设为“yes”，passphrase/password（交互式输入口令）的提示将被禁止。
                                          &gt;当不能交互式输入口令的时候，这个选项对脚本文件和批处理任务十分有用
CheckHostIP yes                           设置ssh是否查看连接到服务器的主机的IP地址以防止DNS欺骗。建议设置为“yes”
StrictHostKeyChecking no                  如果设置成“yes”，ssh就不会自动把计算机的密匙加入“$HOME/.ssh/known_hosts”文件，
                                          &gt;并且一旦计算机的密匙发生了变化，就拒绝连接
IdentityFile ~/.ssh/identity              设置从哪个文件读取用户的RSA安全验证标识
Port 22                                   设置连接到远程主机的端口
Cipher blowfish                           设置加密用的密码
EscapeChar ~                              设置escape字符</code></pre>
<h4 id="sshd配置文件"><a href="#sshd配置文件" class="headerlink" title="sshd配置文件"></a>sshd配置文件</h4><pre><code class="line-numbers language-shell">Port 22                                                         SSH 预设使用 22 这个 port，您也可以使用多的 port ！
Protocol 2,1                                                    选择的 SSH 协议版本，可以是 1 也可以是 2 ，如果要同时支持两者，就必须要使用 2,1 这个分隔了！
ListenAddress 0.0.0.0                                           监听的主机适配卡！举个例子来说，如果您有两个 IP，分别是 192.168.0.100 及 192.168.2.20 ，那么只想要开放 192.168.0.100 时，就可以写如同下面的样式：
ListenAddress 192.168.0.100                                     只监听来自 192.168.0.100 这个 IP 的SSH联机。如果不使用设定的话，则预设所有接口均接受 SSH
PidFile /var/run/sshd.pid                                       可以放置 SSHD 这个 PID 的档案！左列为默认值
LoginGraceTime 600                                              当使用者连上 SSH server 之后，会出现输入密码的画面，在该画面中，在多久时间内没有成功连上 SSH server ，就断线！时间为秒！
Compression yes                                                 是否可以使用压缩指令？
HostKey /etc/ssh/ssh_host_key                                   SSH version 1 使用的私钥
HostKey /etc/ssh/ssh_host_rsa_key                               SSH version 2 使用的 RSA 私钥
HostKey /etc/ssh/ssh_host_dsa_key                               SSH version 2 使用的 DSA 私钥
KeyRegenerationInterval 3600                                    由前面联机的说明可以知道， version 1 会使用 server 的 Public Key ，每隔一段时间来重新建立一次！时间为秒！
ServerKeyBits 768                                               Server key 的长度！
SyslogFacility AUTH                                             当有人使用 SSH 登入系统的时候，SSH会记录信息
LogLevel INFO                                                   登录记录的等级---》全部
PermitRootLogin no                                              是否允许 root 登入！预设是允许的，但是建议设定成 no！
UserLogin no                                                    在 SSH 底下本来就不接受 login 这个程序的登入！
StrictModes yes                                                 当使用者的 host key 改变之后，Server 就不接受联机
RSAAuthentication yes                                           是否使用纯的 RSA 认证！？仅针对 version 1 ！
PubkeyAuthentication yes                                        是否允许 Public Key ？只有 version 2
AuthorizedKeysFile   .ssh/authorized_keys                       设定若要使用不需要密码登入的账号时，那么那个账号的存放档案所在档名！
RhostsAuthentication no                                         本机系统不使用 .rhosts ， .rhosts 不安全！
IgnoreRhosts yes                                                是否取消使用 ~/.ssh/.rhosts 来做为认证！
RhostsRSAAuthentication no                                      针对 version 1 ，使用 rhosts 档案在/etc/hosts.equiv配合 RSA 演算方式来进行认证！
HostbasedAuthentication no                                      这个项目与上面的项目类似，不过是给 version 2 使用的！
IgnoreUserKnownHosts no                                         是否忽略家目录内的 ~/.ssh/known_hosts 这个档案所记录的主机内容
PasswordAuthentication yes                                      密码验证当然是需要的！
PermitEmptyPasswords no                                         上面那一项如果设定为 yes 的话，这一项就最好设定为 no ，这个项目在是否允许以空的密码登入！
ChallengeResponseAuthentication yes                             挑战任何的密码认证！所以，任何 login.conf 规定的认证方式，均可适用！
PAMAuthenticationViaKbdInt yes                                  是否启用其它的 PAM 模块！启用这个模块将会导致 PasswordAuthentication 设定失效！

与Kerberos 有关的参数设定！底下不用设定
KerberosAuthentication no
KerberosOrLocalPasswd yes
KerberosTicketCleanup yes
KerberosTgtPassing no

有关在 X-Window 底下使用的相关设定
X11Forwarding yes
X11DisplayOffset 10
X11UseLocalhost yes

PrintMotd no                                                    登入后是否显示出一些信息呢？例如上次登入的时间、地点等，预设是 yes ，但是，如果为了安全，可以考虑改为 no ！
PrintLastLog yes                                                显示上次登入的信息！预设也是 yes
KeepAlive yes                                                   一般而言，如果设定这项目的话，那么 SSH Server 会传送KeepAlive 的讯息给 Client 端，以确保两者的联机正常！在这个情况下，任何一端死掉后， SSH 可以立刻知道！而不会有僵尸程序的发生！
UsePrivilegeSeparation yes                                      使用者的权限设定项目！
MaxStartups 10                                                  同时允许几个尚未登入的联机画面
DenyUsers *                                                     设定受抵挡的使用者名称
AllowUsers *                                                    设定允许的使用者名称</code></pre>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫案例列表</title>
    <url>/2019/Python/%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>收集的一些经典的爬虫案例</p>
<a id="more"></a>

<hr>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NoeXJvYy9XZWNoYXRTb2dvdQ==">WechatSogou<i class="fa fa-external-link-alt"></i></span> [1]- 微信公众号爬虫。基于搜狗微信搜索的微信公众号爬虫接口，可以扩展成基于搜狗搜索的爬虫，返回结果是列表，每一项均是公众号具体信息字典。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xhbmJpbmc1MTAvRG91QmFuU3BpZGVy">DouBanSpider<i class="fa fa-external-link-alt"></i></span> [2]-  豆瓣读书爬虫。可以爬下豆瓣读书标签下的所有图书，按评分排名依次存储，存储到Excel中，可方便大家筛选搜罗，比如筛选评价人数&gt;1000的高分书籍；可依据不同的主题存储到Excel不同的Sheet ，采用User Agent伪装为浏览器进行爬取，并加入随机延时来更好的模仿浏览器行为，避免爬虫被封。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpdVJveS96aGlodV9zcGlkZXI=">zhihu_spider<i class="fa fa-external-link-alt"></i></span> [3]- 知乎爬虫。此项目的功能是爬取知乎用户信息以及人际拓扑关系，爬虫框架使用scrapy，数据存储使用mongo。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FpcmluZ3Vyc2IvYmlsaWJpbGktdXNlcg==">bilibili-user<i class="fa fa-external-link-alt"></i></span> [4]- Bilibili用户爬虫。总数据数：20119918，抓取字段：用户id，昵称，性别，头像，等级，经验值，粉丝数，生日，地址，注册时间，签名，等级与经验值等。抓取之后生成B站用户数据报告。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpdVhpbmdNaW5nL1NpbmFTcGlkZXI=">SinaSpider<i class="fa fa-external-link-alt"></i></span> [5]- 新浪微博爬虫。主要爬取新浪微博用户的个人信息、微博信息、粉丝和关注。代码获取新浪微博Cookie进行登录，可通过多账号登录来防止新浪的反扒。主要使用 scrapy 爬虫框架。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2duZW1vdWcvZGlzdHJpYnV0ZV9jcmF3bGVy">distribute_crawler<i class="fa fa-external-link-alt"></i></span> [6]- 小说下载分布式爬虫。使用scrapy,Redis, MongoDB,graphite实现的一个分布式网络爬虫,底层存储mongodb集群,分布式使用redis实现,爬虫状态显示使用graphite实现，主要针对一个小说站点。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lhbnpob3UvQ25raVNwaWRlcg==">CnkiSpider<i class="fa fa-external-link-alt"></i></span> [7]- 中国知网爬虫。设置检索条件后，执行src/CnkiSpider.py抓取数据，抓取数据存储在/data目录下，每个数据文件的第一行为字段名称。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xhbmJpbmc1MTAvTGlhbkppYVNwaWRlcg==">LianJiaSpider<i class="fa fa-external-link-alt"></i></span> [8]- 链家网爬虫。爬取北京地区链家历年二手房成交记录。涵盖链家爬虫一文的全部代码，包括链家模拟登录代码。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RhaXppbG9uZ3h1L3NjcmFweV9qaW5nZG9uZw==">scrapy_jingdong<i class="fa fa-external-link-alt"></i></span> [9]- 京东爬虫。基于scrapy的京东网站爬虫，保存格式为csv。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhc3BhcnRzZS9RUS1Hcm91cHMtU3BpZGVy">QQ-Groups-Spider<i class="fa fa-external-link-alt"></i></span> [10]- QQ 群爬虫。批量抓取 QQ 群信息，包括群名称、群号、群人数、群主、群简介等内容，最终生成 XLS(X) / CSV 结果文件。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhbmMwMGwvd29veXVuX3B1YmxpYw==">wooyun_public<i class="fa fa-external-link-alt"></i></span>[11]-乌云爬虫。  乌云公开漏洞、知识库爬虫和搜索。全部公开漏洞的列表和每个漏洞的文本内容存在mongodb中，大概约2G内容；如果整站爬全部文本和图片作为离线查询，大概需要10G空间、2小时（10M电信带宽）；爬取全部知识库，总共约500M空间。漏洞搜索使用了Flask作为web server，bootstrap作为前端。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpbmluZzA4MDYvUXVuYXJTcGlkZXI=">QunarSpider<i class="fa fa-external-link-alt"></i></span> [12]- 去哪儿网爬虫。 网络爬虫之Selenium使用代理登陆：爬取去哪儿网站，使用selenium模拟浏览器登陆，获取翻页操作。代理可以存入一个文件，程序读取并使用。支持多进程抓取。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Zhbmtjb2Rlci9maW5kdHJpcA==">findtrip<i class="fa fa-external-link-alt"></i></span> [13]- 机票爬虫（去哪儿和携程网）。Findtrip是一个基于Scrapy的机票爬虫，目前整合了国内两大机票网站（去哪儿 + 携程）。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xleWxlLzE2M3NwaWRlcg==">163spider<i class="fa fa-external-link-alt"></i></span> [14] - 基于requests、MySQLdb、torndb的网易客户端内容爬虫</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvbnRjb250YWN0bWUvZG91YmFuc3BpZGVycw==">doubanspiders<i class="fa fa-external-link-alt"></i></span>[15]- 豆瓣电影、书籍、小组、相册、东西等爬虫集</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpdVhpbmdNaW5nL1FRU3BpZGVy">QQSpider<i class="fa fa-external-link-alt"></i></span> [16]- QQ空间爬虫，包括日志、说说、个人信息等，一天可抓取 400 万条数据。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NodS1KaS9iYWlkdS1tdXNpYy1zcGlkZXI=">baidu-music-spider<i class="fa fa-external-link-alt"></i></span> [17]- 百度mp3全站爬虫，使用redis支持断点续传。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Bha29vL3RiY3Jhd2xlcg==">tbcrawler<i class="fa fa-external-link-alt"></i></span>[18]- 淘宝和天猫的爬虫,可以根据搜索关键词,物品id来抓去页面的信息，数据存储在mongodb。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jlbml0b3JvL3N0b2NraG9sbQ==">stockholm<i class="fa fa-external-link-alt"></i></span> [19]- 一个股票数据（沪深）爬虫和选股策略测试框架。根据选定的日期范围抓取所有沪深两市股票的行情数据。支持使用表达式定义选股策略。支持多线程处理。保存数据到JSON文件、CSV文件。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2sxOTk1L0JhaWR1eXVuU3BpZGVy">BaiduyunSpider<i class="fa fa-external-link-alt"></i></span>[20]-百度云盘爬虫。 </p>
<p>[Spider<span class="exturl" data-url="aHR0cDovL2xpbmsuemhpaHUuY29tLz90YXJnZXQ9aHR0cHM6Ly9naXRodWIuY29tL1F1dGFuL1NwaWRlcg==">21]<i class="fa fa-external-link-alt"></i></span>-社交数据爬虫。支持微博,知乎,豆瓣。</p>
<p>[proxy pool<span class="exturl" data-url="aHR0cDovL2xpbmsuemhpaHUuY29tLz90YXJnZXQ9aHR0cHM6Ly9naXRodWIuY29tL1F1dGFuL1NwaWRlcg==">22]<i class="fa fa-external-link-alt"></i></span>-Python爬虫代理IP池(proxy pool)。</p>
<p>[music-163<span class="exturl" data-url="aHR0cDovL2xpbmsuemhpaHUuY29tLz90YXJnZXQ9aHR0cHM6Ly9naXRodWIuY29tL1JpdHRlckhvdS9tdXNpYy0xNjM=">23]<i class="fa fa-external-link-alt"></i></span>-爬取网易云音乐所有歌曲的评论。</p>
<p>[jandan_spider<span class="exturl" data-url="aHR0cDovL2xpbmsuemhpaHUuY29tLz90YXJnZXQ9aHR0cHM6Ly9naXRodWIuY29tL1JpdHRlckhvdS9tdXNpYy0xNjM=">24]<i class="fa fa-external-link-alt"></i></span>-爬取煎蛋妹纸图片。</p>
<p>[CnblogsSpider<span class="exturl" data-url="aHR0cDovL2xpbmsuemhpaHUuY29tLz90YXJnZXQ9aHR0cHM6Ly9naXRodWIuY29tL2phY2tnaXRnei9DbmJsb2dzU3BpZGVy">25]<i class="fa fa-external-link-alt"></i></span>-cnblogs列表页爬虫。</p>
<p>[spider_smooc<span class="exturl" data-url="aHR0cDovL2xpbmsuemhpaHUuY29tLz90YXJnZXQ9aHR0cHM6Ly9naXRodWIuY29tL2phY2tnaXRnei9DbmJsb2dzU3BpZGVy">26]<i class="fa fa-external-link-alt"></i></span>-爬取慕课网视频。</p>
<p>[CnkiSpider<span class="exturl" data-url="aHR0cDovL2xpbmsuemhpaHUuY29tLz90YXJnZXQ9aHR0cHM6Ly9naXRodWIuY29tL3lhbnpob3UvQ25raVNwaWRlcg==">27]<i class="fa fa-external-link-alt"></i></span>-中国知网爬虫。</p>
<p>[knowsecSpider2<span class="exturl" data-url="aHR0cDovL2xpbmsuemhpaHUuY29tLz90YXJnZXQ9aHR0cHM6Ly9naXRodWIuY29tL2xpdHRsZXRodW5kZXIva25vd3NlY1NwaWRlcjI=">28]<i class="fa fa-external-link-alt"></i></span>-知道创宇爬虫题目。</p>
<p>[aiss-spider<span class="exturl" data-url="aHR0cDovL2xpbmsuemhpaHUuY29tLz90YXJnZXQ9aHR0cHM6Ly9naXRodWIuY29tL3gtc3BpZGVycy9haXNzLXNwaWRlcg==">29]<i class="fa fa-external-link-alt"></i></span>-爱丝APP图片爬虫。</p>
<p>[SinaSpider<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N6Y2Ytd2VpeWEvU2luYVNwaWRlcg==">30]<i class="fa fa-external-link-alt"></i></span>-动态IP解决新浪的反爬虫机制，快速抓取内容。</p>
<p>[csdn-spider<span class="exturl" data-url="aHR0cDovL2xpbmsuemhpaHUuY29tLz90YXJnZXQ9aHR0cHM6Ly9naXRodWIuY29tL0tldmluc3NzL2NzZG4tc3BpZGVy">31]<i class="fa fa-external-link-alt"></i></span>-爬取CSDN上的博客文章。</p>
<p>[ProxySpider<span class="exturl" data-url="aHR0cDovL2xpbmsuemhpaHUuY29tLz90YXJnZXQ9aHR0cHM6Ly9naXRodWIuY29tL2NoYW5nZXRqdXQvUHJveHlTcGlkZXI=">32]<i class="fa fa-external-link-alt"></i></span>-爬取西刺上的代理IP，并验证代理可用性。</p>
<p>[webspider<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0d1b3podUhlL3dlYnNwaWRlcg==">33]<i class="fa fa-external-link-alt"></i></span>-本系统是一个主要使用python3, celery和requests来爬取职位数据的爬虫，实现了定时任务，出错重试，日志记录，自动更改Cookies等的功能，并使用ECharts + Bootstrap 来构建前端页面，来展示爬取到的数据。</p>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>一些有用的Windows软件</title>
    <url>/2019/%E9%9A%8F%E7%AC%94/Windows%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p>Windows下的一些使用软件、小插件等安装及使用方法</p>
<a id="more"></a>

<h2 id="Quicklook-空格键文件预览"><a href="#Quicklook-空格键文件预览" class="headerlink" title="Quicklook | 空格键文件预览"></a>Quicklook | 空格键文件预览</h2><blockquote>
<img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200827223543.jpeg" style="zoom: 50%;" />

<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1FMLVdpbi9RdWlja0xvb2s=">GitHub项目地址<i class="fa fa-external-link-alt"></i></span> |  <span class="exturl" data-url="aHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS9zdG9yZS9hcHBzLzludjRiczNsMWg0cz9vY2lkPWJhZGdl">Windows Store商店<i class="fa fa-external-link-alt"></i></span> | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1FMLVdpbi9RdWlja0xvb2svcmVsZWFzZXM=">安装文件下载<i class="fa fa-external-link-alt"></i></span></p>
<p>操作说明：</p>
<ul>
<li>空格键：预览/关闭预览 </li>
<li>ESC：关闭预览 </li>
<li>回车：运行程序并关闭预览 </li>
<li>CTRL+鼠标滚轮：缩放图片/文档 </li>
<li>鼠标滚轮：调节音量                    </li>
</ul>
</blockquote>
<h2 id="Everything-全盘文件搜索"><a href="#Everything-全盘文件搜索" class="headerlink" title="Everything | 全盘文件搜索"></a>Everything | 全盘文件搜索</h2><blockquote>
<p>“Everything”是一个运行于Windows系统，基于文件、文件夹名称的快速搜索引擎。它体积小巧，界面简洁易用，快速建立索引，快速搜索，同时占用极低的系统资源，实时<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQjclOUYlRTglQjglQUElRTYlOTYlODclRTQlQkIlQjY=">跟踪文件<i class="fa fa-external-link-alt"></i></span>变化，并且还可以通过http或ftp形式分享搜索。</p>
<p>官网地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cudm9pZHRvb2xzLmNvbS96aC1jbi8=">https://www.voidtools.com/zh-cn/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="EarTrumpet-进程音量控制-音频设备选择"><a href="#EarTrumpet-进程音量控制-音频设备选择" class="headerlink" title="EarTrumpet | 进程音量控制/音频设备选择"></a>EarTrumpet | 进程音量控制/音频设备选择</h2><blockquote>
<p>软件特点：</p>
<ul>
<li>Visualize audio with multi-channel aware peaking</li>
<li>Standalone volume mixer</li>
<li>Move apps between playback devices</li>
<li>Default playback device management</li>
<li>Automatic updates via the Microsoft Store</li>
<li>Support for light/dark mode and all accent colors</li>
<li>Configurable hotkeys</li>
<li>Modern context menus</li>
<li>Growing multilingual support</li>
</ul>
<p>GitHub项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lzZWV5by9FYXJUcnVtcGV0">https://github.com/iseeyo/EarTrumpet<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器操作命令</title>
    <url>/2019/Docker/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<ul>
<li>软件版本/帮助信息</li>
<li>针对镜像（image）的操作</li>
<li>针对容器（container，image实例）的操作</li>
<li>其他操作（image、container的备份与导入等）</li>
</ul>
<a id="more"></a>

<h2 id="1-Docker软件相关"><a href="#1-Docker软件相关" class="headerlink" title="1 Docker软件相关"></a>1 Docker软件相关</h2><pre><code class="line-numbers language-shell">docker version        # 查看docker容器版本
docker info            # 查看docker容器信息
docker --help        # 查看docker容器帮助</code></pre>
<h2 id="2-镜像（image）操作"><a href="#2-镜像（image）操作" class="headerlink" title="2 镜像（image）操作"></a>2 镜像（image）操作</h2><p>提示：对于镜像的操作可使用镜像名 镜像长ID和短ID。</p>
<h3 id="2-1-镜像查看"><a href="#2-1-镜像查看" class="headerlink" title="2.1 镜像查看"></a>2.1 镜像查看</h3><pre><code class="line-numbers language-shell">docker images            # 列出本地images
docker images -a            # 含中间映像层
docker images -q            # 只显示镜像ID
docker images --digests        # 显示镜像摘要信息(DIGEST列)
docker images --no-trunc        # 显示镜像完整信息</code></pre>
<p>指定镜像名称</p>
<pre><code class="line-numbers language-shell"># 显示指定镜像的历史创建；参数：-H 镜像大小和日期，默认为true；--no-trunc  显示完整的提交记录；-q  仅列出提交记录ID
docker history -H redis</code></pre>
<h3 id="2-2-镜像搜索"><a href="#2-2-镜像搜索" class="headerlink" title="2.2 镜像搜索"></a>2.2 镜像搜索</h3><pre><code class="line-numbers language-shell">docker search mysql        # 搜索仓库MySQL镜像
docker search --filter=stars=600 mysql        #  --filter=stars=600：只显示 starts&gt;=600 的镜像
docker search --no-trunc mysql        #  --no-trunc 显示镜像完整 DESCRIPTION 描述
docker search  --automated mysql        #  --automated ：只列出 AUTOMATED=OK 的镜像</code></pre>
<h3 id="2-3-镜像下载"><a href="#2-3-镜像下载" class="headerlink" title="2.3 镜像下载"></a>2.3 镜像下载</h3><pre><code class="line-numbers language-shell"># 下载Redis官方最新镜像，相当于：docker pull redis:latest
docker pull redis
# 下载仓库所有Redis镜像
docker pull -a redis
# 下载私人仓库镜像
docker pull bitnami/redis</code></pre>
<h3 id="2-4-镜像删除"><a href="#2-4-镜像删除" class="headerlink" title="2.4 镜像删除"></a>2.4 镜像删除</h3><pre><code class="line-numbers language-shell"># 单个镜像删除，相当于：docker rmi redis:latest
docker rmi redis
# 强制删除(针对基于镜像有运行的容器进程)
docker rmi -f redis
# 多个镜像删除，不同镜像间以空格间隔
docker rmi -f redis tomcat nginx
# 删除本地全部镜像
docker rmi -f $(docker images -q)</code></pre>
<h3 id="2-5-镜像构建"><a href="#2-5-镜像构建" class="headerlink" title="2.5 镜像构建"></a>2.5 镜像构建</h3><pre><code class="line-numbers language-shell"># （1）编写dockerfile
cd /docker/dockerfile
vim mycentos
# （2）构建docker镜像
docker build -f /docker/dockerfile/mycentos -t mycentos:1.1</code></pre>
<h2 id="3-容器操作"><a href="#3-容器操作" class="headerlink" title="3 容器操作"></a>3 容器操作</h2><p>提示：对于容器的操作可使用 container id 或 names。</p>
<h3 id="3-1-容器启动"><a href="#3-1-容器启动" class="headerlink" title="3.1 容器启动"></a>3.1 容器启动</h3><pre><code class="line-numbers language-shell"># 新建并启动容器，参数：-i  以交互模式运行容器；-t  为容器重新分配一个伪输入终端；--name  为容器指定一个名称
docker run -i -t --name mycentos
# 后台启动容器，参数：-d  守护方式启动容器
docker run -d mycentos</code></pre>
<p>注意在添加run参数的时候，前者为宿主机port，后者为container port，如redis的<code>-p 16379:6379</code></p>
<pre><code class="line-numbers language-shell"># 启动一个或多个已经被停止的容器
docker start redis
# 重启容器
docker restart redis</code></pre>
<h3 id="3-2-容器进程"><a href="#3-2-容器进程" class="headerlink" title="3.2 容器进程"></a>3.2 容器进程</h3><pre><code class="line-numbers language-shell"># top支持 ps 命令参数，格式：docker top [OPTIONS] CONTAINER [ps OPTIONS]
# 列出redis容器中运行进程
docker top redis
# 查看所有运行容器的进程信息
for i in  `docker ps |grep Up|awk &#39;&#123;print $1&#125;&#39;`;do echo \ &amp;&amp;docker top $i; done</code></pre>
<h3 id="3-3-容器日志"><a href="#3-3-容器日志" class="headerlink" title="3.3 容器日志"></a>3.3 容器日志</h3><pre><code class="line-numbers language-shell"># 查看redis容器日志，默认参数
docker logs rabbitmq
# 查看redis容器日志，参数：-f  跟踪日志输出；-t   显示时间戳；--tail  仅列出最新N条容器日志；
docker logs -f -t --tail=20 redis
# 查看容器redis从2019年05月21日后的最新10条日志。
docker logs --since=&quot;2019-05-21&quot; --tail=10 redis</code></pre>
<h3 id="3-4-容器的进入与退出"><a href="#3-4-容器的进入与退出" class="headerlink" title="3.4 容器的进入与退出"></a>3.4 容器的进入与退出</h3><pre><code class="line-numbers language-shell"># 使用run方式在创建时进入
docker run -it centos /bin/bash
# 关闭容器并退出
exit
# 仅退出容器，不关闭
快捷键：Ctrl + P + Q
# 直接进入centos 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：--sig-proxy=false  确保CTRL-D或CTRL-C不会关闭容器
docker attach --sig-proxy=false centos 
# 在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i  即使没有附加也保持STDIN 打开；-t  分配一个伪终端
docker exec -i -t  centos /bin/bash
# 以交互模式在容器中执行命令，结果返回到当前终端屏幕
docker exec -i -t centos ls -l /tmp
# 以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端
docker exec -d centos  touch cache.txt </code></pre>
<h3 id="3-5-查看容器"><a href="#3-5-查看容器" class="headerlink" title="3.5 查看容器"></a>3.5 查看容器</h3><pre><code class="line-numbers language-shell"># 查看正在运行的容器
docker ps
# 查看正在运行的容器的ID
docker ps -q
# 查看正在运行+历史运行过的容器
docker ps -a
# 显示运行容器总文件大小
docker ps -s

# 显示最近创建容器
docker ps -l
# 显示最近创建的3个容器
docker ps -n 3
# 不截断输出
docker ps --no-trunc 

# 获取镜像redis的元信息
docker inspect redis
# 获取正在运行的容器redis的 IP
docker inspect --format=&#39;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#39; redis</code></pre>
<h3 id="3-6-容器的停止与删除"><a href="#3-6-容器的停止与删除" class="headerlink" title="3.6 容器的停止与删除"></a>3.6 容器的停止与删除</h3><pre><code class="line-numbers language-shell"># 停止一个运行中的容器
docker stop redis
# 杀掉一个运行中的容器
docker kill redis
# 删除一个已停止的容器
docker rm redis
# 删除一个运行中的容器
docker rm -f redis
# 删除多个容器
docker rm -f $(docker ps -a -q)
docker ps -a -q | xargs docker rm
#  -l 移除容器间的网络连接，连接名为 db
docker rm -l db 
#  -v 删除容器，并删除容器挂载的数据卷
docker rm -v redis</code></pre>
<h3 id="3-7-生成镜像"><a href="#3-7-生成镜像" class="headerlink" title="3.7 生成镜像"></a>3.7 生成镜像</h3><pre><code class="line-numbers language-shell"># 基于当前redis容器创建一个新的镜像；参数：-a 提交的镜像作者；-c 使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停
docker commit -a=&quot;DeepInThought&quot; -m=&quot;my redis&quot; [redis容器ID]  myredis:v1.1</code></pre>
<h2 id="4-其他操作"><a href="#4-其他操作" class="headerlink" title="4 其他操作"></a>4 其他操作</h2><h3 id="4-1-容器与主机间的数据拷贝"><a href="#4-1-容器与主机间的数据拷贝" class="headerlink" title="4.1 容器与主机间的数据拷贝"></a>4.1 容器与主机间的数据拷贝</h3><pre><code class="line-numbers language-shell"># 将&lt;cname&gt;容器中的文件copy至本地路径
docker cp &lt;cname&gt;:/[container_path] [local_path]

# 将主机文件copy至&lt;cname&gt;容器
docker cp [local_path] &lt;cname&gt;:/[container_path]/

# 将主机文件copy至&lt;cname&gt;容器，目录重命名为[container_path]（注意与非重命名copy的区别）
docker cp [local_path] &lt;cname&gt;:/[container_path]</code></pre>
<h3 id="4-2-Docker-Image的备份-导入"><a href="#4-2-Docker-Image的备份-导入" class="headerlink" title="4.2 Docker Image的备份/导入"></a>4.2 Docker Image的备份/导入</h3><pre><code class="line-numbers language-shell"># 备份镜像
docker save redis &gt; /home/yuan/redis_save.tar
# 导入镜像
docker load &lt; /home/yuan/redis_save.tar</code></pre>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200827154931.png"></p>
<h3 id="4-3-Docker-container的备份-导入"><a href="#4-3-Docker-container的备份-导入" class="headerlink" title="4.3 Docker container的备份/导入"></a>4.3 Docker container的备份/导入</h3><pre><code>docker ps -a

docker export redis_6379 &gt; redis_6379_export.tar

cat /home/yuan/redis_6379_export.tar | sudo docker import - redis:latest</code></pre>
<h2 id="5-Docker-run的启动参数"><a href="#5-Docker-run的启动参数" class="headerlink" title="5 Docker run的启动参数"></a>5 Docker run的启动参数</h2><pre><code class="line-numbers language-shell">-a, --attach=[] 登录容器（以docker run -d启动的容器）
-c, --cpu-shares=0 设置容器CPU权重，在CPU共享场景使用
--cap-add=[] 添加权限，清单详见：http://linux.die.net/man/7/capabilities
--cap-drop=[] 删除权限，清单详见：http://linux.die.net/man/7/capabilities
--cidfile=&quot;&quot; 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法
--cpuset=&quot;&quot; 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU
-d, --detach=false 指定容器运行于前台还是后台
--device=[] 添加主机设备给容器，相当于设备直通
--dns=[] 指定容器的dns服务器
--dns-search=[] 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件
-e, --env=[] 指定环境变量，容器中可以使用该环境变量
--entrypoint=&quot;&quot; 覆盖image的入口点
--env-file=[] 指定环境变量文件，文件格式为每行一个环境变量
--expose=[] 指定容器暴露的端口，即修改镜像的暴露端口
-h, --hostname=&quot;&quot; 指定容器的主机名
-i, --interactive=false 打开STDIN，用于控制台交互
--link=[] 指定容器间的关联，使用其他容器的IP、env等信息
--lxc-conf=[] 指定容器的配置文件，只有在指定--exec-driver=lxc时使用
-m, --memory=&quot;&quot; 指定容器的内存上限
--name=&quot;&quot; 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字
--net=&quot;bridge&quot; 容器网络设置，待详述
-P, --publish-all=false 指定容器暴露的端口，待详述
-p, --publish=[] 指定容器暴露的端口，待详述
--privileged=false 指定容器是否为特权容器，特权容器拥有所有的capabilities
--restart=&quot;&quot; 指定容器停止后的重启策略，待详述
--rm=false 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)
--sig-proxy=true 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理
-t, --tty=false 分配tty设备，该可以支持终端登录
-u, --user=&quot;&quot; 指定容器的用户
-v, --volume=[] 给容器挂载存储卷，挂载到容器的某个目录
--volumes-from=[] 给容器挂载其他容器上的卷，挂载到容器的某个目录
-w, --workdir=&quot;&quot; 指定容器的工作目录</code></pre>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS定位方法</title>
    <url>/2019/%E9%9A%8F%E7%AC%94/CSS%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<p>百度百科介绍：</p>
<p>层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9IVE1M">HTML<i class="fa fa-external-link-alt"></i></span>（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQTAlODclRTUlODclODYlRTklODAlOUElRTclOTQlQTglRTYlQTAlODclRTglQUUlQjAlRTglQUYlQUQlRTglQTglODAvNjgwNTA3Mw==">标准通用标记语言<i class="fa fa-external-link-alt"></i></span>的一个应用）或<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9YTUw=">XML<i class="fa fa-external-link-alt"></i></span>（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。</p>
<p>什么是选择器呢？每一条css样式定义由两部分组成，形式如下： [code] 选择器{样式} [/code] 在{}之前的部分就是“选择器”。 “选择器”指明了{}中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素</p>
<a id="more"></a>

<hr>
<h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4><table>
<thead>
<tr>
<th align="left">选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td>通用元素选择器，匹配任何元素</td>
</tr>
<tr>
<td align="left"><strong>E</strong></td>
<td>标签选择器，匹配所有使用E标签的元素</td>
</tr>
<tr>
<td align="left"><strong>.info</strong></td>
<td>class选择器，匹配所有class属性中包含info的元素</td>
</tr>
<tr>
<td align="left"><strong>#footer</strong></td>
<td>id选择器，匹配所有id属性等于footer的元素</td>
</tr>
</tbody></table>
<h4 id="多元素的组合选择器"><a href="#多元素的组合选择器" class="headerlink" title="多元素的组合选择器"></a>多元素的组合选择器</h4><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>E,F</td>
<td>多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔</td>
</tr>
<tr>
<td>E F</td>
<td>后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔</td>
</tr>
<tr>
<td>E &gt; F</td>
<td>子元素选择器，匹配所有E元素的子元素F</td>
</tr>
<tr>
<td>E + F</td>
<td>毗邻元素选择器，匹配所有紧随E元素之后的同级元素F</td>
</tr>
</tbody></table>
<h4 id="CSS-2-1-属性选择器"><a href="#CSS-2-1-属性选择器" class="headerlink" title="CSS 2.1 属性选择器"></a>CSS 2.1 属性选择器</h4><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>E[att]</td>
<td>匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如”[cheacked]”。以下同。）</td>
</tr>
<tr>
<td>E[att=val]</td>
<td>匹配所有att属性等于”val”的E元素</td>
</tr>
<tr>
<td>E[att~=val]</td>
<td>匹配所有att属性具有多个空格分隔的值、其中一个值等于”val”的E元素</td>
</tr>
<tr>
<td>E[att|=val]</td>
<td>匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以”val”开头的E元素，主要用于lang属性，比如”en”、”en-us”、”en-gb”等等</td>
</tr>
</tbody></table>
<h4 id="CSS-2-1中的伪类"><a href="#CSS-2-1中的伪类" class="headerlink" title="CSS 2.1中的伪类"></a>CSS 2.1中的伪类</h4><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>E:first-child</td>
<td>匹配父元素的第一个子元素</td>
</tr>
<tr>
<td>E:link</td>
<td>匹配所有未被点击的链接</td>
</tr>
<tr>
<td>E:visited</td>
<td>匹配所有已被点击的链接</td>
</tr>
<tr>
<td>E:active</td>
<td>匹配鼠标已经其上按下、还没有释放的E元素</td>
</tr>
<tr>
<td>E:hover</td>
<td>匹配鼠标悬停其上的E元素</td>
</tr>
<tr>
<td>E:focus</td>
<td>匹配获得当前焦点的E元素</td>
</tr>
<tr>
<td>E:lang(c)</td>
<td>匹配lang属性等于c的E元素</td>
</tr>
</tbody></table>
<h4 id="CSS-2-1中的伪元素"><a href="#CSS-2-1中的伪元素" class="headerlink" title="CSS 2.1中的伪元素"></a>CSS 2.1中的伪元素</h4><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>E:first-line</td>
<td>匹配E元素的第一行</td>
</tr>
<tr>
<td>E:first-letter</td>
<td>匹配E元素的第一个字母</td>
</tr>
<tr>
<td>E:before</td>
<td>在E元素之前插入生成的内容</td>
</tr>
<tr>
<td>E:after</td>
<td>在E元素之后插入生成的内容</td>
</tr>
</tbody></table>
<h4 id="CSS-3的同级元素通用选择器"><a href="#CSS-3的同级元素通用选择器" class="headerlink" title="CSS 3的同级元素通用选择器"></a>CSS 3的同级元素通用选择器</h4><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>E ~ F</td>
<td>匹配任何在E元素之后的同级F元素</td>
</tr>
</tbody></table>
<h4 id="CSS-3-属性选择器"><a href="#CSS-3-属性选择器" class="headerlink" title="CSS 3 属性选择器"></a>CSS 3 属性选择器</h4><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>E[att^=”val”]</td>
<td>属性att的值以”val”开头的元素</td>
</tr>
<tr>
<td>E[att$=”val”]</td>
<td>属性att的值以”val”结尾的元素</td>
</tr>
<tr>
<td>E[att*=”val”]</td>
<td>属性att的值包含”val”字符串的元素</td>
</tr>
</tbody></table>
<h4 id="CSS-3中与用户界面有关的伪类"><a href="#CSS-3中与用户界面有关的伪类" class="headerlink" title="CSS 3中与用户界面有关的伪类"></a>CSS 3中与用户界面有关的伪类</h4><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>E:enabled</td>
<td>匹配表单中激活的元素</td>
</tr>
<tr>
<td>E:disabled</td>
<td>匹配表单中禁用的元素</td>
</tr>
<tr>
<td>E:checked</td>
<td>匹配表单中被选中的radio（单选框）或checkbox（复选框）元素</td>
</tr>
<tr>
<td>E::selection</td>
<td>匹配用户当前选中的元素</td>
</tr>
</tbody></table>
<h4 id="CSS-3中的结构性伪类"><a href="#CSS-3中的结构性伪类" class="headerlink" title="CSS 3中的结构性伪类"></a>CSS 3中的结构性伪类</h4><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>E:root</td>
<td>匹配文档的根元素，对于HTML文档，就是HTML元素</td>
</tr>
<tr>
<td>E:nth-child(n)</td>
<td>匹配其父元素的第n个子元素，第一个编号为1</td>
</tr>
<tr>
<td>E:nth-last-child(n)</td>
<td>匹配其父元素的倒数第n个子元素，第一个编号为1</td>
</tr>
<tr>
<td>E:nth-of-type(n)</td>
<td>与:nth-child()作用类似，但是仅匹配使用同种标签的元素</td>
</tr>
<tr>
<td>E:nth-last-of-type(n)</td>
<td>与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素</td>
</tr>
<tr>
<td>E:last-child</td>
<td>匹配父元素的最后一个子元素，等同于:nth-last-child(1)</td>
</tr>
<tr>
<td>E:first-of-type</td>
<td>匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)</td>
</tr>
<tr>
<td>E:last-of-type</td>
<td>匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)</td>
</tr>
<tr>
<td>E:only-child</td>
<td>匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)</td>
</tr>
<tr>
<td>E:only-of-type</td>
<td>匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)</td>
</tr>
<tr>
<td>E:empty</td>
<td>匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素</td>
</tr>
</tbody></table>
<h4 id="CSS-3的反选伪类"><a href="#CSS-3的反选伪类" class="headerlink" title="CSS 3的反选伪类"></a>CSS 3的反选伪类</h4><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>E:not(s)</td>
<td>匹配不符合当前选择器的任何元素</td>
</tr>
</tbody></table>
<h4 id="CSS-3中的-target-伪类"><a href="#CSS-3中的-target-伪类" class="headerlink" title="CSS 3中的 :target 伪类"></a>CSS 3中的 :target 伪类</h4><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>E:target</td>
<td>匹配文档中特定”id”点击后的效果</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装与配置方法</title>
    <url>/2019/Docker/Docker%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li>Centos7下的Docker-ce的安装方法</li>
<li>Ubuntu下Docker-ce的安装方法</li>
<li>Docker换源方法</li>
</ul>
<a id="more"></a>

<hr>
<h2 id="Centos7下的Docker-ce的安装方法"><a href="#Centos7下的Docker-ce的安装方法" class="headerlink" title="Centos7下的Docker-ce的安装方法"></a>Centos7下的Docker-ce的安装方法</h2><p>系统版本信息：<code>Linux centos7 3.10.0-1127.18.2.el7.x86_64 GNU/Linux</code></p>
<p>安装依赖</p>
<pre><code class="line-numbers language-bash">yum install -y yum-utils device-mapper-persistent-data lvm2
# yum-util 提供 yum-config-manager 功能，后两者为devicemapper驱动依赖</code></pre>
<p>安装Docker软件源（前者为官方源，后者为阿里源，二者选其一即可）</p>
<pre><code class="line-numbers language-bash">yum-config-manager --add-repo http://download.docker.com/linux/centos/docker-ce.repo
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre>
<p>查看安装源中的Docker-ce软件版本方法</p>
<pre><code class="line-numbers language-bash">yum list docker-ce --showduplicates | sort -r</code></pre>
<p>安装docker-ce</p>
<pre><code class="line-numbers language-bash">yum install docker-ce-18.03.1.ce -y        # 安装指定版本
yum install docker-ce -y        # 安装最新的stable版本</code></pre>
<p>开启docker服务</p>
<pre><code class="line-numbers language-bash">systemctl start docker.service        # 开启服务
systemctl enable docker.service        # 开启开机自启动</code></pre>
<p>测试</p>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200825214420.png"></p>
<hr>
<h2 id="Ubuntu下Docker-ce的安装方法"><a href="#Ubuntu下Docker-ce的安装方法" class="headerlink" title="Ubuntu下Docker-ce的安装方法"></a>Ubuntu下Docker-ce的安装方法</h2><p>APT换源，推荐科大源</p>
<pre><code class="line-numbers language-bash">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
sudo sed -i &#39;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.list
sudo apt update</code></pre>
<p>安装依赖包</p>
<pre><code class="line-numbers language-bash">sudo apt install apt-transport-https ca-certificates software-properties-common curl -y</code></pre>
<p>添加 GPG 密钥，并添加 Docker-ce 软件源，然后更新一下缓存</p>
<pre><code class="line-numbers language-bash">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;
sudo apt update -y</code></pre>
<p>安装 Docker-ce</p>
<pre><code class="line-numbers language-bash">sudo apt install docker-ce -y</code></pre>
<p>设置开机自启动并启动 Docker-ce</p>
<pre><code class="line-numbers language-bash">sudo systemctl enable docker
sudo systemctl restart docker</code></pre>
<p>测试运行</p>
<pre><code class="line-numbers language-bash">sudo docker --help</code></pre>
<p>添加当前用户到 docker 用户组，可以不用 sudo 运行 docker（可选）</p>
<pre><code class="line-numbers language-bash">sudo groupadd docker
sudo usermod -aG docker $USER
docker pull hello-world        # 测试</code></pre>
<h2 id="Docker在WSL中的使用"><a href="#Docker在WSL中的使用" class="headerlink" title="Docker在WSL中的使用"></a>Docker在WSL中的使用</h2><p>wsl中根据Linux发行版本进行安装后还需要执行以下步骤</p>
<ol>
<li><p>对socket文件进行赋权：<code>sudo chmod -R 777 /var/run/docker.sock</code>，解决无权限通信error问题</p>
</li>
<li><p>关于启动方法的实际测试</p>
<ul>
<li><code>systemctl start docker.service</code>，无效</li>
<li><code>sudo service docker start</code>，有效</li>
</ul>
</li>
</ol>
<h2 id="Docker仓库的换源问题"><a href="#Docker仓库的换源问题" class="headerlink" title="Docker仓库的换源问题"></a>Docker仓库的换源问题</h2><p><code>vi /etc/docker/daemon.json</code></p>
<pre><code class="line-numbers language-bash">&#123;
    &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]
&#125;</code></pre>
<p><code>systemctl restart docker.service</code></p>
<ul>
<li><p>网易：<span class="exturl" data-url="aHR0cDovL2h1Yi1taXJyb3IuYy4xNjMuY29tLw==">http://hub-mirror.c.163.com<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>ustc：<span class="exturl" data-url="aHR0cHM6Ly9kb2NrZXIubWlycm9ycy51c3RjLmVkdS5jbi8=">https://docker.mirrors.ustc.edu.cn<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>中国科技大学：<span class="exturl" data-url="aHR0cHM6Ly9kb2NrZXIubWlycm9ycy51c3RjLmVkdS5jbi8=">https://docker.mirrors.ustc.edu.cn<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>阿里云获取地址：<span class="exturl" data-url="aHR0cHM6Ly9jci5jb25zb2xlLmFsaXl1bi5jb20vY24tYmVpamluZy9pbnN0YW5jZXMvbWlycm9ycw==">https://cr.console.aliyun.com/cn-beijing/instances/mirrors<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter Notebook安装及配置优化</title>
    <url>/2019/Python/Jupyter%20notebook/</url>
    <content><![CDATA[<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200831152020.png"></p>
<a id="more"></a>

<hr>
<h3 id="1-安装jupyter-notebook"><a href="#1-安装jupyter-notebook" class="headerlink" title="1. 安装jupyter notebook"></a>1. 安装jupyter notebook</h3><pre><code class="line-numbers language-bash">pip install jupyter notebook        # 安装

jupyter notebook        # 本地启用，浏览器访问localhost:8888即可访问</code></pre>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200430152348.png"></p>
<h3 id="2-远程使用"><a href="#2-远程使用" class="headerlink" title="2. 远程使用"></a>2. 远程使用</h3><p>注意：网络服务器应该在<strong>安全组</strong>打开jupyter notebook服务的端口（默认8888）才能进行远程访问！</p>
<h4 id="2-1-带参数运行"><a href="#2-1-带参数运行" class="headerlink" title="2.1 带参数运行"></a>2.1 带参数运行</h4><p>添加命令行参数方式会比较麻烦，治标不治本，建议配置config</p>
<pre><code class="line-numbers language-bash">jupyter notebook --ip=&#39;0.0.0.0&#39; --allow-root</code></pre>
<h4 id="2-2-写入配置文件"><a href="#2-2-写入配置文件" class="headerlink" title="2.2 写入配置文件"></a>2.2 写入配置文件</h4><p>使用命令<code>jupyter notebook --generate-config</code>生成配置文件，编辑配置文件</p>
<pre><code class="line-numbers language-bash">vim ~/.jupyter/jupyter_notebook_config.jso</code></pre>
<pre><code class="line-numbers language-bash">c.NotebookApp.ip=&#39;*&#39;                            # 默认localhost仅支持本地访问，修改为0.0.0.0或者*允许所有IP进行访问
c.NotebookApp.open_browser = False                # 启动自动打开浏览器，默认true
c.NotebookApp.port = 8888                        # 服务端口，默认8888，被占用可以自行调整
c.NotebookApp.notebook_dir = &#39;/root/code&#39;        # 根目录，不存在需手动创建文件夹
c.NotebookApp.allow_root = True                    # 允许以root用户运行</code></pre>
<pre><code class="line-numbers language-bash">jupyter notebook        # 运行</code></pre>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200430154113.png"></p>
<h4 id="2-3-登陆密码"><a href="#2-3-登陆密码" class="headerlink" title="2.3 登陆密码"></a>2.3 登陆密码</h4><p>远程使用一般会有一个登陆token，查看方法：</p>
<pre><code class="line-numbers language-bash">jupyter notebook list</code></pre>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200828171037.png"></p>
<h3 id="3-后台运行"><a href="#3-后台运行" class="headerlink" title="3. 后台运行"></a>3. 后台运行</h3><h4 id="3-1-使用后台运行"><a href="#3-1-使用后台运行" class="headerlink" title="3.1 使用后台运行"></a>3.1 使用后台运行</h4><p>直接运行jupyter notebook会导致两个问题：</p>
<ul>
<li>命令的log输出会阻塞占用一个terminal窗口</li>
<li>关闭terminal进程自动结束</li>
</ul>
<p>我们可以用<code>nohup</code>和<code>&amp;</code>两个命令结合解决这个问题</p>
<ul>
<li>nohup：将命令输出转入后台，默认保存到<code>./nohup.out</code></li>
<li>&amp;：后台运行命令，不受ctrl+C/Z的控制，但会前台显示输出，影响terminal的使用</li>
</ul>
<pre><code>nohup jupyter notebook &amp; </code></pre>
<p>这样jupyternotebook就会转到后台执行，logs会保存到<code>./nohup.out</code>，如果想保存到指定文件<code>./logs/jupyter.log</code></p>
<pre><code class="line-numbers language-bash">mkdir ./logs
nohup jupyter notebook 1&gt;./logs/jupyter.log 2&gt;&amp;1 &amp;</code></pre>
<p>操作系统中有三个常用的流： 0：标准输入流 stdin 1：标准输出流 stdout 2：标准错误流 stderr</p>
<p>对于上面的参数</p>
<ul>
<li><code>1&gt;file</code>：将标准输出流1重定向至文件file</li>
<li><code>2&gt;1&amp;</code>：将标准错误2重定向至标准输出1</li>
</ul>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200430151828.png"></p>
<h4 id="3-2-结束进程"><a href="#3-2-结束进程" class="headerlink" title="3.2 结束进程"></a>3.2 结束进程</h4><pre><code class="line-numbers language-bash"># 查询任务PID
jobs -l                            # 当前tty
ps aux | grep jupyter             # 任意tty</code></pre>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200430151901.png"></p>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200430152103.png"></p>
<pre><code class="line-numbers language-bash">kill -9 24891        # 结束任务</code></pre>
<h3 id="4-jupyter扩展（extension）"><a href="#4-jupyter扩展（extension）" class="headerlink" title="4. jupyter扩展（extension）"></a>4. jupyter扩展（extension）</h3><h4 id="4-1-安装扩展"><a href="#4-1-安装扩展" class="headerlink" title="4.1 安装扩展"></a>4.1 安装扩展</h4><pre><code class="line-numbers language-bash">pip install jupyter_contrib_nbextensions                # 安装nbextensions
jupyter contrib nbextension install --user                # 安装 javascript and css files
pip install jupyter_nbextensions_configurator            # 安装configurator</code></pre>
<p>网络超时可以选择另一种安装方式</p>
<pre><code class="line-numbers language-bash">pip install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master
jupyter contrib nbextension install --user 
pip install jupyter_nbextensions_configurator</code></pre>
<h4 id="4-2-好用的插件"><a href="#4-2-好用的插件" class="headerlink" title="4.2 好用的插件"></a>4.2 好用的插件</h4><ul>
<li>Collapsible Headings        可折叠标题</li>
<li>Code folding         代码折叠</li>
<li>Notify       任务完成通知</li>
<li>zenmode        禅模式</li>
<li>Table of Contents       添加目录</li>
<li>Hinterland         补全提示</li>
</ul>
<h3 id="5-排错"><a href="#5-排错" class="headerlink" title="5. 排错"></a>5. 排错</h3><h4 id="jupyter-notebook标题栏不显示extension"><a href="#jupyter-notebook标题栏不显示extension" class="headerlink" title="jupyter notebook标题栏不显示extension"></a>jupyter notebook标题栏不显示extension</h4><p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200430163959.png"></p>
<p>没有执行安装的第二步（安装 javascript and css files），执行一次就好了。。</p>
<h4 id="扩展是灰色的不可开启状态"><a href="#扩展是灰色的不可开启状态" class="headerlink" title="扩展是灰色的不可开启状态"></a>扩展是灰色的不可开启状态</h4><p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200430164100.png"></p>
<p>去掉disable的勾选</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux配置NodeJs环境方法</title>
    <url>/2019/Linux/ubuntu%E5%AE%89%E8%A3%85Nodejs%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>Ubuntu配置NodeJs环境的方法，手动安装理论适合所有发行版本</p>
<ul>
<li>自动安装</li>
<li>手动安装</li>
</ul>
<a id="more"></a>

<hr>
<h3 id="源安装方法"><a href="#源安装方法" class="headerlink" title="源安装方法"></a>源安装方法</h3><p>安装nodejs 12</p>
<pre><code class="line-numbers language-bash">curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -            # 安装nodejs官方源，12为nodejs的版本号，自由选择
sudo apt install nodejs -y
sudo apt install npm -y</code></pre>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200904223857.png"></p>
<p>安装yarn包管理器（manager）</p>
<pre><code class="line-numbers language-bash">curl -sL https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -
echo &quot;deb https://dl.yarnpkg.com/debian/ stable main&quot; | sudo tee /etc/apt/sources.list.d/yarn.list
sudo apt-get update &amp;&amp; sudo apt-get install yarn</code></pre>
<h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><p>下载解压</p>
<pre><code class="line-numbers language-bash">wget https://nodejs.org/dist/v12.18.3/node-v12.18.3-linux-x64.tar.xz
tar xvf node-v12.18.3-linux-x64.tar.xz
mv node-v12.18.3-linux-x64 node 
sudo mkdir /opt/env &amp;&amp; sudo mv node /opt/env
sudo chmod 777 -R /opt/env/node</code></pre>
<p>测试</p>
<pre><code class="line-numbers language-bash">/opt/env/node/bin/node --version
/opt/env/node/bin/npm --version</code></pre>
<p>添加环境变量</p>
<pre><code class="line-numbers language-shell">sudo vim /etc/profile.d/node.sh
# add
export PATH=$PATH:/opt/env/node/bin</code></pre>
<p>测试</p>
<pre><code class="line-numbers language-bash">node -v
npm -v</code></pre>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据类型分析及常用方法</title>
    <url>/2019/Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<a id="more"></a>

<hr>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署httpbin网络测试服务</title>
    <url>/2019/Docker/Docker%E9%83%A8%E7%BD%B2httpbin%E5%8F%8A%E5%B8%B8%E7%94%A8API/</url>
    <content><![CDATA[<p>httpbin是大神kennethreitz为搭建测试用的http服务而写的一个开源项目，httpbin 这个服务应用能测试HTTP请求及响应的各种信息，比如 cookie、ip、headers 和登录验证等，且支持 GET、POST 等多种方法，对 web 开发和测试具有很大的帮助。</p>
<a id="more"></a>

<h4 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h4><p>假设你服务器的公网IP为1.2.3.4，那么部署成功后httpbin服务应该开放在1.2.3.4:81上</p>
<pre><code class="line-numbers language-bash">docker pull kennethreitz/httpbin
docker run -d -p 81:80 --restart=always kennethreitz/httpbin </code></pre>
<h4 id="API使用方法"><a href="#API使用方法" class="headerlink" title="API使用方法"></a>API使用方法</h4><p>查询本地IP</p>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200721222836.png"></p>
<h4 id="Python使用案例"><a href="#Python使用案例" class="headerlink" title="Python使用案例"></a>Python使用案例</h4><p>比如说测试一个代理的有效性，可以使用</p>
<pre><code class="line-numbers language-python">import requests

# 待测试代理
proxy = &#39;http://10.11.12.13:8888&#39;

log = None

try:
    log = requests.get(&#39;http://aliyun:81/ip&#39;, proxies=&#123;&#39;http&#39;: proxy&#125;, timeout=5).text
except:
    log = &quot;无效代理&quot;

print(log)      # 无效代理</code></pre>
<h4 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h4><p>假设服务器IP已在本地映射为aliyun</p>
<p>/ This page.<br> /ip Returns Origin IP.<br> /user-agent Returns user-agent.<br> /headers Returns header dict.<br> /get Returns GET data.<br> /post Returns POST data.<br> /patch Returns PATCH data.<br> /put Returns PUT data.<br> /delete Returns DELETE data<br> /anything Returns request data, including method used.<br> /anything/:anything Returns request data, including the URL.<br> /encoding/utf8 Returns page containing UTF-8 data.<br> /gzip Returns gzip-encoded data.<br> /deflate Returns deflate-encoded data.<br> /brotli Returns brotli-encoded data.<br> /status/:code Returns given HTTP Status code.<br> /response-headers?key=val Returns given response headers.<br> /redirect/:n 302 Redirects n times.<br> /redirect-to?url=foo 302 Redirects to the foo URL.<br> /redirect-to?url=foo&amp;status_code=307 307 Redirects to the foo URL.<br> /relative-redirect/:n 302 Relative redirects n times.<br> /absolute-redirect/:n 302 Absolute redirects n times.<br> /cookies Returns cookie data.<br> /cookies/set?name=value Sets one or more simple cookies.<br> /cookies/delete?name Deletes one or more simple cookies.<br> /basic-auth/:user/:passwd Challenges HTTPBasic Auth.<br> /hidden-basic-auth/:user/:passwd 404’d BasicAuth.<br> /digest-auth/:qop/:user/:passwd/:algorithm Challenges HTTP Digest Auth.<br> /digest-auth/:qop/:user/:passwd Challenges HTTP Digest Auth.<br> /stream/:n Streams min(n, 100) lines.<br> /delay/:n Delays responding for min(n, 10) seconds.<br> /drip?numbytes=n&amp;duration=s&amp;delay=s&amp;code=code Drips data  over a duration after an optional initial delay, then (optionally)  returns with the given status code.<br> /range/1024?duration=s&amp;chunk_size=code Streams n bytes, and allows  specifying a Range header to select a subset of the data. Accepts a  chunk_size and request duration parameter.<br> /html Renders an HTML Page.<br> /robots.txt Returns some robots.txt rules.<br> /deny Denied by robots.txt file.<br> /cache Returns 200 unless an If-Modified-Since or If-None-Match header is provided, when it returns a 304.<br> /etag/:etag Assumes the resource has the given etag and responds to  If-None-Match header with a 200 or 304 and If-Match with a 200 or 412 as appropriate.<br> /cache/:n Sets a Cache-Control header for n seconds.<br> /bytes/:n Generates n random bytes of binary data, accepts optional seed integer parameter.<br> /stream-bytes/:n Streams n random bytes of binary data in chunked  encoding, accepts optional seed and chunk_size integer parameters.<br> /links/:n Returns page containing n HTML links.<br> /image Returns page containing an image based on sent Accept header.<br> /image/png Returns a PNG image.<br> /image/jpeg Returns a JPEG image.<br> /image/webp Returns a WEBP image.<br> /image/svg Returns a SVG image.<br> /forms/post HTML form that submits to /post<br> /xml Returns some XML</p>
<blockquote>
<p>httpbin是大神kennethreitz为搭建测试用的http服务而写的一个开源项目，httpbin 这个服务应用能测试HTTP请求及响应的各种信息，比如 cookie、ip、headers 和登录验证等，且支持 GET、POST 等多种方法，对 web 开发和测试具有很大的帮助，它是用 Python + Flask 编写的.</p>
<p>Kenneth Reitz: 著名的python首席架构师，requests、python-guide、pipenv、legit、autoenv等一系列大名鼎鼎的python类库及工具的创作者，大神级程序员，据说其身价高达5亿美元。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据库·Python API</title>
    <url>/2019/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E7%AC%94%E8%AE%B0%C2%B7PythonAPI/</url>
    <content><![CDATA[</br>

<p>redis库是python操作redis数据库的接口库</p>
<pre><code class="line-numbers language-bash">pip install redis</code></pre>
<a id="more"></a>



<h2 id="1-连接Redis"><a href="#1-连接Redis" class="headerlink" title="1. 连接Redis"></a>1. 连接Redis</h2><h3 id="1-1-普通连接"><a href="#1-1-普通连接" class="headerlink" title="1.1 普通连接"></a>1.1 普通连接</h3><p>redis模块提供了两个类用于构建redis数据库连接对象</p>
<ul>
<li><p>redis.StructRedis：日常使用该类即可，redis命令行client的大部分命令都可以通过该类构建的对象执行，如</p>
<pre><code>import redis

conn = redis.StructRedis(host=&#39;127.0.0.1&#39;, port=6379, db=1, decode_responses=True)

conn.keys(&#39;*&#39;)
# [&#39;key1&#39;, &#39;key2&#39;]</code></pre>
<p>decode_responses=True：表示将返回的二进制数据进行解码，b’key1’–&gt;”key1”</p>
</li>
<li><p>redis.Redis：StructRedis的子类，为了向后兼容低版本redis，并不常用</p>
</li>
</ul>
<h3 id="1-2-创建连接池"><a href="#1-2-创建连接池" class="headerlink" title="1.2 创建连接池"></a>1.2 创建连接池</h3><pre><code class="line-numbers language-python"># 使用默认方式连接到数据库
pool = redis.ConnectionPool(host=&#39;127.0.0.1&#39;, port=6379, db=0)
conn = redis.StrictRedis(connection_pool=pool)</code></pre>
<h3 id="1-3-redis-url方式连接到数据库"><a href="#1-3-redis-url方式连接到数据库" class="headerlink" title="1.3 redis url方式连接到数据库"></a>1.3 redis url方式连接到数据库</h3><p>RedisUrl类型</p>
<pre><code>redis://[:password]@host:port/db    # TCP连接
rediss://[:password]@host:port/db   # Redis TCP+SSL 连接
unix://[:password]@/path/to/socket.sock?db=db    # Redis Unix Socket 连接</code></pre>
<p>连接方法</p>
<pre><code class="line-numbers language-python"># 普通连接
conn = redis.StrictRedis(connection_pool=pool)
# 连接池
conn = redis.ConnectionPool.from_url(&#39;redis://@localhost:6379/1&#39;)</code></pre>
<h2 id="2-redis对象api"><a href="#2-redis对象api" class="headerlink" title="2. redis对象api"></a>2. redis对象api</h2><h3 id="String操作"><a href="#String操作" class="headerlink" title="String操作"></a>String操作</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>示例</th>
<th>示例结果</th>
</tr>
</thead>
<tbody><tr>
<td>set(name, value)</td>
<td>给name赋值为value</td>
<td>redis.set(‘name’, ‘Bob’)</td>
<td>True</td>
</tr>
<tr>
<td>get(name)</td>
<td>返回数据库中key为name的string的value</td>
<td>redis.get(‘name’)</td>
<td>b’Bob’</td>
</tr>
<tr>
<td>getset(name, value)</td>
<td>给数据库中key为name的string赋予值value并返回上次的value</td>
<td>redis.getset(‘name’, ‘Mike’)</td>
<td>b’Bob’</td>
</tr>
<tr>
<td>mget(keys, *args)</td>
<td>返回多个key对应的value</td>
<td>redis.mget([‘name’, ‘nickname’])</td>
<td>[b’Mike’, b’Miker’]</td>
</tr>
<tr>
<td>setnx(name, value)</td>
<td>如果key不存在才设置value</td>
<td>redis.setnx(‘newname’, ‘James’)</td>
<td>第一次运行True，第二次False</td>
</tr>
<tr>
<td>setex(name, time, value)</td>
<td>设置可以对应的值为string类型的value，并指定此键值对应的有效期</td>
<td>redis.setex(‘name’, 1, ‘James’)</td>
<td>True</td>
</tr>
<tr>
<td>setrange(name, offset, value)</td>
<td>设置指定key的value值的子字符串</td>
<td>redis.set(‘name’, ‘Hello’) redis.setrange(‘name’, 6, ‘World’)</td>
<td>11，修改后的字符串长度</td>
</tr>
<tr>
<td>mset(mapping)</td>
<td>批量赋值</td>
<td>redis.mset({‘name1’: ‘Durant’, ‘name2’: ‘James’})</td>
<td>True</td>
</tr>
<tr>
<td>msetnx(mapping)</td>
<td>key均不存在时才批量赋值</td>
<td>redis.msetnx({‘name3’: ‘Smith’, ‘name4’: ‘Curry’})</td>
<td>True</td>
</tr>
<tr>
<td>incr(name, amount=1)</td>
<td>key为name的value增值操作，默认1，key不存在则被创建并设为amount</td>
<td>redis.incr(‘age’, 1)</td>
<td>1，即修改后的值</td>
</tr>
<tr>
<td>decr(name, amount=1)</td>
<td>key为name的value减值操作，默认1，key不存在则被创建并设置为-amount</td>
<td>redis.decr(‘age’, 1)</td>
<td>-1，即修改后的值</td>
</tr>
<tr>
<td>append(key, value)</td>
<td>key为name的string的值附加value</td>
<td>redis.append(‘nickname’, ‘OK’)</td>
<td>13，即修改后的字符串长度</td>
</tr>
<tr>
<td>substr(name, start, end=-1)</td>
<td>返回key为name的string的value的子串</td>
<td>redis.substr(‘name’, 1, 4)</td>
<td>b’ello’</td>
</tr>
<tr>
<td>getrange(key, start, end)</td>
<td>获取key的value值从start到end的子字符串</td>
<td>redis.getrange(‘name’, 1, 4)</td>
<td>b’ello’</td>
</tr>
</tbody></table>
<h3 id="Key操作"><a href="#Key操作" class="headerlink" title="Key操作"></a>Key操作</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>示例</th>
<th>示例结果</th>
</tr>
</thead>
<tbody><tr>
<td>exists(name)</td>
<td>判断一个key是否存在</td>
<td>redis.exists(‘name’)</td>
<td>True</td>
</tr>
<tr>
<td>delete(name)</td>
<td>删除一个key</td>
<td>redis.delete(‘name’)</td>
<td>1</td>
</tr>
<tr>
<td>type(name)</td>
<td>判断key类型</td>
<td>redis.type(‘name’)</td>
<td>b’string’</td>
</tr>
<tr>
<td>keys(pattern)</td>
<td>获取所有符合规则的key</td>
<td>redis.keys(‘n*’)</td>
<td>[b’name’]</td>
</tr>
<tr>
<td>randomkey()</td>
<td>获取随机的一个key</td>
<td>randomkey()</td>
<td>b’name’</td>
</tr>
<tr>
<td>rename(src, dst)</td>
<td>将key重命名</td>
<td>redis.rename(‘name’, ‘nickname’)</td>
<td>True</td>
</tr>
<tr>
<td>dbsize()</td>
<td>获取当前数据库中key的数目</td>
<td>dbsize()</td>
<td>100</td>
</tr>
<tr>
<td>expire(name, time)</td>
<td>设定key的过期时间，单位秒</td>
<td>redis.expire(‘name’, 2)</td>
<td>True</td>
</tr>
<tr>
<td>ttl(name)</td>
<td>获取key的过期时间，单位秒，-1为永久不过期</td>
<td>redis.ttl(‘name’)</td>
<td>-1</td>
</tr>
<tr>
<td>move(name, db)</td>
<td>将key移动到其他数据库</td>
<td>move(‘name’, 2)</td>
<td>True</td>
</tr>
<tr>
<td>flushdb()</td>
<td>删除当前选择数据库中的所有key</td>
<td>flushdb()</td>
<td>True</td>
</tr>
<tr>
<td>flushall()</td>
<td>删除所有数据库中的所有key</td>
<td>flushall()</td>
<td>True</td>
</tr>
</tbody></table>
<h3 id="List操作"><a href="#List操作" class="headerlink" title="List操作"></a>List操作</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>示例</th>
<th>示例结果</th>
</tr>
</thead>
<tbody><tr>
<td>rpush(name, *values)</td>
<td>在key为name的list尾添加值为value的元素，可以传多个</td>
<td>redis.rpush(‘list’, 1, 2, 3)</td>
<td>3，list大小</td>
</tr>
<tr>
<td>lpush(name, *values)</td>
<td>在key为name的list头添加值为value的元素，可以传多个</td>
<td>redis.lpush(‘list’, 0)</td>
<td>4，list大小</td>
</tr>
<tr>
<td>llen(name)</td>
<td>返回key为name的list的长度</td>
<td>redis.llen(‘list’)</td>
<td>4</td>
</tr>
<tr>
<td>lrange(name, start, end)</td>
<td>返回key为name的list中start至end之间的元素</td>
<td>redis.lrange(‘list’, 1, 3)</td>
<td>[b’3’, b’2’, b’1’]</td>
</tr>
<tr>
<td>ltrim(name, start, end)</td>
<td>截取key为name的list，保留索引为start到end的内容</td>
<td>ltrim(‘list’, 1, 3)</td>
<td>True</td>
</tr>
<tr>
<td>lindex(name, index)</td>
<td>返回key为name的list中index位置的元素</td>
<td>redis.lindex(‘list’, 1)</td>
<td>b’2’</td>
</tr>
<tr>
<td>lset(name, index, value)</td>
<td>给key为name的list中index位置的元素赋值，越界则报错</td>
<td>redis.lset(‘list’, 1, 5)</td>
<td>True</td>
</tr>
<tr>
<td>lrem(name, count, value)</td>
<td>删除count个key的list中值为value的元素</td>
<td>redis.lrem(‘list’, 2, 3)</td>
<td>1，即删除的个数</td>
</tr>
<tr>
<td>lpop(name)</td>
<td>返回并删除key为name的list中的首元素</td>
<td>redis.lpop(‘list’)</td>
<td>b’5’</td>
</tr>
<tr>
<td>rpop(name)</td>
<td>返回并删除key为name的list中的尾元素</td>
<td>redis.rpop(‘list’)</td>
<td>b’2’</td>
</tr>
<tr>
<td>blpop(keys, timeout=0)</td>
<td>返回并删除名称为在keys中的list中的首元素，如果list为空，则会一直阻塞等待</td>
<td>redis.blpop(‘list’)</td>
<td>[b’5’]</td>
</tr>
<tr>
<td>brpop(keys, timeout=0)</td>
<td>返回并删除key为name的list中的尾元素，如果list为空，则会一直阻塞等待</td>
<td>redis.brpop(‘list’)</td>
<td>[b’2’]</td>
</tr>
<tr>
<td>rpoplpush(src, dst)</td>
<td>返回并删除名称为src的list的尾元素，并将该元素添加到名称为dst的list的头部</td>
<td>redis.rpoplpush(‘list’, ‘list2’)</td>
<td>b’2’</td>
</tr>
</tbody></table>
<h3 id="Set操作"><a href="#Set操作" class="headerlink" title="Set操作"></a>Set操作</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>示例</th>
<th>示例结果</th>
</tr>
</thead>
<tbody><tr>
<td>sadd(name, *values)</td>
<td>向key为name的set中添加元素</td>
<td>redis.sadd(‘tags’, ‘Book’, ‘Tea’, ‘Coffee’)</td>
<td>3，即插入的数据个数</td>
</tr>
<tr>
<td>srem(name, *values)</td>
<td>从key为name的set中删除元素</td>
<td>redis.srem(‘tags’, ‘Book’)</td>
<td>1，即删除的数据个数</td>
</tr>
<tr>
<td>spop(name)</td>
<td>随机返回并删除key为name的set中一个元素</td>
<td>redis.spop(‘tags’)</td>
<td>b’Tea’</td>
</tr>
<tr>
<td>smove(src, dst, value)</td>
<td>从src对应的set中移除元素并添加到dst对应的set中</td>
<td>redis.smove(‘tags’, ‘tags2’, ‘Coffee’)</td>
<td>True</td>
</tr>
<tr>
<td>scard(name)</td>
<td>返回key为name的set的元素个数</td>
<td>redis.scard(‘tags’)</td>
<td>3</td>
</tr>
<tr>
<td>sismember(name, value)</td>
<td>测试member是否是key为name的set的元素</td>
<td>redis.sismember(‘tags’, ‘Book’)</td>
<td>True</td>
</tr>
<tr>
<td>sinter(keys, *args)</td>
<td>返回所有给定key的set的交集</td>
<td>redis.sinter([‘tags’, ‘tags2’])</td>
<td>{b’Coffee’}</td>
</tr>
<tr>
<td>sinterstore(dest, keys, *args)</td>
<td>求交集并将交集保存到dest的集合</td>
<td>redis.sinterstore(‘inttag’, [‘tags’, ‘tags2’])</td>
<td>1</td>
</tr>
<tr>
<td>sunion(keys, *args)</td>
<td>返回所有给定key的set的并集</td>
<td>redis.sunion([‘tags’, ‘tags2’])</td>
<td>{b’Coffee’, b’Book’, b’Pen’}</td>
</tr>
<tr>
<td>sunionstore(dest, keys, *args)</td>
<td>求并集并将并集保存到dest的集合</td>
<td>redis.sunionstore(‘inttag’, [‘tags’, ‘tags2’])</td>
<td>3</td>
</tr>
<tr>
<td>sdiff(keys, *args)</td>
<td>返回所有给定key的set的差集</td>
<td>redis.sdiff([‘tags’, ‘tags2’])</td>
<td>{b’Book’, b’Pen’}</td>
</tr>
<tr>
<td>sdiffstore(dest, keys, *args)</td>
<td>求差集并将差集保存到dest的集合</td>
<td>redis.sdiffstore(‘inttag’, [‘tags’, ‘tags2’])</td>
<td>3</td>
</tr>
<tr>
<td>smembers(name)</td>
<td>返回key为name的set的所有元素</td>
<td>redis.smembers(‘tags’)</td>
<td>{b’Pen’, b’Book’, b’Coffee’}</td>
</tr>
<tr>
<td>srandmember(name)</td>
<td>随机返回key为name的set的一个元素，但不删除元素</td>
<td>redis.srandmember(‘tags’)</td>
<td></td>
</tr>
</tbody></table>
<h3 id="Sorted-Set操作"><a href="#Sorted-Set操作" class="headerlink" title="Sorted Set操作"></a>Sorted Set操作</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>示例</th>
<th>示例结果</th>
</tr>
</thead>
<tbody><tr>
<td>zadd(name, args, *kwargs)</td>
<td>向key为name的zset中添加元素member，score用于排序。如果该元素存在，则更新其顺序</td>
<td>redis.zadd(‘grade’, 100, ‘Bob’, 98, ‘Mike’)</td>
<td>2，即添加的元素个数</td>
</tr>
<tr>
<td>zrem(name, *values)</td>
<td>删除key为name的zset中的元素</td>
<td>redis.zrem(‘grade’, ‘Mike’)</td>
<td>1，即删除的元素个数</td>
</tr>
<tr>
<td>zincrby(name, value, amount=1)</td>
<td>如果在key为name的zset中已经存在元素value，则该元素的score增加amount，否则向该集合中添加该元素，其score的值为amount</td>
<td>redis.zincrby(‘grade’, ‘Bob’, -2)</td>
<td>98.0，即修改后的值</td>
</tr>
<tr>
<td>zrank(name, value)</td>
<td>返回key为name的zset中元素的排名（按score从小到大排序）即下标</td>
<td>redis.zrank(‘grade’, ‘Amy’)</td>
<td>1</td>
</tr>
<tr>
<td>zrevrank(name, value)</td>
<td>返回key为name的zset中元素的倒数排名（按score从大到小排序）即下标</td>
<td>redis.zrevrank(‘grade’, ‘Amy’)</td>
<td>2</td>
</tr>
<tr>
<td>zrevrange(name, start, end, withscores=False)</td>
<td>返回key为name的zset（按score从大到小排序）中的index从start到end的所有元素</td>
<td>redis.zrevrange(‘grade’, 0, 3)</td>
<td>[b’Bob’, b’Mike’, b’Amy’, b’James’]</td>
</tr>
<tr>
<td>zrangebyscore(name, min, max, start=None, num=None, withscores=False)</td>
<td>返回key为name的zset中score在给定区间的元素</td>
<td>redis.zrangebyscore(‘grade’, 80, 95)</td>
<td>[b’Amy’, b’James’]</td>
</tr>
<tr>
<td>zcount(name, min, max)</td>
<td>返回key为name的zset中score在给定区间的数量</td>
<td>redis.zcount(‘grade’, 80, 95)</td>
<td>2</td>
</tr>
<tr>
<td>zcard(name)</td>
<td>返回key为name的zset的元素个数</td>
<td>redis.zcard(‘grade’)</td>
<td>3</td>
</tr>
<tr>
<td>zremrangebyrank(name, min, max)</td>
<td>删除key为name的zset中排名在给定区间的元素</td>
<td>redis.zremrangebyrank(‘grade’, 0, 0)</td>
<td>1，即删除的元素个数</td>
</tr>
<tr>
<td>zremrangebyscore(name, min, max)</td>
<td>删除key为name的zset中score在给定区间的元素</td>
<td>redis.zremrangebyscore(‘grade’, 80, 90)</td>
<td>1，即删除的元素个数</td>
</tr>
</tbody></table>
<h3 id="Hash操作"><a href="#Hash操作" class="headerlink" title="Hash操作"></a>Hash操作</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>示例</th>
<th>示例结果</th>
</tr>
</thead>
<tbody><tr>
<td>hset(name, key, value)</td>
<td>向key为name的hash中添加映射</td>
<td>hset(‘price’, ‘cake’, 5)</td>
<td>1，即添加的映射个数</td>
</tr>
<tr>
<td>hsetnx(name, key, value)</td>
<td>向key为name的hash中添加映射，如果映射键名不存在</td>
<td>hsetnx(‘price’, ‘book’, 6)</td>
<td>1，即添加的映射个数</td>
</tr>
<tr>
<td>hget(name, key)</td>
<td>返回key为name的hash中field对应的value</td>
<td>redis.hget(‘price’, ‘cake’)</td>
<td>5</td>
</tr>
<tr>
<td>hmget(name, keys, *args)</td>
<td>返回key为name的hash中各个键对应的value</td>
<td>redis.hmget(‘price’, [‘apple’, ‘orange’])</td>
<td>[b’3’, b’7’]</td>
</tr>
<tr>
<td>hmset(name, mapping)</td>
<td>向key为name的hash中批量添加映射</td>
<td>redis.hmset(‘price’, {‘banana’: 2, ‘pear’: 6})</td>
<td>True</td>
</tr>
<tr>
<td>hincrby(name, key, amount=1)</td>
<td>将key为name的hash中映射的value增加amount</td>
<td>redis.hincrby(‘price’, ‘apple’, 3)</td>
<td>6，修改后的值</td>
</tr>
<tr>
<td>hexists(name, key)</td>
<td>key为namehash中是否存在键名为key的映射</td>
<td>redis.hexists(‘price’, ‘banana’)</td>
<td>True</td>
</tr>
<tr>
<td>hdel(name, *keys)</td>
<td>key为namehash中删除键名为key的映射</td>
<td>redis.hdel(‘price’, ‘banana’)</td>
<td>True</td>
</tr>
<tr>
<td>hlen(name)</td>
<td>从key为name的hash中获取映射个数</td>
<td>redis.hlen(‘price’)</td>
<td>6</td>
</tr>
<tr>
<td>hkeys(name)</td>
<td>从key为name的hash中获取所有映射键名</td>
<td>redis.hkeys(‘price’)</td>
<td>[b’cake’, b’book’, b’banana’, b’pear’]</td>
</tr>
<tr>
<td>hvals(name)</td>
<td>从key为name的hash中获取所有映射键值</td>
<td>redis.hvals(‘price’)</td>
<td>[b’5’, b’6’, b’2’, b’6’]</td>
</tr>
<tr>
<td>hgetall(name)</td>
<td>从key为name的hash中获取所有映射键值对</td>
<td>redis.hgetall(‘price’)</td>
<td>{b’cake’: b’5’, b’book’: b’6’, b’orange’: b’7’, b’pear’: b’6’}</td>
</tr>
<tr>
<td>                                                                                     </td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现经典排序算法</title>
    <url>/2018/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>已经学习并实现：冒泡、选择、插入、快速、堆、归并</p>
<p>待实现：希尔、计数、桶</p>
<a id="more"></a>

<hr>
<p><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200804150652.png"></p>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><p>冒泡排序是稳定的内部排序算法，时间复杂度为N（有序）~ n^2（反序），排序思想是</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
<pre><code class="line-numbers language-python">def bubble_sort(array):
    &quot;&quot;&quot;
    冒泡排序
    &quot;&quot;&quot;
    for i in range(0, len(array)):    # 控制选择无序区
        for j in range(0, len(array) - i - 1):    # 无序区元素比较
            if array[j] &gt; array[j + 1]:    # 浮现元素到有序区一侧，--&gt;
                array[j + 1], array[j] = array[j], array[j + 1]
    return array</code></pre>
<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。算法思想为：</p>
<ul>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ul>
<pre><code class="line-numbers language-python">def selection_sort(array):
    &quot;&quot;&quot;
    选择排序
    &quot;&quot;&quot;
    for i in range(len(array)-1):
        flag = i
        for j in range(i+1, len(array)):
            if array[j] &lt; array[flag]:
                flag = j
        array[i], array[flag] = array[flag], array[i]
    return array</code></pre>
<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><p>工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
<pre><code class="line-numbers language-python">def insert_sort(array):
    &quot;&quot;&quot;
    插入排序
    &quot;&quot;&quot;
    for i in range(1, len(array)):
        pointer, cur = i - 1, array[i]
        while pointer &gt;= 0 and array[pointer] &gt; cur:
            array[pointer+1] = array[pointer]
            pointer -= 1
        array[pointer+1] = cur
    return array</code></pre>
<h2 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4. 堆排序"></a>4. 堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<ul>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<pre><code class="line-numbers language-python">def heapify(array, length, i):
    &quot;&quot;&quot;堆化&quot;&quot;&quot;
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    if left &lt; length and array[largest] &lt; array[left]:
        largest = left
    if right &lt; length and array[largest] &lt; array[right]:
        largest = right
    if largest != i:
        array[i], array[largest] = array[largest], array[i]
        heapify(array, length, largest)

def heap_sort(array):
    &quot;&quot;&quot;堆排序&quot;&quot;&quot;
    length = len(array)
    for i in range(length, -1, -1):
        heapify(array, length, i)
    for i in range(length-1, 0, -1):
        array[i], array[0] = array[0], array[i]
        heapify(array, i, 0)
    return array</code></pre>
<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and  Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>
<p>Python风格的实现方式</p>
<pre><code class="line-numbers language-python">def merge_sort(array):
    &quot;&quot;&quot;
    归并排序
    &quot;&quot;&quot;
    if len(array) &lt; 2:
        return array
    flag = array.pop()
    left = [i for i in array if i &lt;= flag]
    right = [i for i in array if i &gt; flag]
    # print(left, flag, right)
    return merge_sort(left) + [flag] + merge_sort(right)</code></pre>
<p>测试</p>
<pre><code class="line-numbers language-python">if __name__ == &#39;__main__&#39;:
    import random
    array = random.sample(range(99), 10)
    print(array)
    print(merge_sort(array.copy()))

# [83, 3, 28, 33, 5, 7, 24, 8, 11, 51]
# [3, 28, 33, 5, 7, 24, 8, 11] 51 [83]
# [3, 5, 7, 8] 11 [28, 33, 24]
# [3, 5, 7] 8 []
# [3, 5] 7 []
# [3] 5 []
# [] 24 [28, 33]
# [28] 33 []
# [3, 5, 7, 8, 11, 24, 28, 33, 51, 83]</code></pre>
<h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<pre><code class="line-numbers language-python">def quick_sort(array, left, right):
    if left &gt;= right:
        return array
    pivot, i, j = array[left], left, right
    while i &lt; j:
        while i &lt; j and array[j] &gt;= pivot:
            j -= 1
        array[i] = array[j]
        while i &lt; j and array[i] &lt;= pivot:
            i += 1
        array[j] = array[i]
    array[j] = pivot
    quick_sort(array, left, i-1)
    quick_sort(array, i+1, right)
    return array</code></pre>
<h2 id="7-希尔排序"><a href="#7-希尔排序" class="headerlink" title="7. 希尔排序"></a>7. 希尔排序</h2><p>···</p>
<h2 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h2><p>···</p>
<h2 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h2><p>···</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔问题</title>
    <url>/2018/%E7%AE%97%E6%B3%95/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>11</p>
<a id="more"></a>

<h3 id="1-起源"><a href="#1-起源" class="headerlink" title="1. 起源"></a>1. 起源</h3><p>汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklODclOTElRTUlODglOUElRTclOUYlQjMvODA2OTg=">金刚石<i class="fa fa-external-link-alt"></i></span>柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<h3 id="2-数学归纳"><a href="#2-数学归纳" class="headerlink" title="2. 数学归纳"></a>2. 数学归纳</h3><p>有三根相邻的柱子，标号为A,B,C，A柱子上从下到上按金字塔状叠放着n个不同大小的圆盘，要把所有盘子移动到C上，并且每次移动同一根柱子上都不能出现大盘子在小盘子上方，请问至少需要多少次移动，设移动次数为H(n）。</p>
<h4 id="1-1-移动"><a href="#1-1-移动" class="headerlink" title="1.1 移动"></a>1.1 移动</h4><img src="https://gitee.com/yuandongxu/mydata/raw/master/image/20200412095910.jpg" style="zoom:80%;" />

<ul>
<li><p>1个盘子</p>
<p><strong>盘1，A –&gt; C</strong></p>
</li>
<li><p>2个盘子</p>
<p>盘1，A –&gt; B</p>
<p><strong>盘2，A –&gt; C</strong></p>
<p>盘1，B –&gt; C</p>
</li>
<li><p>···</p>
</li>
</ul>
<h4 id="2-2-归纳"><a href="#2-2-归纳" class="headerlink" title="2.2 归纳"></a>2.2 归纳</h4><p>运用归纳法进行归纳，可以将盘子的移动过程归纳为三次移动：</p>
<ol>
<li>将n-1个盘子从A借助C移动到B上</li>
<li>将n号盘移动到C上</li>
<li>将n-1个盘子从B借助A移动到C上</li>
</ol>
<p>也就是说总的移动次数H(n)：<br>$$<br>H(n) = H(n-1) + 1 + H(n-1)</p>
<p>H(n) = 2^n - 1<br>$$<br>由此可见这个问题就是一个递归求解的过程</p>
<h3 id="3-什么是递归"><a href="#3-什么是递归" class="headerlink" title="3. 什么是递归"></a>3. 什么是递归</h3><p>递归，即自己调用自己，能用递归处理的问题具有两个必要条件</p>
<ol>
<li><p>将较大规模问题能够转化为较小规模的问题。</p>
</li>
<li><p>存在递归的终止条件。</p>
</li>
</ol>
<h3 id="4-Python实现"><a href="#4-Python实现" class="headerlink" title="4. Python实现"></a>4. Python实现</h3><p>逻辑</p>
<pre><code class="line-numbers language-python">def move(x, a, b, c):
    if x == 1:
        print(&quot;&#123;&#125; --&gt; &#123;&#125;&quot;.format(a, c))
    else:
        move(x - 1, a, c, b)
        print(&quot;&#123;&#125; --&gt; &#123;&#125;&quot;.format(a, c))
        move(x - 1, b, a, c)

move(3, &quot;A&quot;, &quot;B&quot; , &quot;C&quot;)

# A --&gt; C
# A --&gt; B
# C --&gt; B
# A --&gt; C
# B --&gt; A
# B --&gt; C
# A --&gt; C</code></pre>
<p>完善版本</p>
<pre><code class="line-numbers language-python">class TowerOfHanoi:

    def __init__(self):
        self.time = 0

    def move(self, n, a, b):
        # 移动函数
        self.time += 1
        print(&quot;第&#123;&#125;次移动：将 &#123;&#125; 号碟从 &#123;&#125; 移动到 &#123;&#125;&quot;.format(self.time, n, a, b))
    def hanoi(self, n, a, b, c):
        # 主体逻辑函数
        if n == 1:
            self.move(1, a, c)
        else:
            self.hanoi(n-1, a, c, b)
            self.move(n, a, c)
            self.hanoi(n-1, b, a, c)

t = TowerOfHanoi()
t.hanoi(3, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;)

# 第1次移动：将 1 号碟从 A 移动到 C
# 第2次移动：将 2 号碟从 A 移动到 B
# 第3次移动：将 1 号碟从 C 移动到 B
# 第4次移动：将 3 号碟从 A 移动到 C
# 第5次移动：将 1 号碟从 B 移动到 A
# 第6次移动：将 2 号碟从 B 移动到 C
# 第7次移动：将 1 号碟从 A 移动到 C
</code></pre>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
